/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package org.apache.cassandra.service;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;

import org.apache.thrift.protocol.*;
import org.apache.thrift.transport.*;

public class Cassandra {

  public interface Iface {

    public List<column_t> get_slice(String tablename, String key, String columnFamily_column, int start, int count) throws CassandraException, TException;

    public List<column_t> get_slice_by_names(String tablename, String key, String columnFamily, List<String> columnNames) throws CassandraException, TException;

    public column_t get_column(String tablename, String key, String columnFamily_column) throws CassandraException, TException;

    public int get_column_count(String tablename, String key, String columnFamily_column) throws CassandraException, TException;

    public void insert(String tablename, String key, String columnFamily_column, byte[] cellData, long timestamp) throws TException;

    public void batch_insert(batch_mutation_t batchMutation) throws TException;

    public boolean batch_insert_blocking(batch_mutation_t batchMutation) throws CassandraException, TException;

    public boolean remove(String tablename, String key, String columnFamily_column, long timestamp, boolean block) throws TException;

    public List<column_t> get_columns_since(String tablename, String key, String columnFamily_column, long timeStamp) throws CassandraException, TException;

    public List<superColumn_t> get_slice_super(String tablename, String key, String columnFamily_superColumnName, int start, int count) throws CassandraException, TException;

    public List<superColumn_t> get_slice_super_by_names(String tablename, String key, String columnFamily, List<String> superColumnNames) throws CassandraException, TException;

    public superColumn_t get_superColumn(String tablename, String key, String columnFamily) throws CassandraException, TException;

    public void batch_insert_superColumn(batch_mutation_super_t batchMutationSuper) throws TException;

    public boolean batch_insert_superColumn_blocking(batch_mutation_super_t batchMutationSuper) throws CassandraException, TException;

    public void touch(String key, boolean fData) throws TException;

    public String getStringProperty(String propertyName) throws TException;

    public List<String> getStringListProperty(String propertyName) throws TException;

    public String describeTable(String tableName) throws TException;

    public CqlResult_t executeQuery(String query) throws TException;

  }

  public static class Client implements Iface {
    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public List<column_t> get_slice(String tablename, String key, String columnFamily_column, int start, int count) throws CassandraException, TException
    {
      send_get_slice(tablename, key, columnFamily_column, start, count);
      return recv_get_slice();
    }

    public void send_get_slice(String tablename, String key, String columnFamily_column, int start, int count) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_slice", TMessageType.CALL, seqid_));
      get_slice_args args = new get_slice_args();
      args.tablename = tablename;
      args.key = key;
      args.columnFamily_column = columnFamily_column;
      args.start = start;
      args.count = count;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<column_t> recv_get_slice() throws CassandraException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_slice_result result = new get_slice_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.__isset.success) {
        return result.success;
      }
      if (result.__isset.e) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_slice failed: unknown result");
    }

    public List<column_t> get_slice_by_names(String tablename, String key, String columnFamily, List<String> columnNames) throws CassandraException, TException
    {
      send_get_slice_by_names(tablename, key, columnFamily, columnNames);
      return recv_get_slice_by_names();
    }

    public void send_get_slice_by_names(String tablename, String key, String columnFamily, List<String> columnNames) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_slice_by_names", TMessageType.CALL, seqid_));
      get_slice_by_names_args args = new get_slice_by_names_args();
      args.tablename = tablename;
      args.key = key;
      args.columnFamily = columnFamily;
      args.columnNames = columnNames;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<column_t> recv_get_slice_by_names() throws CassandraException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_slice_by_names_result result = new get_slice_by_names_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.__isset.success) {
        return result.success;
      }
      if (result.__isset.e) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_slice_by_names failed: unknown result");
    }

    public column_t get_column(String tablename, String key, String columnFamily_column) throws CassandraException, TException
    {
      send_get_column(tablename, key, columnFamily_column);
      return recv_get_column();
    }

    public void send_get_column(String tablename, String key, String columnFamily_column) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_column", TMessageType.CALL, seqid_));
      get_column_args args = new get_column_args();
      args.tablename = tablename;
      args.key = key;
      args.columnFamily_column = columnFamily_column;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public column_t recv_get_column() throws CassandraException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_column_result result = new get_column_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.__isset.success) {
        return result.success;
      }
      if (result.__isset.e) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_column failed: unknown result");
    }

    public int get_column_count(String tablename, String key, String columnFamily_column) throws CassandraException, TException
    {
      send_get_column_count(tablename, key, columnFamily_column);
      return recv_get_column_count();
    }

    public void send_get_column_count(String tablename, String key, String columnFamily_column) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_column_count", TMessageType.CALL, seqid_));
      get_column_count_args args = new get_column_count_args();
      args.tablename = tablename;
      args.key = key;
      args.columnFamily_column = columnFamily_column;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public int recv_get_column_count() throws CassandraException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_column_count_result result = new get_column_count_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.__isset.success) {
        return result.success;
      }
      if (result.__isset.e) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_column_count failed: unknown result");
    }

    public void insert(String tablename, String key, String columnFamily_column, byte[] cellData, long timestamp) throws TException
    {
      send_insert(tablename, key, columnFamily_column, cellData, timestamp);
    }

    public void send_insert(String tablename, String key, String columnFamily_column, byte[] cellData, long timestamp) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("insert", TMessageType.CALL, seqid_));
      insert_args args = new insert_args();
      args.tablename = tablename;
      args.key = key;
      args.columnFamily_column = columnFamily_column;
      args.cellData = cellData;
      args.timestamp = timestamp;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void batch_insert(batch_mutation_t batchMutation) throws TException
    {
      send_batch_insert(batchMutation);
    }

    public void send_batch_insert(batch_mutation_t batchMutation) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("batch_insert", TMessageType.CALL, seqid_));
      batch_insert_args args = new batch_insert_args();
      args.batchMutation = batchMutation;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean batch_insert_blocking(batch_mutation_t batchMutation) throws CassandraException, TException
    {
      send_batch_insert_blocking(batchMutation);
      return recv_batch_insert_blocking();
    }

    public void send_batch_insert_blocking(batch_mutation_t batchMutation) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("batch_insert_blocking", TMessageType.CALL, seqid_));
      batch_insert_blocking_args args = new batch_insert_blocking_args();
      args.batchMutation = batchMutation;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_batch_insert_blocking() throws CassandraException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      batch_insert_blocking_result result = new batch_insert_blocking_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.__isset.success) {
        return result.success;
      }
      if (result.__isset.e) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "batch_insert_blocking failed: unknown result");
    }

    public boolean remove(String tablename, String key, String columnFamily_column, long timestamp, boolean block) throws TException
    {
      send_remove(tablename, key, columnFamily_column, timestamp, block);
      return recv_remove();
    }

    public void send_remove(String tablename, String key, String columnFamily_column, long timestamp, boolean block) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("remove", TMessageType.CALL, seqid_));
      remove_args args = new remove_args();
      args.tablename = tablename;
      args.key = key;
      args.columnFamily_column = columnFamily_column;
      args.timestamp = timestamp;
      args.block = block;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_remove() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      remove_result result = new remove_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.__isset.success) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "remove failed: unknown result");
    }

    public List<column_t> get_columns_since(String tablename, String key, String columnFamily_column, long timeStamp) throws CassandraException, TException
    {
      send_get_columns_since(tablename, key, columnFamily_column, timeStamp);
      return recv_get_columns_since();
    }

    public void send_get_columns_since(String tablename, String key, String columnFamily_column, long timeStamp) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_columns_since", TMessageType.CALL, seqid_));
      get_columns_since_args args = new get_columns_since_args();
      args.tablename = tablename;
      args.key = key;
      args.columnFamily_column = columnFamily_column;
      args.timeStamp = timeStamp;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<column_t> recv_get_columns_since() throws CassandraException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_columns_since_result result = new get_columns_since_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.__isset.success) {
        return result.success;
      }
      if (result.__isset.e) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_columns_since failed: unknown result");
    }

    public List<superColumn_t> get_slice_super(String tablename, String key, String columnFamily_superColumnName, int start, int count) throws CassandraException, TException
    {
      send_get_slice_super(tablename, key, columnFamily_superColumnName, start, count);
      return recv_get_slice_super();
    }

    public void send_get_slice_super(String tablename, String key, String columnFamily_superColumnName, int start, int count) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_slice_super", TMessageType.CALL, seqid_));
      get_slice_super_args args = new get_slice_super_args();
      args.tablename = tablename;
      args.key = key;
      args.columnFamily_superColumnName = columnFamily_superColumnName;
      args.start = start;
      args.count = count;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<superColumn_t> recv_get_slice_super() throws CassandraException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_slice_super_result result = new get_slice_super_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.__isset.success) {
        return result.success;
      }
      if (result.__isset.e) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_slice_super failed: unknown result");
    }

    public List<superColumn_t> get_slice_super_by_names(String tablename, String key, String columnFamily, List<String> superColumnNames) throws CassandraException, TException
    {
      send_get_slice_super_by_names(tablename, key, columnFamily, superColumnNames);
      return recv_get_slice_super_by_names();
    }

    public void send_get_slice_super_by_names(String tablename, String key, String columnFamily, List<String> superColumnNames) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_slice_super_by_names", TMessageType.CALL, seqid_));
      get_slice_super_by_names_args args = new get_slice_super_by_names_args();
      args.tablename = tablename;
      args.key = key;
      args.columnFamily = columnFamily;
      args.superColumnNames = superColumnNames;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<superColumn_t> recv_get_slice_super_by_names() throws CassandraException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_slice_super_by_names_result result = new get_slice_super_by_names_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.__isset.success) {
        return result.success;
      }
      if (result.__isset.e) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_slice_super_by_names failed: unknown result");
    }

    public superColumn_t get_superColumn(String tablename, String key, String columnFamily) throws CassandraException, TException
    {
      send_get_superColumn(tablename, key, columnFamily);
      return recv_get_superColumn();
    }

    public void send_get_superColumn(String tablename, String key, String columnFamily) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get_superColumn", TMessageType.CALL, seqid_));
      get_superColumn_args args = new get_superColumn_args();
      args.tablename = tablename;
      args.key = key;
      args.columnFamily = columnFamily;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public superColumn_t recv_get_superColumn() throws CassandraException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_superColumn_result result = new get_superColumn_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.__isset.success) {
        return result.success;
      }
      if (result.__isset.e) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_superColumn failed: unknown result");
    }

    public void batch_insert_superColumn(batch_mutation_super_t batchMutationSuper) throws TException
    {
      send_batch_insert_superColumn(batchMutationSuper);
    }

    public void send_batch_insert_superColumn(batch_mutation_super_t batchMutationSuper) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("batch_insert_superColumn", TMessageType.CALL, seqid_));
      batch_insert_superColumn_args args = new batch_insert_superColumn_args();
      args.batchMutationSuper = batchMutationSuper;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean batch_insert_superColumn_blocking(batch_mutation_super_t batchMutationSuper) throws CassandraException, TException
    {
      send_batch_insert_superColumn_blocking(batchMutationSuper);
      return recv_batch_insert_superColumn_blocking();
    }

    public void send_batch_insert_superColumn_blocking(batch_mutation_super_t batchMutationSuper) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("batch_insert_superColumn_blocking", TMessageType.CALL, seqid_));
      batch_insert_superColumn_blocking_args args = new batch_insert_superColumn_blocking_args();
      args.batchMutationSuper = batchMutationSuper;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public boolean recv_batch_insert_superColumn_blocking() throws CassandraException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      batch_insert_superColumn_blocking_result result = new batch_insert_superColumn_blocking_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.__isset.success) {
        return result.success;
      }
      if (result.__isset.e) {
        throw result.e;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "batch_insert_superColumn_blocking failed: unknown result");
    }

    public void touch(String key, boolean fData) throws TException
    {
      send_touch(key, fData);
    }

    public void send_touch(String key, boolean fData) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("touch", TMessageType.CALL, seqid_));
      touch_args args = new touch_args();
      args.key = key;
      args.fData = fData;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String getStringProperty(String propertyName) throws TException
    {
      send_getStringProperty(propertyName);
      return recv_getStringProperty();
    }

    public void send_getStringProperty(String propertyName) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getStringProperty", TMessageType.CALL, seqid_));
      getStringProperty_args args = new getStringProperty_args();
      args.propertyName = propertyName;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_getStringProperty() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getStringProperty_result result = new getStringProperty_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.__isset.success) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getStringProperty failed: unknown result");
    }

    public List<String> getStringListProperty(String propertyName) throws TException
    {
      send_getStringListProperty(propertyName);
      return recv_getStringListProperty();
    }

    public void send_getStringListProperty(String propertyName) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getStringListProperty", TMessageType.CALL, seqid_));
      getStringListProperty_args args = new getStringListProperty_args();
      args.propertyName = propertyName;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_getStringListProperty() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getStringListProperty_result result = new getStringListProperty_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.__isset.success) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getStringListProperty failed: unknown result");
    }

    public String describeTable(String tableName) throws TException
    {
      send_describeTable(tableName);
      return recv_describeTable();
    }

    public void send_describeTable(String tableName) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("describeTable", TMessageType.CALL, seqid_));
      describeTable_args args = new describeTable_args();
      args.tableName = tableName;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_describeTable() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      describeTable_result result = new describeTable_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.__isset.success) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "describeTable failed: unknown result");
    }

    public CqlResult_t executeQuery(String query) throws TException
    {
      send_executeQuery(query);
      return recv_executeQuery();
    }

    public void send_executeQuery(String query) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("executeQuery", TMessageType.CALL, seqid_));
      executeQuery_args args = new executeQuery_args();
      args.query = query;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public CqlResult_t recv_executeQuery() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      executeQuery_result result = new executeQuery_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.__isset.success) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "executeQuery failed: unknown result");
    }

  }
  public static class Processor implements TProcessor {
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("get_slice", new get_slice());
      processMap_.put("get_slice_by_names", new get_slice_by_names());
      processMap_.put("get_column", new get_column());
      processMap_.put("get_column_count", new get_column_count());
      processMap_.put("insert", new insert());
      processMap_.put("batch_insert", new batch_insert());
      processMap_.put("batch_insert_blocking", new batch_insert_blocking());
      processMap_.put("remove", new remove());
      processMap_.put("get_columns_since", new get_columns_since());
      processMap_.put("get_slice_super", new get_slice_super());
      processMap_.put("get_slice_super_by_names", new get_slice_super_by_names());
      processMap_.put("get_superColumn", new get_superColumn());
      processMap_.put("batch_insert_superColumn", new batch_insert_superColumn());
      processMap_.put("batch_insert_superColumn_blocking", new batch_insert_superColumn_blocking());
      processMap_.put("touch", new touch());
      processMap_.put("getStringProperty", new getStringProperty());
      processMap_.put("getStringListProperty", new getStringListProperty());
      processMap_.put("describeTable", new describeTable());
      processMap_.put("executeQuery", new executeQuery());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class get_slice implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_slice_args args = new get_slice_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_slice_result result = new get_slice_result();
        try {
          result.success = iface_.get_slice(args.tablename, args.key, args.columnFamily_column, args.start, args.count);
          result.__isset.success = true;
        } catch (CassandraException e) {
          result.e = e;
          result.__isset.e = true;
        }
        oprot.writeMessageBegin(new TMessage("get_slice", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_slice_by_names implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_slice_by_names_args args = new get_slice_by_names_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_slice_by_names_result result = new get_slice_by_names_result();
        try {
          result.success = iface_.get_slice_by_names(args.tablename, args.key, args.columnFamily, args.columnNames);
          result.__isset.success = true;
        } catch (CassandraException e) {
          result.e = e;
          result.__isset.e = true;
        }
        oprot.writeMessageBegin(new TMessage("get_slice_by_names", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_column implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_column_args args = new get_column_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_column_result result = new get_column_result();
        try {
          result.success = iface_.get_column(args.tablename, args.key, args.columnFamily_column);
          result.__isset.success = true;
        } catch (CassandraException e) {
          result.e = e;
          result.__isset.e = true;
        }
        oprot.writeMessageBegin(new TMessage("get_column", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_column_count implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_column_count_args args = new get_column_count_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_column_count_result result = new get_column_count_result();
        try {
          result.success = iface_.get_column_count(args.tablename, args.key, args.columnFamily_column);
          result.__isset.success = true;
        } catch (CassandraException e) {
          result.e = e;
          result.__isset.e = true;
        }
        oprot.writeMessageBegin(new TMessage("get_column_count", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class insert implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        insert_args args = new insert_args();
        args.read(iprot);
        iprot.readMessageEnd();
        iface_.insert(args.tablename, args.key, args.columnFamily_column, args.cellData, args.timestamp);
        return;
      }
    }

    private class batch_insert implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        batch_insert_args args = new batch_insert_args();
        args.read(iprot);
        iprot.readMessageEnd();
        iface_.batch_insert(args.batchMutation);
        return;
      }
    }

    private class batch_insert_blocking implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        batch_insert_blocking_args args = new batch_insert_blocking_args();
        args.read(iprot);
        iprot.readMessageEnd();
        batch_insert_blocking_result result = new batch_insert_blocking_result();
        try {
          result.success = iface_.batch_insert_blocking(args.batchMutation);
          result.__isset.success = true;
        } catch (CassandraException e) {
          result.e = e;
          result.__isset.e = true;
        }
        oprot.writeMessageBegin(new TMessage("batch_insert_blocking", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class remove implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        remove_args args = new remove_args();
        args.read(iprot);
        iprot.readMessageEnd();
        remove_result result = new remove_result();
        result.success = iface_.remove(args.tablename, args.key, args.columnFamily_column, args.timestamp, args.block);
        result.__isset.success = true;
        oprot.writeMessageBegin(new TMessage("remove", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_columns_since implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_columns_since_args args = new get_columns_since_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_columns_since_result result = new get_columns_since_result();
        try {
          result.success = iface_.get_columns_since(args.tablename, args.key, args.columnFamily_column, args.timeStamp);
          result.__isset.success = true;
        } catch (CassandraException e) {
          result.e = e;
          result.__isset.e = true;
        }
        oprot.writeMessageBegin(new TMessage("get_columns_since", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_slice_super implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_slice_super_args args = new get_slice_super_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_slice_super_result result = new get_slice_super_result();
        try {
          result.success = iface_.get_slice_super(args.tablename, args.key, args.columnFamily_superColumnName, args.start, args.count);
          result.__isset.success = true;
        } catch (CassandraException e) {
          result.e = e;
          result.__isset.e = true;
        }
        oprot.writeMessageBegin(new TMessage("get_slice_super", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_slice_super_by_names implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_slice_super_by_names_args args = new get_slice_super_by_names_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_slice_super_by_names_result result = new get_slice_super_by_names_result();
        try {
          result.success = iface_.get_slice_super_by_names(args.tablename, args.key, args.columnFamily, args.superColumnNames);
          result.__isset.success = true;
        } catch (CassandraException e) {
          result.e = e;
          result.__isset.e = true;
        }
        oprot.writeMessageBegin(new TMessage("get_slice_super_by_names", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class get_superColumn implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_superColumn_args args = new get_superColumn_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_superColumn_result result = new get_superColumn_result();
        try {
          result.success = iface_.get_superColumn(args.tablename, args.key, args.columnFamily);
          result.__isset.success = true;
        } catch (CassandraException e) {
          result.e = e;
          result.__isset.e = true;
        }
        oprot.writeMessageBegin(new TMessage("get_superColumn", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class batch_insert_superColumn implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        batch_insert_superColumn_args args = new batch_insert_superColumn_args();
        args.read(iprot);
        iprot.readMessageEnd();
        iface_.batch_insert_superColumn(args.batchMutationSuper);
        return;
      }
    }

    private class batch_insert_superColumn_blocking implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        batch_insert_superColumn_blocking_args args = new batch_insert_superColumn_blocking_args();
        args.read(iprot);
        iprot.readMessageEnd();
        batch_insert_superColumn_blocking_result result = new batch_insert_superColumn_blocking_result();
        try {
          result.success = iface_.batch_insert_superColumn_blocking(args.batchMutationSuper);
          result.__isset.success = true;
        } catch (CassandraException e) {
          result.e = e;
          result.__isset.e = true;
        }
        oprot.writeMessageBegin(new TMessage("batch_insert_superColumn_blocking", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class touch implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        touch_args args = new touch_args();
        args.read(iprot);
        iprot.readMessageEnd();
        iface_.touch(args.key, args.fData);
        return;
      }
    }

    private class getStringProperty implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getStringProperty_args args = new getStringProperty_args();
        args.read(iprot);
        iprot.readMessageEnd();
        getStringProperty_result result = new getStringProperty_result();
        result.success = iface_.getStringProperty(args.propertyName);
        result.__isset.success = true;
        oprot.writeMessageBegin(new TMessage("getStringProperty", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getStringListProperty implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getStringListProperty_args args = new getStringListProperty_args();
        args.read(iprot);
        iprot.readMessageEnd();
        getStringListProperty_result result = new getStringListProperty_result();
        result.success = iface_.getStringListProperty(args.propertyName);
        result.__isset.success = true;
        oprot.writeMessageBegin(new TMessage("getStringListProperty", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class describeTable implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        describeTable_args args = new describeTable_args();
        args.read(iprot);
        iprot.readMessageEnd();
        describeTable_result result = new describeTable_result();
        result.success = iface_.describeTable(args.tableName);
        result.__isset.success = true;
        oprot.writeMessageBegin(new TMessage("describeTable", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class executeQuery implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        executeQuery_args args = new executeQuery_args();
        args.read(iprot);
        iprot.readMessageEnd();
        executeQuery_result result = new executeQuery_result();
        result.success = iface_.executeQuery(args.query);
        result.__isset.success = true;
        oprot.writeMessageBegin(new TMessage("executeQuery", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

  public static class get_slice_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_slice_args");
    private static final TField TABLENAME_FIELD_DESC = new TField("tablename", TType.STRING, (short)-1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)-2);
    private static final TField COLUMN_FAMILY_COLUMN_FIELD_DESC = new TField("columnFamily_column", TType.STRING, (short)-3);
    private static final TField START_FIELD_DESC = new TField("start", TType.I32, (short)-4);
    private static final TField COUNT_FIELD_DESC = new TField("count", TType.I32, (short)-5);

    public String tablename;
    public static final int TABLENAME = -1;
    public String key;
    public static final int KEY = -2;
    public String columnFamily_column;
    public static final int COLUMNFAMILY_COLUMN = -3;
    public int start;
    public static final int START = -4;
    public int count;
    public static final int COUNT = -5;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean tablename = false;
      public boolean key = false;
      public boolean columnFamily_column = false;
      public boolean start = false;
      public boolean count = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLENAME, new FieldMetaData("tablename", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMNFAMILY_COLUMN, new FieldMetaData("columnFamily_column", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(START, new FieldMetaData("start", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      put(COUNT, new FieldMetaData("count", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_slice_args.class, metaDataMap);
    }

    public get_slice_args() {
      this.start = -1;

      this.count = -1;

    }

    public get_slice_args(
      String tablename,
      String key,
      String columnFamily_column,
      int start,
      int count)
    {
      this();
      this.tablename = tablename;
      this.__isset.tablename = (tablename != null);
      this.key = key;
      this.__isset.key = (key != null);
      this.columnFamily_column = columnFamily_column;
      this.__isset.columnFamily_column = (columnFamily_column != null);
      this.start = start;
      this.__isset.start = true;
      this.count = count;
      this.__isset.count = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_slice_args(get_slice_args other) {
      __isset.tablename = other.__isset.tablename;
      if (other.tablename != null) {
        this.tablename = other.tablename;
      }
      __isset.key = other.__isset.key;
      if (other.key != null) {
        this.key = other.key;
      }
      __isset.columnFamily_column = other.__isset.columnFamily_column;
      if (other.columnFamily_column != null) {
        this.columnFamily_column = other.columnFamily_column;
      }
      __isset.start = other.__isset.start;
      this.start = other.start;
      __isset.count = other.__isset.count;
      this.count = other.count;
    }

    @Override
    public get_slice_args clone() {
      return new get_slice_args(this);
    }

    public String getTablename() {
      return this.tablename;
    }

    public void setTablename(String tablename) {
      this.tablename = tablename;
      this.__isset.tablename = (tablename != null);
    }

    public void unsetTablename() {
      this.__isset.tablename = false;
    }

    // Returns true if field tablename is set (has been asigned a value) and false otherwise
    public boolean isSetTablename() {
      return this.__isset.tablename;
    }

    public void setTablenameIsSet(boolean value) {
      this.__isset.tablename = value;
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
      this.__isset.key = (key != null);
    }

    public void unsetKey() {
      this.__isset.key = false;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.__isset.key;
    }

    public void setKeyIsSet(boolean value) {
      this.__isset.key = value;
    }

    public String getColumnFamily_column() {
      return this.columnFamily_column;
    }

    public void setColumnFamily_column(String columnFamily_column) {
      this.columnFamily_column = columnFamily_column;
      this.__isset.columnFamily_column = (columnFamily_column != null);
    }

    public void unsetColumnFamily_column() {
      this.__isset.columnFamily_column = false;
    }

    // Returns true if field columnFamily_column is set (has been asigned a value) and false otherwise
    public boolean isSetColumnFamily_column() {
      return this.__isset.columnFamily_column;
    }

    public void setColumnFamily_columnIsSet(boolean value) {
      this.__isset.columnFamily_column = value;
    }

    public int getStart() {
      return this.start;
    }

    public void setStart(int start) {
      this.start = start;
      this.__isset.start = true;
    }

    public void unsetStart() {
      this.__isset.start = false;
    }

    // Returns true if field start is set (has been asigned a value) and false otherwise
    public boolean isSetStart() {
      return this.__isset.start;
    }

    public void setStartIsSet(boolean value) {
      this.__isset.start = value;
    }

    public int getCount() {
      return this.count;
    }

    public void setCount(int count) {
      this.count = count;
      this.__isset.count = true;
    }

    public void unsetCount() {
      this.__isset.count = false;
    }

    // Returns true if field count is set (has been asigned a value) and false otherwise
    public boolean isSetCount() {
      return this.__isset.count;
    }

    public void setCountIsSet(boolean value) {
      this.__isset.count = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLENAME:
        setTablename((String)value);
        break;

      case KEY:
        setKey((String)value);
        break;

      case COLUMNFAMILY_COLUMN:
        setColumnFamily_column((String)value);
        break;

      case START:
        setStart((Integer)value);
        break;

      case COUNT:
        setCount((Integer)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return getTablename();

      case KEY:
        return getKey();

      case COLUMNFAMILY_COLUMN:
        return getColumnFamily_column();

      case START:
        return new Integer(getStart());

      case COUNT:
        return new Integer(getCount());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return this.__isset.tablename;
      case KEY:
        return this.__isset.key;
      case COLUMNFAMILY_COLUMN:
        return this.__isset.columnFamily_column;
      case START:
        return this.__isset.start;
      case COUNT:
        return this.__isset.count;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_slice_args)
        return this.equals((get_slice_args)that);
      return false;
    }

    public boolean equals(get_slice_args that) {
      if (that == null)
        return false;

      boolean this_present_tablename = true && (this.tablename != null);
      boolean that_present_tablename = true && (that.tablename != null);
      if (this_present_tablename || that_present_tablename) {
        if (!(this_present_tablename && that_present_tablename))
          return false;
        if (!this.tablename.equals(that.tablename))
          return false;
      }

      boolean this_present_key = true && (this.key != null);
      boolean that_present_key = true && (that.key != null);
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_columnFamily_column = true && (this.columnFamily_column != null);
      boolean that_present_columnFamily_column = true && (that.columnFamily_column != null);
      if (this_present_columnFamily_column || that_present_columnFamily_column) {
        if (!(this_present_columnFamily_column && that_present_columnFamily_column))
          return false;
        if (!this.columnFamily_column.equals(that.columnFamily_column))
          return false;
      }

      boolean this_present_start = true;
      boolean that_present_start = true;
      if (this_present_start || that_present_start) {
        if (!(this_present_start && that_present_start))
          return false;
        if (this.start != that.start)
          return false;
      }

      boolean this_present_count = true;
      boolean that_present_count = true;
      if (this_present_count || that_present_count) {
        if (!(this_present_count && that_present_count))
          return false;
        if (this.count != that.count)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLENAME:
            if (field.type == TType.STRING) {
              this.tablename = iprot.readString();
              this.__isset.tablename = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
              this.__isset.key = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMNFAMILY_COLUMN:
            if (field.type == TType.STRING) {
              this.columnFamily_column = iprot.readString();
              this.__isset.columnFamily_column = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case START:
            if (field.type == TType.I32) {
              this.start = iprot.readI32();
              this.__isset.start = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COUNT:
            if (field.type == TType.I32) {
              this.count = iprot.readI32();
              this.__isset.count = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tablename != null) {
        oprot.writeFieldBegin(TABLENAME_FIELD_DESC);
        oprot.writeString(this.tablename);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.columnFamily_column != null) {
        oprot.writeFieldBegin(COLUMN_FAMILY_COLUMN_FIELD_DESC);
        oprot.writeString(this.columnFamily_column);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(START_FIELD_DESC);
      oprot.writeI32(this.start);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(COUNT_FIELD_DESC);
      oprot.writeI32(this.count);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_slice_args(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("tablename:");
      sb.append(this.tablename);
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      sb.append(this.key);
      first = false;
      if (!first) sb.append(", ");
      sb.append("columnFamily_column:");
      sb.append(this.columnFamily_column);
      first = false;
      if (!first) sb.append(", ");
      sb.append("start:");
      sb.append(this.start);
      first = false;
      if (!first) sb.append(", ");
      sb.append("count:");
      sb.append(this.count);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_slice_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_slice_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<column_t> success;
    public static final int SUCCESS = 0;
    public CassandraException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
      public boolean e = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, column_t.class))));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_slice_result.class, metaDataMap);
    }

    public get_slice_result() {
    }

    public get_slice_result(
      List<column_t> success,
      CassandraException e)
    {
      this();
      this.success = success;
      this.__isset.success = (success != null);
      this.e = e;
      this.__isset.e = (e != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_slice_result(get_slice_result other) {
      __isset.success = other.__isset.success;
      if (other.success != null) {
        List<column_t> __this__success = new ArrayList<column_t>();
        for (column_t other_element : other.success) {
          __this__success.add(new column_t(other_element));
        }
        this.success = __this__success;
      }
      __isset.e = other.__isset.e;
      if (other.e != null) {
        this.e = new CassandraException(other.e);
      }
    }

    @Override
    public get_slice_result clone() {
      return new get_slice_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<column_t> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(column_t elem) {
      if (this.success == null) {
        this.success = new ArrayList<column_t>();
      }
      this.success.add(elem);
      this.__isset.success = true;
    }

    public List<column_t> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<column_t> success) {
      this.success = success;
      this.__isset.success = (success != null);
    }

    public void unsetSuccess() {
      this.success = null;
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public CassandraException getE() {
      return this.e;
    }

    public void setE(CassandraException e) {
      this.e = e;
      this.__isset.e = (e != null);
    }

    public void unsetE() {
      this.e = null;
      this.__isset.e = false;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.__isset.e;
    }

    public void setEIsSet(boolean value) {
      this.__isset.e = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        setSuccess((List<column_t>)value);
        break;

      case E:
        setE((CassandraException)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return this.__isset.success;
      case E:
        return this.__isset.e;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_slice_result)
        return this.equals((get_slice_result)that);
      return false;
    }

    public boolean equals(get_slice_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && (this.success != null);
      boolean that_present_success = true && (that.success != null);
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && (this.e != null);
      boolean that_present_e = true && (that.e != null);
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list49 = iprot.readListBegin();
                this.success = new ArrayList<column_t>(_list49.size);
                for (int _i50 = 0; _i50 < _list49.size; ++_i50)
                {
                  column_t _elem51;
                  _elem51 = new column_t();
                  _elem51.read(iprot);
                  this.success.add(_elem51);
                }
                iprot.readListEnd();
              }
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new CassandraException();
              this.e.read(iprot);
              this.__isset.e = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.__isset.success) {
        if (this.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          {
            oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
            for (column_t _iter52 : this.success)            {
              _iter52.write(oprot);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
      } else if (this.__isset.e) {
        if (this.e != null) {
          oprot.writeFieldBegin(E_FIELD_DESC);
          this.e.write(oprot);
          oprot.writeFieldEnd();
        }
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_slice_result(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      sb.append(this.e);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_slice_by_names_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_slice_by_names_args");
    private static final TField TABLENAME_FIELD_DESC = new TField("tablename", TType.STRING, (short)-1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)-2);
    private static final TField COLUMN_FAMILY_FIELD_DESC = new TField("columnFamily", TType.STRING, (short)-3);
    private static final TField COLUMN_NAMES_FIELD_DESC = new TField("columnNames", TType.LIST, (short)-4);

    public String tablename;
    public static final int TABLENAME = -1;
    public String key;
    public static final int KEY = -2;
    public String columnFamily;
    public static final int COLUMNFAMILY = -3;
    public List<String> columnNames;
    public static final int COLUMNNAMES = -4;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean tablename = false;
      public boolean key = false;
      public boolean columnFamily = false;
      public boolean columnNames = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLENAME, new FieldMetaData("tablename", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMNFAMILY, new FieldMetaData("columnFamily", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMNNAMES, new FieldMetaData("columnNames", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_slice_by_names_args.class, metaDataMap);
    }

    public get_slice_by_names_args() {
    }

    public get_slice_by_names_args(
      String tablename,
      String key,
      String columnFamily,
      List<String> columnNames)
    {
      this();
      this.tablename = tablename;
      this.__isset.tablename = (tablename != null);
      this.key = key;
      this.__isset.key = (key != null);
      this.columnFamily = columnFamily;
      this.__isset.columnFamily = (columnFamily != null);
      this.columnNames = columnNames;
      this.__isset.columnNames = (columnNames != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_slice_by_names_args(get_slice_by_names_args other) {
      __isset.tablename = other.__isset.tablename;
      if (other.tablename != null) {
        this.tablename = other.tablename;
      }
      __isset.key = other.__isset.key;
      if (other.key != null) {
        this.key = other.key;
      }
      __isset.columnFamily = other.__isset.columnFamily;
      if (other.columnFamily != null) {
        this.columnFamily = other.columnFamily;
      }
      __isset.columnNames = other.__isset.columnNames;
      if (other.columnNames != null) {
        List<String> __this__columnNames = new ArrayList<String>();
        for (String other_element : other.columnNames) {
          __this__columnNames.add(other_element);
        }
        this.columnNames = __this__columnNames;
      }
    }

    @Override
    public get_slice_by_names_args clone() {
      return new get_slice_by_names_args(this);
    }

    public String getTablename() {
      return this.tablename;
    }

    public void setTablename(String tablename) {
      this.tablename = tablename;
      this.__isset.tablename = (tablename != null);
    }

    public void unsetTablename() {
      this.__isset.tablename = false;
    }

    // Returns true if field tablename is set (has been asigned a value) and false otherwise
    public boolean isSetTablename() {
      return this.__isset.tablename;
    }

    public void setTablenameIsSet(boolean value) {
      this.__isset.tablename = value;
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
      this.__isset.key = (key != null);
    }

    public void unsetKey() {
      this.__isset.key = false;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.__isset.key;
    }

    public void setKeyIsSet(boolean value) {
      this.__isset.key = value;
    }

    public String getColumnFamily() {
      return this.columnFamily;
    }

    public void setColumnFamily(String columnFamily) {
      this.columnFamily = columnFamily;
      this.__isset.columnFamily = (columnFamily != null);
    }

    public void unsetColumnFamily() {
      this.__isset.columnFamily = false;
    }

    // Returns true if field columnFamily is set (has been asigned a value) and false otherwise
    public boolean isSetColumnFamily() {
      return this.__isset.columnFamily;
    }

    public void setColumnFamilyIsSet(boolean value) {
      this.__isset.columnFamily = value;
    }

    public int getColumnNamesSize() {
      return (this.columnNames == null) ? 0 : this.columnNames.size();
    }

    public java.util.Iterator<String> getColumnNamesIterator() {
      return (this.columnNames == null) ? null : this.columnNames.iterator();
    }

    public void addToColumnNames(String elem) {
      if (this.columnNames == null) {
        this.columnNames = new ArrayList<String>();
      }
      this.columnNames.add(elem);
      this.__isset.columnNames = true;
    }

    public List<String> getColumnNames() {
      return this.columnNames;
    }

    public void setColumnNames(List<String> columnNames) {
      this.columnNames = columnNames;
      this.__isset.columnNames = (columnNames != null);
    }

    public void unsetColumnNames() {
      this.columnNames = null;
      this.__isset.columnNames = false;
    }

    // Returns true if field columnNames is set (has been asigned a value) and false otherwise
    public boolean isSetColumnNames() {
      return this.__isset.columnNames;
    }

    public void setColumnNamesIsSet(boolean value) {
      this.__isset.columnNames = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLENAME:
        setTablename((String)value);
        break;

      case KEY:
        setKey((String)value);
        break;

      case COLUMNFAMILY:
        setColumnFamily((String)value);
        break;

      case COLUMNNAMES:
        setColumnNames((List<String>)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return getTablename();

      case KEY:
        return getKey();

      case COLUMNFAMILY:
        return getColumnFamily();

      case COLUMNNAMES:
        return getColumnNames();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return this.__isset.tablename;
      case KEY:
        return this.__isset.key;
      case COLUMNFAMILY:
        return this.__isset.columnFamily;
      case COLUMNNAMES:
        return this.__isset.columnNames;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_slice_by_names_args)
        return this.equals((get_slice_by_names_args)that);
      return false;
    }

    public boolean equals(get_slice_by_names_args that) {
      if (that == null)
        return false;

      boolean this_present_tablename = true && (this.tablename != null);
      boolean that_present_tablename = true && (that.tablename != null);
      if (this_present_tablename || that_present_tablename) {
        if (!(this_present_tablename && that_present_tablename))
          return false;
        if (!this.tablename.equals(that.tablename))
          return false;
      }

      boolean this_present_key = true && (this.key != null);
      boolean that_present_key = true && (that.key != null);
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_columnFamily = true && (this.columnFamily != null);
      boolean that_present_columnFamily = true && (that.columnFamily != null);
      if (this_present_columnFamily || that_present_columnFamily) {
        if (!(this_present_columnFamily && that_present_columnFamily))
          return false;
        if (!this.columnFamily.equals(that.columnFamily))
          return false;
      }

      boolean this_present_columnNames = true && (this.columnNames != null);
      boolean that_present_columnNames = true && (that.columnNames != null);
      if (this_present_columnNames || that_present_columnNames) {
        if (!(this_present_columnNames && that_present_columnNames))
          return false;
        if (!this.columnNames.equals(that.columnNames))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLENAME:
            if (field.type == TType.STRING) {
              this.tablename = iprot.readString();
              this.__isset.tablename = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
              this.__isset.key = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMNFAMILY:
            if (field.type == TType.STRING) {
              this.columnFamily = iprot.readString();
              this.__isset.columnFamily = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMNNAMES:
            if (field.type == TType.LIST) {
              {
                TList _list53 = iprot.readListBegin();
                this.columnNames = new ArrayList<String>(_list53.size);
                for (int _i54 = 0; _i54 < _list53.size; ++_i54)
                {
                  String _elem55;
                  _elem55 = iprot.readString();
                  this.columnNames.add(_elem55);
                }
                iprot.readListEnd();
              }
              this.__isset.columnNames = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tablename != null) {
        oprot.writeFieldBegin(TABLENAME_FIELD_DESC);
        oprot.writeString(this.tablename);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.columnFamily != null) {
        oprot.writeFieldBegin(COLUMN_FAMILY_FIELD_DESC);
        oprot.writeString(this.columnFamily);
        oprot.writeFieldEnd();
      }
      if (this.columnNames != null) {
        oprot.writeFieldBegin(COLUMN_NAMES_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.columnNames.size()));
          for (String _iter56 : this.columnNames)          {
            oprot.writeString(_iter56);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_slice_by_names_args(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("tablename:");
      sb.append(this.tablename);
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      sb.append(this.key);
      first = false;
      if (!first) sb.append(", ");
      sb.append("columnFamily:");
      sb.append(this.columnFamily);
      first = false;
      if (!first) sb.append(", ");
      sb.append("columnNames:");
      sb.append(this.columnNames);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_slice_by_names_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_slice_by_names_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<column_t> success;
    public static final int SUCCESS = 0;
    public CassandraException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
      public boolean e = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, column_t.class))));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_slice_by_names_result.class, metaDataMap);
    }

    public get_slice_by_names_result() {
    }

    public get_slice_by_names_result(
      List<column_t> success,
      CassandraException e)
    {
      this();
      this.success = success;
      this.__isset.success = (success != null);
      this.e = e;
      this.__isset.e = (e != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_slice_by_names_result(get_slice_by_names_result other) {
      __isset.success = other.__isset.success;
      if (other.success != null) {
        List<column_t> __this__success = new ArrayList<column_t>();
        for (column_t other_element : other.success) {
          __this__success.add(new column_t(other_element));
        }
        this.success = __this__success;
      }
      __isset.e = other.__isset.e;
      if (other.e != null) {
        this.e = new CassandraException(other.e);
      }
    }

    @Override
    public get_slice_by_names_result clone() {
      return new get_slice_by_names_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<column_t> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(column_t elem) {
      if (this.success == null) {
        this.success = new ArrayList<column_t>();
      }
      this.success.add(elem);
      this.__isset.success = true;
    }

    public List<column_t> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<column_t> success) {
      this.success = success;
      this.__isset.success = (success != null);
    }

    public void unsetSuccess() {
      this.success = null;
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public CassandraException getE() {
      return this.e;
    }

    public void setE(CassandraException e) {
      this.e = e;
      this.__isset.e = (e != null);
    }

    public void unsetE() {
      this.e = null;
      this.__isset.e = false;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.__isset.e;
    }

    public void setEIsSet(boolean value) {
      this.__isset.e = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        setSuccess((List<column_t>)value);
        break;

      case E:
        setE((CassandraException)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return this.__isset.success;
      case E:
        return this.__isset.e;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_slice_by_names_result)
        return this.equals((get_slice_by_names_result)that);
      return false;
    }

    public boolean equals(get_slice_by_names_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && (this.success != null);
      boolean that_present_success = true && (that.success != null);
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && (this.e != null);
      boolean that_present_e = true && (that.e != null);
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list57 = iprot.readListBegin();
                this.success = new ArrayList<column_t>(_list57.size);
                for (int _i58 = 0; _i58 < _list57.size; ++_i58)
                {
                  column_t _elem59;
                  _elem59 = new column_t();
                  _elem59.read(iprot);
                  this.success.add(_elem59);
                }
                iprot.readListEnd();
              }
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new CassandraException();
              this.e.read(iprot);
              this.__isset.e = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.__isset.success) {
        if (this.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          {
            oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
            for (column_t _iter60 : this.success)            {
              _iter60.write(oprot);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
      } else if (this.__isset.e) {
        if (this.e != null) {
          oprot.writeFieldBegin(E_FIELD_DESC);
          this.e.write(oprot);
          oprot.writeFieldEnd();
        }
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_slice_by_names_result(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      sb.append(this.e);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_column_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_column_args");
    private static final TField TABLENAME_FIELD_DESC = new TField("tablename", TType.STRING, (short)-1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)-2);
    private static final TField COLUMN_FAMILY_COLUMN_FIELD_DESC = new TField("columnFamily_column", TType.STRING, (short)-3);

    public String tablename;
    public static final int TABLENAME = -1;
    public String key;
    public static final int KEY = -2;
    public String columnFamily_column;
    public static final int COLUMNFAMILY_COLUMN = -3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean tablename = false;
      public boolean key = false;
      public boolean columnFamily_column = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLENAME, new FieldMetaData("tablename", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMNFAMILY_COLUMN, new FieldMetaData("columnFamily_column", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_column_args.class, metaDataMap);
    }

    public get_column_args() {
    }

    public get_column_args(
      String tablename,
      String key,
      String columnFamily_column)
    {
      this();
      this.tablename = tablename;
      this.__isset.tablename = (tablename != null);
      this.key = key;
      this.__isset.key = (key != null);
      this.columnFamily_column = columnFamily_column;
      this.__isset.columnFamily_column = (columnFamily_column != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_column_args(get_column_args other) {
      __isset.tablename = other.__isset.tablename;
      if (other.tablename != null) {
        this.tablename = other.tablename;
      }
      __isset.key = other.__isset.key;
      if (other.key != null) {
        this.key = other.key;
      }
      __isset.columnFamily_column = other.__isset.columnFamily_column;
      if (other.columnFamily_column != null) {
        this.columnFamily_column = other.columnFamily_column;
      }
    }

    @Override
    public get_column_args clone() {
      return new get_column_args(this);
    }

    public String getTablename() {
      return this.tablename;
    }

    public void setTablename(String tablename) {
      this.tablename = tablename;
      this.__isset.tablename = (tablename != null);
    }

    public void unsetTablename() {
      this.__isset.tablename = false;
    }

    // Returns true if field tablename is set (has been asigned a value) and false otherwise
    public boolean isSetTablename() {
      return this.__isset.tablename;
    }

    public void setTablenameIsSet(boolean value) {
      this.__isset.tablename = value;
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
      this.__isset.key = (key != null);
    }

    public void unsetKey() {
      this.__isset.key = false;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.__isset.key;
    }

    public void setKeyIsSet(boolean value) {
      this.__isset.key = value;
    }

    public String getColumnFamily_column() {
      return this.columnFamily_column;
    }

    public void setColumnFamily_column(String columnFamily_column) {
      this.columnFamily_column = columnFamily_column;
      this.__isset.columnFamily_column = (columnFamily_column != null);
    }

    public void unsetColumnFamily_column() {
      this.__isset.columnFamily_column = false;
    }

    // Returns true if field columnFamily_column is set (has been asigned a value) and false otherwise
    public boolean isSetColumnFamily_column() {
      return this.__isset.columnFamily_column;
    }

    public void setColumnFamily_columnIsSet(boolean value) {
      this.__isset.columnFamily_column = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLENAME:
        setTablename((String)value);
        break;

      case KEY:
        setKey((String)value);
        break;

      case COLUMNFAMILY_COLUMN:
        setColumnFamily_column((String)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return getTablename();

      case KEY:
        return getKey();

      case COLUMNFAMILY_COLUMN:
        return getColumnFamily_column();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return this.__isset.tablename;
      case KEY:
        return this.__isset.key;
      case COLUMNFAMILY_COLUMN:
        return this.__isset.columnFamily_column;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_column_args)
        return this.equals((get_column_args)that);
      return false;
    }

    public boolean equals(get_column_args that) {
      if (that == null)
        return false;

      boolean this_present_tablename = true && (this.tablename != null);
      boolean that_present_tablename = true && (that.tablename != null);
      if (this_present_tablename || that_present_tablename) {
        if (!(this_present_tablename && that_present_tablename))
          return false;
        if (!this.tablename.equals(that.tablename))
          return false;
      }

      boolean this_present_key = true && (this.key != null);
      boolean that_present_key = true && (that.key != null);
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_columnFamily_column = true && (this.columnFamily_column != null);
      boolean that_present_columnFamily_column = true && (that.columnFamily_column != null);
      if (this_present_columnFamily_column || that_present_columnFamily_column) {
        if (!(this_present_columnFamily_column && that_present_columnFamily_column))
          return false;
        if (!this.columnFamily_column.equals(that.columnFamily_column))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLENAME:
            if (field.type == TType.STRING) {
              this.tablename = iprot.readString();
              this.__isset.tablename = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
              this.__isset.key = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMNFAMILY_COLUMN:
            if (field.type == TType.STRING) {
              this.columnFamily_column = iprot.readString();
              this.__isset.columnFamily_column = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tablename != null) {
        oprot.writeFieldBegin(TABLENAME_FIELD_DESC);
        oprot.writeString(this.tablename);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.columnFamily_column != null) {
        oprot.writeFieldBegin(COLUMN_FAMILY_COLUMN_FIELD_DESC);
        oprot.writeString(this.columnFamily_column);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_column_args(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("tablename:");
      sb.append(this.tablename);
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      sb.append(this.key);
      first = false;
      if (!first) sb.append(", ");
      sb.append("columnFamily_column:");
      sb.append(this.columnFamily_column);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_column_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_column_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public column_t success;
    public static final int SUCCESS = 0;
    public CassandraException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
      public boolean e = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, column_t.class)));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_column_result.class, metaDataMap);
    }

    public get_column_result() {
    }

    public get_column_result(
      column_t success,
      CassandraException e)
    {
      this();
      this.success = success;
      this.__isset.success = (success != null);
      this.e = e;
      this.__isset.e = (e != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_column_result(get_column_result other) {
      __isset.success = other.__isset.success;
      if (other.success != null) {
        this.success = new column_t(other.success);
      }
      __isset.e = other.__isset.e;
      if (other.e != null) {
        this.e = new CassandraException(other.e);
      }
    }

    @Override
    public get_column_result clone() {
      return new get_column_result(this);
    }

    public column_t getSuccess() {
      return this.success;
    }

    public void setSuccess(column_t success) {
      this.success = success;
      this.__isset.success = (success != null);
    }

    public void unsetSuccess() {
      this.success = null;
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public CassandraException getE() {
      return this.e;
    }

    public void setE(CassandraException e) {
      this.e = e;
      this.__isset.e = (e != null);
    }

    public void unsetE() {
      this.e = null;
      this.__isset.e = false;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.__isset.e;
    }

    public void setEIsSet(boolean value) {
      this.__isset.e = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        setSuccess((column_t)value);
        break;

      case E:
        setE((CassandraException)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return this.__isset.success;
      case E:
        return this.__isset.e;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_column_result)
        return this.equals((get_column_result)that);
      return false;
    }

    public boolean equals(get_column_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && (this.success != null);
      boolean that_present_success = true && (that.success != null);
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && (this.e != null);
      boolean that_present_e = true && (that.e != null);
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new column_t();
              this.success.read(iprot);
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new CassandraException();
              this.e.read(iprot);
              this.__isset.e = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.__isset.success) {
        if (this.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          this.success.write(oprot);
          oprot.writeFieldEnd();
        }
      } else if (this.__isset.e) {
        if (this.e != null) {
          oprot.writeFieldBegin(E_FIELD_DESC);
          this.e.write(oprot);
          oprot.writeFieldEnd();
        }
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_column_result(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      sb.append(this.e);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_column_count_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_column_count_args");
    private static final TField TABLENAME_FIELD_DESC = new TField("tablename", TType.STRING, (short)-1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)-2);
    private static final TField COLUMN_FAMILY_COLUMN_FIELD_DESC = new TField("columnFamily_column", TType.STRING, (short)-3);

    public String tablename;
    public static final int TABLENAME = -1;
    public String key;
    public static final int KEY = -2;
    public String columnFamily_column;
    public static final int COLUMNFAMILY_COLUMN = -3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean tablename = false;
      public boolean key = false;
      public boolean columnFamily_column = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLENAME, new FieldMetaData("tablename", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMNFAMILY_COLUMN, new FieldMetaData("columnFamily_column", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_column_count_args.class, metaDataMap);
    }

    public get_column_count_args() {
    }

    public get_column_count_args(
      String tablename,
      String key,
      String columnFamily_column)
    {
      this();
      this.tablename = tablename;
      this.__isset.tablename = (tablename != null);
      this.key = key;
      this.__isset.key = (key != null);
      this.columnFamily_column = columnFamily_column;
      this.__isset.columnFamily_column = (columnFamily_column != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_column_count_args(get_column_count_args other) {
      __isset.tablename = other.__isset.tablename;
      if (other.tablename != null) {
        this.tablename = other.tablename;
      }
      __isset.key = other.__isset.key;
      if (other.key != null) {
        this.key = other.key;
      }
      __isset.columnFamily_column = other.__isset.columnFamily_column;
      if (other.columnFamily_column != null) {
        this.columnFamily_column = other.columnFamily_column;
      }
    }

    @Override
    public get_column_count_args clone() {
      return new get_column_count_args(this);
    }

    public String getTablename() {
      return this.tablename;
    }

    public void setTablename(String tablename) {
      this.tablename = tablename;
      this.__isset.tablename = (tablename != null);
    }

    public void unsetTablename() {
      this.__isset.tablename = false;
    }

    // Returns true if field tablename is set (has been asigned a value) and false otherwise
    public boolean isSetTablename() {
      return this.__isset.tablename;
    }

    public void setTablenameIsSet(boolean value) {
      this.__isset.tablename = value;
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
      this.__isset.key = (key != null);
    }

    public void unsetKey() {
      this.__isset.key = false;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.__isset.key;
    }

    public void setKeyIsSet(boolean value) {
      this.__isset.key = value;
    }

    public String getColumnFamily_column() {
      return this.columnFamily_column;
    }

    public void setColumnFamily_column(String columnFamily_column) {
      this.columnFamily_column = columnFamily_column;
      this.__isset.columnFamily_column = (columnFamily_column != null);
    }

    public void unsetColumnFamily_column() {
      this.__isset.columnFamily_column = false;
    }

    // Returns true if field columnFamily_column is set (has been asigned a value) and false otherwise
    public boolean isSetColumnFamily_column() {
      return this.__isset.columnFamily_column;
    }

    public void setColumnFamily_columnIsSet(boolean value) {
      this.__isset.columnFamily_column = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLENAME:
        setTablename((String)value);
        break;

      case KEY:
        setKey((String)value);
        break;

      case COLUMNFAMILY_COLUMN:
        setColumnFamily_column((String)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return getTablename();

      case KEY:
        return getKey();

      case COLUMNFAMILY_COLUMN:
        return getColumnFamily_column();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return this.__isset.tablename;
      case KEY:
        return this.__isset.key;
      case COLUMNFAMILY_COLUMN:
        return this.__isset.columnFamily_column;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_column_count_args)
        return this.equals((get_column_count_args)that);
      return false;
    }

    public boolean equals(get_column_count_args that) {
      if (that == null)
        return false;

      boolean this_present_tablename = true && (this.tablename != null);
      boolean that_present_tablename = true && (that.tablename != null);
      if (this_present_tablename || that_present_tablename) {
        if (!(this_present_tablename && that_present_tablename))
          return false;
        if (!this.tablename.equals(that.tablename))
          return false;
      }

      boolean this_present_key = true && (this.key != null);
      boolean that_present_key = true && (that.key != null);
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_columnFamily_column = true && (this.columnFamily_column != null);
      boolean that_present_columnFamily_column = true && (that.columnFamily_column != null);
      if (this_present_columnFamily_column || that_present_columnFamily_column) {
        if (!(this_present_columnFamily_column && that_present_columnFamily_column))
          return false;
        if (!this.columnFamily_column.equals(that.columnFamily_column))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLENAME:
            if (field.type == TType.STRING) {
              this.tablename = iprot.readString();
              this.__isset.tablename = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
              this.__isset.key = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMNFAMILY_COLUMN:
            if (field.type == TType.STRING) {
              this.columnFamily_column = iprot.readString();
              this.__isset.columnFamily_column = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tablename != null) {
        oprot.writeFieldBegin(TABLENAME_FIELD_DESC);
        oprot.writeString(this.tablename);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.columnFamily_column != null) {
        oprot.writeFieldBegin(COLUMN_FAMILY_COLUMN_FIELD_DESC);
        oprot.writeString(this.columnFamily_column);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_column_count_args(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("tablename:");
      sb.append(this.tablename);
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      sb.append(this.key);
      first = false;
      if (!first) sb.append(", ");
      sb.append("columnFamily_column:");
      sb.append(this.columnFamily_column);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_column_count_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_column_count_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public int success;
    public static final int SUCCESS = 0;
    public CassandraException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
      public boolean e = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_column_count_result.class, metaDataMap);
    }

    public get_column_count_result() {
    }

    public get_column_count_result(
      int success,
      CassandraException e)
    {
      this();
      this.success = success;
      this.__isset.success = true;
      this.e = e;
      this.__isset.e = (e != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_column_count_result(get_column_count_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
      __isset.e = other.__isset.e;
      if (other.e != null) {
        this.e = new CassandraException(other.e);
      }
    }

    @Override
    public get_column_count_result clone() {
      return new get_column_count_result(this);
    }

    public int getSuccess() {
      return this.success;
    }

    public void setSuccess(int success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public CassandraException getE() {
      return this.e;
    }

    public void setE(CassandraException e) {
      this.e = e;
      this.__isset.e = (e != null);
    }

    public void unsetE() {
      this.e = null;
      this.__isset.e = false;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.__isset.e;
    }

    public void setEIsSet(boolean value) {
      this.__isset.e = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        setSuccess((Integer)value);
        break;

      case E:
        setE((CassandraException)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Integer(getSuccess());

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return this.__isset.success;
      case E:
        return this.__isset.e;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_column_count_result)
        return this.equals((get_column_count_result)that);
      return false;
    }

    public boolean equals(get_column_count_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_e = true && (this.e != null);
      boolean that_present_e = true && (that.e != null);
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.I32) {
              this.success = iprot.readI32();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new CassandraException();
              this.e.read(iprot);
              this.__isset.e = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.__isset.success) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI32(this.success);
        oprot.writeFieldEnd();
      } else if (this.__isset.e) {
        if (this.e != null) {
          oprot.writeFieldBegin(E_FIELD_DESC);
          this.e.write(oprot);
          oprot.writeFieldEnd();
        }
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_column_count_result(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      sb.append(this.e);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class insert_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("insert_args");
    private static final TField TABLENAME_FIELD_DESC = new TField("tablename", TType.STRING, (short)-1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)-2);
    private static final TField COLUMN_FAMILY_COLUMN_FIELD_DESC = new TField("columnFamily_column", TType.STRING, (short)-3);
    private static final TField CELL_DATA_FIELD_DESC = new TField("cellData", TType.STRING, (short)-4);
    private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)-5);

    public String tablename;
    public static final int TABLENAME = -1;
    public String key;
    public static final int KEY = -2;
    public String columnFamily_column;
    public static final int COLUMNFAMILY_COLUMN = -3;
    public byte[] cellData;
    public static final int CELLDATA = -4;
    public long timestamp;
    public static final int TIMESTAMP = -5;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean tablename = false;
      public boolean key = false;
      public boolean columnFamily_column = false;
      public boolean cellData = false;
      public boolean timestamp = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLENAME, new FieldMetaData("tablename", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMNFAMILY_COLUMN, new FieldMetaData("columnFamily_column", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(CELLDATA, new FieldMetaData("cellData", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(insert_args.class, metaDataMap);
    }

    public insert_args() {
    }

    public insert_args(
      String tablename,
      String key,
      String columnFamily_column,
      byte[] cellData,
      long timestamp)
    {
      this();
      this.tablename = tablename;
      this.__isset.tablename = (tablename != null);
      this.key = key;
      this.__isset.key = (key != null);
      this.columnFamily_column = columnFamily_column;
      this.__isset.columnFamily_column = (columnFamily_column != null);
      this.cellData = cellData;
      this.__isset.cellData = (cellData != null);
      this.timestamp = timestamp;
      this.__isset.timestamp = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public insert_args(insert_args other) {
      __isset.tablename = other.__isset.tablename;
      if (other.tablename != null) {
        this.tablename = other.tablename;
      }
      __isset.key = other.__isset.key;
      if (other.key != null) {
        this.key = other.key;
      }
      __isset.columnFamily_column = other.__isset.columnFamily_column;
      if (other.columnFamily_column != null) {
        this.columnFamily_column = other.columnFamily_column;
      }
      __isset.cellData = other.__isset.cellData;
      if (other.cellData != null) {
        this.cellData = new byte[other.cellData.length];
        System.arraycopy(other.cellData, 0, cellData, 0, other.cellData.length);
      }
      __isset.timestamp = other.__isset.timestamp;
      this.timestamp = other.timestamp;
    }

    @Override
    public insert_args clone() {
      return new insert_args(this);
    }

    public String getTablename() {
      return this.tablename;
    }

    public void setTablename(String tablename) {
      this.tablename = tablename;
      this.__isset.tablename = (tablename != null);
    }

    public void unsetTablename() {
      this.__isset.tablename = false;
    }

    // Returns true if field tablename is set (has been asigned a value) and false otherwise
    public boolean isSetTablename() {
      return this.__isset.tablename;
    }

    public void setTablenameIsSet(boolean value) {
      this.__isset.tablename = value;
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
      this.__isset.key = (key != null);
    }

    public void unsetKey() {
      this.__isset.key = false;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.__isset.key;
    }

    public void setKeyIsSet(boolean value) {
      this.__isset.key = value;
    }

    public String getColumnFamily_column() {
      return this.columnFamily_column;
    }

    public void setColumnFamily_column(String columnFamily_column) {
      this.columnFamily_column = columnFamily_column;
      this.__isset.columnFamily_column = (columnFamily_column != null);
    }

    public void unsetColumnFamily_column() {
      this.__isset.columnFamily_column = false;
    }

    // Returns true if field columnFamily_column is set (has been asigned a value) and false otherwise
    public boolean isSetColumnFamily_column() {
      return this.__isset.columnFamily_column;
    }

    public void setColumnFamily_columnIsSet(boolean value) {
      this.__isset.columnFamily_column = value;
    }

    public byte[] getCellData() {
      return this.cellData;
    }

    public void setCellData(byte[] cellData) {
      this.cellData = cellData;
      this.__isset.cellData = (cellData != null);
    }

    public void unsetCellData() {
      this.__isset.cellData = false;
    }

    // Returns true if field cellData is set (has been asigned a value) and false otherwise
    public boolean isSetCellData() {
      return this.__isset.cellData;
    }

    public void setCellDataIsSet(boolean value) {
      this.__isset.cellData = value;
    }

    public long getTimestamp() {
      return this.timestamp;
    }

    public void setTimestamp(long timestamp) {
      this.timestamp = timestamp;
      this.__isset.timestamp = true;
    }

    public void unsetTimestamp() {
      this.__isset.timestamp = false;
    }

    // Returns true if field timestamp is set (has been asigned a value) and false otherwise
    public boolean isSetTimestamp() {
      return this.__isset.timestamp;
    }

    public void setTimestampIsSet(boolean value) {
      this.__isset.timestamp = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLENAME:
        setTablename((String)value);
        break;

      case KEY:
        setKey((String)value);
        break;

      case COLUMNFAMILY_COLUMN:
        setColumnFamily_column((String)value);
        break;

      case CELLDATA:
        setCellData((byte[])value);
        break;

      case TIMESTAMP:
        setTimestamp((Long)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return getTablename();

      case KEY:
        return getKey();

      case COLUMNFAMILY_COLUMN:
        return getColumnFamily_column();

      case CELLDATA:
        return getCellData();

      case TIMESTAMP:
        return new Long(getTimestamp());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return this.__isset.tablename;
      case KEY:
        return this.__isset.key;
      case COLUMNFAMILY_COLUMN:
        return this.__isset.columnFamily_column;
      case CELLDATA:
        return this.__isset.cellData;
      case TIMESTAMP:
        return this.__isset.timestamp;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof insert_args)
        return this.equals((insert_args)that);
      return false;
    }

    public boolean equals(insert_args that) {
      if (that == null)
        return false;

      boolean this_present_tablename = true && (this.tablename != null);
      boolean that_present_tablename = true && (that.tablename != null);
      if (this_present_tablename || that_present_tablename) {
        if (!(this_present_tablename && that_present_tablename))
          return false;
        if (!this.tablename.equals(that.tablename))
          return false;
      }

      boolean this_present_key = true && (this.key != null);
      boolean that_present_key = true && (that.key != null);
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_columnFamily_column = true && (this.columnFamily_column != null);
      boolean that_present_columnFamily_column = true && (that.columnFamily_column != null);
      if (this_present_columnFamily_column || that_present_columnFamily_column) {
        if (!(this_present_columnFamily_column && that_present_columnFamily_column))
          return false;
        if (!this.columnFamily_column.equals(that.columnFamily_column))
          return false;
      }

      boolean this_present_cellData = true && (this.cellData != null);
      boolean that_present_cellData = true && (that.cellData != null);
      if (this_present_cellData || that_present_cellData) {
        if (!(this_present_cellData && that_present_cellData))
          return false;
        if (!java.util.Arrays.equals(this.cellData, that.cellData))
          return false;
      }

      boolean this_present_timestamp = true;
      boolean that_present_timestamp = true;
      if (this_present_timestamp || that_present_timestamp) {
        if (!(this_present_timestamp && that_present_timestamp))
          return false;
        if (this.timestamp != that.timestamp)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLENAME:
            if (field.type == TType.STRING) {
              this.tablename = iprot.readString();
              this.__isset.tablename = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
              this.__isset.key = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMNFAMILY_COLUMN:
            if (field.type == TType.STRING) {
              this.columnFamily_column = iprot.readString();
              this.__isset.columnFamily_column = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case CELLDATA:
            if (field.type == TType.STRING) {
              this.cellData = iprot.readBinary();
              this.__isset.cellData = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case TIMESTAMP:
            if (field.type == TType.I64) {
              this.timestamp = iprot.readI64();
              this.__isset.timestamp = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tablename != null) {
        oprot.writeFieldBegin(TABLENAME_FIELD_DESC);
        oprot.writeString(this.tablename);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.columnFamily_column != null) {
        oprot.writeFieldBegin(COLUMN_FAMILY_COLUMN_FIELD_DESC);
        oprot.writeString(this.columnFamily_column);
        oprot.writeFieldEnd();
      }
      if (this.cellData != null) {
        oprot.writeFieldBegin(CELL_DATA_FIELD_DESC);
        oprot.writeBinary(this.cellData);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
      oprot.writeI64(this.timestamp);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("insert_args(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("tablename:");
      sb.append(this.tablename);
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      sb.append(this.key);
      first = false;
      if (!first) sb.append(", ");
      sb.append("columnFamily_column:");
      sb.append(this.columnFamily_column);
      first = false;
      if (!first) sb.append(", ");
      sb.append("cellData:");
      if (cellData == null) { 
        sb.append("null");
      } else {
        int __cellData_size = Math.min(this.cellData.length, 128);
        for (int i = 0; i < __cellData_size; i++) {
          if (i != 0) sb.append(" ");
          sb.append(Integer.toHexString(this.cellData[i]).length() > 1 ? Integer.toHexString(this.cellData[i]).substring(Integer.toHexString(this.cellData[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.cellData[i]).toUpperCase());
        }
        if (this.cellData.length > 128) sb.append(" ...");
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("timestamp:");
      sb.append(this.timestamp);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class batch_insert_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("batch_insert_args");
    private static final TField BATCH_MUTATION_FIELD_DESC = new TField("batchMutation", TType.STRUCT, (short)-1);

    public batch_mutation_t batchMutation;
    public static final int BATCHMUTATION = -1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean batchMutation = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(BATCHMUTATION, new FieldMetaData("batchMutation", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, batch_mutation_t.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(batch_insert_args.class, metaDataMap);
    }

    public batch_insert_args() {
    }

    public batch_insert_args(
      batch_mutation_t batchMutation)
    {
      this();
      this.batchMutation = batchMutation;
      this.__isset.batchMutation = (batchMutation != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public batch_insert_args(batch_insert_args other) {
      __isset.batchMutation = other.__isset.batchMutation;
      if (other.batchMutation != null) {
        this.batchMutation = new batch_mutation_t(other.batchMutation);
      }
    }

    @Override
    public batch_insert_args clone() {
      return new batch_insert_args(this);
    }

    public batch_mutation_t getBatchMutation() {
      return this.batchMutation;
    }

    public void setBatchMutation(batch_mutation_t batchMutation) {
      this.batchMutation = batchMutation;
      this.__isset.batchMutation = (batchMutation != null);
    }

    public void unsetBatchMutation() {
      this.batchMutation = null;
      this.__isset.batchMutation = false;
    }

    // Returns true if field batchMutation is set (has been asigned a value) and false otherwise
    public boolean isSetBatchMutation() {
      return this.__isset.batchMutation;
    }

    public void setBatchMutationIsSet(boolean value) {
      this.__isset.batchMutation = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case BATCHMUTATION:
        setBatchMutation((batch_mutation_t)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case BATCHMUTATION:
        return getBatchMutation();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case BATCHMUTATION:
        return this.__isset.batchMutation;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof batch_insert_args)
        return this.equals((batch_insert_args)that);
      return false;
    }

    public boolean equals(batch_insert_args that) {
      if (that == null)
        return false;

      boolean this_present_batchMutation = true && (this.batchMutation != null);
      boolean that_present_batchMutation = true && (that.batchMutation != null);
      if (this_present_batchMutation || that_present_batchMutation) {
        if (!(this_present_batchMutation && that_present_batchMutation))
          return false;
        if (!this.batchMutation.equals(that.batchMutation))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case BATCHMUTATION:
            if (field.type == TType.STRUCT) {
              this.batchMutation = new batch_mutation_t();
              this.batchMutation.read(iprot);
              this.__isset.batchMutation = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.batchMutation != null) {
        oprot.writeFieldBegin(BATCH_MUTATION_FIELD_DESC);
        this.batchMutation.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("batch_insert_args(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("batchMutation:");
      sb.append(this.batchMutation);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class batch_insert_blocking_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("batch_insert_blocking_args");
    private static final TField BATCH_MUTATION_FIELD_DESC = new TField("batchMutation", TType.STRUCT, (short)-1);

    public batch_mutation_t batchMutation;
    public static final int BATCHMUTATION = -1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean batchMutation = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(BATCHMUTATION, new FieldMetaData("batchMutation", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, batch_mutation_t.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(batch_insert_blocking_args.class, metaDataMap);
    }

    public batch_insert_blocking_args() {
    }

    public batch_insert_blocking_args(
      batch_mutation_t batchMutation)
    {
      this();
      this.batchMutation = batchMutation;
      this.__isset.batchMutation = (batchMutation != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public batch_insert_blocking_args(batch_insert_blocking_args other) {
      __isset.batchMutation = other.__isset.batchMutation;
      if (other.batchMutation != null) {
        this.batchMutation = new batch_mutation_t(other.batchMutation);
      }
    }

    @Override
    public batch_insert_blocking_args clone() {
      return new batch_insert_blocking_args(this);
    }

    public batch_mutation_t getBatchMutation() {
      return this.batchMutation;
    }

    public void setBatchMutation(batch_mutation_t batchMutation) {
      this.batchMutation = batchMutation;
      this.__isset.batchMutation = (batchMutation != null);
    }

    public void unsetBatchMutation() {
      this.batchMutation = null;
      this.__isset.batchMutation = false;
    }

    // Returns true if field batchMutation is set (has been asigned a value) and false otherwise
    public boolean isSetBatchMutation() {
      return this.__isset.batchMutation;
    }

    public void setBatchMutationIsSet(boolean value) {
      this.__isset.batchMutation = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case BATCHMUTATION:
        setBatchMutation((batch_mutation_t)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case BATCHMUTATION:
        return getBatchMutation();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case BATCHMUTATION:
        return this.__isset.batchMutation;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof batch_insert_blocking_args)
        return this.equals((batch_insert_blocking_args)that);
      return false;
    }

    public boolean equals(batch_insert_blocking_args that) {
      if (that == null)
        return false;

      boolean this_present_batchMutation = true && (this.batchMutation != null);
      boolean that_present_batchMutation = true && (that.batchMutation != null);
      if (this_present_batchMutation || that_present_batchMutation) {
        if (!(this_present_batchMutation && that_present_batchMutation))
          return false;
        if (!this.batchMutation.equals(that.batchMutation))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case BATCHMUTATION:
            if (field.type == TType.STRUCT) {
              this.batchMutation = new batch_mutation_t();
              this.batchMutation.read(iprot);
              this.__isset.batchMutation = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.batchMutation != null) {
        oprot.writeFieldBegin(BATCH_MUTATION_FIELD_DESC);
        this.batchMutation.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("batch_insert_blocking_args(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("batchMutation:");
      sb.append(this.batchMutation);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class batch_insert_blocking_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("batch_insert_blocking_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public boolean success;
    public static final int SUCCESS = 0;
    public CassandraException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
      public boolean e = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(batch_insert_blocking_result.class, metaDataMap);
    }

    public batch_insert_blocking_result() {
    }

    public batch_insert_blocking_result(
      boolean success,
      CassandraException e)
    {
      this();
      this.success = success;
      this.__isset.success = true;
      this.e = e;
      this.__isset.e = (e != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public batch_insert_blocking_result(batch_insert_blocking_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
      __isset.e = other.__isset.e;
      if (other.e != null) {
        this.e = new CassandraException(other.e);
      }
    }

    @Override
    public batch_insert_blocking_result clone() {
      return new batch_insert_blocking_result(this);
    }

    public boolean isSuccess() {
      return this.success;
    }

    public void setSuccess(boolean success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public CassandraException getE() {
      return this.e;
    }

    public void setE(CassandraException e) {
      this.e = e;
      this.__isset.e = (e != null);
    }

    public void unsetE() {
      this.e = null;
      this.__isset.e = false;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.__isset.e;
    }

    public void setEIsSet(boolean value) {
      this.__isset.e = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        setSuccess((Boolean)value);
        break;

      case E:
        setE((CassandraException)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Boolean(isSuccess());

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return this.__isset.success;
      case E:
        return this.__isset.e;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof batch_insert_blocking_result)
        return this.equals((batch_insert_blocking_result)that);
      return false;
    }

    public boolean equals(batch_insert_blocking_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_e = true && (this.e != null);
      boolean that_present_e = true && (that.e != null);
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new CassandraException();
              this.e.read(iprot);
              this.__isset.e = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.__isset.success) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      } else if (this.__isset.e) {
        if (this.e != null) {
          oprot.writeFieldBegin(E_FIELD_DESC);
          this.e.write(oprot);
          oprot.writeFieldEnd();
        }
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("batch_insert_blocking_result(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      sb.append(this.e);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class remove_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("remove_args");
    private static final TField TABLENAME_FIELD_DESC = new TField("tablename", TType.STRING, (short)-1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)-2);
    private static final TField COLUMN_FAMILY_COLUMN_FIELD_DESC = new TField("columnFamily_column", TType.STRING, (short)-3);
    private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)-4);
    private static final TField BLOCK_FIELD_DESC = new TField("block", TType.BOOL, (short)-5);

    public String tablename;
    public static final int TABLENAME = -1;
    public String key;
    public static final int KEY = -2;
    public String columnFamily_column;
    public static final int COLUMNFAMILY_COLUMN = -3;
    public long timestamp;
    public static final int TIMESTAMP = -4;
    public boolean block;
    public static final int BLOCK = -5;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean tablename = false;
      public boolean key = false;
      public boolean columnFamily_column = false;
      public boolean timestamp = false;
      public boolean block = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLENAME, new FieldMetaData("tablename", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMNFAMILY_COLUMN, new FieldMetaData("columnFamily_column", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(BLOCK, new FieldMetaData("block", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(remove_args.class, metaDataMap);
    }

    public remove_args() {
    }

    public remove_args(
      String tablename,
      String key,
      String columnFamily_column,
      long timestamp,
      boolean block)
    {
      this();
      this.tablename = tablename;
      this.__isset.tablename = (tablename != null);
      this.key = key;
      this.__isset.key = (key != null);
      this.columnFamily_column = columnFamily_column;
      this.__isset.columnFamily_column = (columnFamily_column != null);
      this.timestamp = timestamp;
      this.__isset.timestamp = true;
      this.block = block;
      this.__isset.block = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public remove_args(remove_args other) {
      __isset.tablename = other.__isset.tablename;
      if (other.tablename != null) {
        this.tablename = other.tablename;
      }
      __isset.key = other.__isset.key;
      if (other.key != null) {
        this.key = other.key;
      }
      __isset.columnFamily_column = other.__isset.columnFamily_column;
      if (other.columnFamily_column != null) {
        this.columnFamily_column = other.columnFamily_column;
      }
      __isset.timestamp = other.__isset.timestamp;
      this.timestamp = other.timestamp;
      __isset.block = other.__isset.block;
      this.block = other.block;
    }

    @Override
    public remove_args clone() {
      return new remove_args(this);
    }

    public String getTablename() {
      return this.tablename;
    }

    public void setTablename(String tablename) {
      this.tablename = tablename;
      this.__isset.tablename = (tablename != null);
    }

    public void unsetTablename() {
      this.__isset.tablename = false;
    }

    // Returns true if field tablename is set (has been asigned a value) and false otherwise
    public boolean isSetTablename() {
      return this.__isset.tablename;
    }

    public void setTablenameIsSet(boolean value) {
      this.__isset.tablename = value;
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
      this.__isset.key = (key != null);
    }

    public void unsetKey() {
      this.__isset.key = false;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.__isset.key;
    }

    public void setKeyIsSet(boolean value) {
      this.__isset.key = value;
    }

    public String getColumnFamily_column() {
      return this.columnFamily_column;
    }

    public void setColumnFamily_column(String columnFamily_column) {
      this.columnFamily_column = columnFamily_column;
      this.__isset.columnFamily_column = (columnFamily_column != null);
    }

    public void unsetColumnFamily_column() {
      this.__isset.columnFamily_column = false;
    }

    // Returns true if field columnFamily_column is set (has been asigned a value) and false otherwise
    public boolean isSetColumnFamily_column() {
      return this.__isset.columnFamily_column;
    }

    public void setColumnFamily_columnIsSet(boolean value) {
      this.__isset.columnFamily_column = value;
    }

    public long getTimestamp() {
      return this.timestamp;
    }

    public void setTimestamp(long timestamp) {
      this.timestamp = timestamp;
      this.__isset.timestamp = true;
    }

    public void unsetTimestamp() {
      this.__isset.timestamp = false;
    }

    // Returns true if field timestamp is set (has been asigned a value) and false otherwise
    public boolean isSetTimestamp() {
      return this.__isset.timestamp;
    }

    public void setTimestampIsSet(boolean value) {
      this.__isset.timestamp = value;
    }

    public boolean isBlock() {
      return this.block;
    }

    public void setBlock(boolean block) {
      this.block = block;
      this.__isset.block = true;
    }

    public void unsetBlock() {
      this.__isset.block = false;
    }

    // Returns true if field block is set (has been asigned a value) and false otherwise
    public boolean isSetBlock() {
      return this.__isset.block;
    }

    public void setBlockIsSet(boolean value) {
      this.__isset.block = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLENAME:
        setTablename((String)value);
        break;

      case KEY:
        setKey((String)value);
        break;

      case COLUMNFAMILY_COLUMN:
        setColumnFamily_column((String)value);
        break;

      case TIMESTAMP:
        setTimestamp((Long)value);
        break;

      case BLOCK:
        setBlock((Boolean)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return getTablename();

      case KEY:
        return getKey();

      case COLUMNFAMILY_COLUMN:
        return getColumnFamily_column();

      case TIMESTAMP:
        return new Long(getTimestamp());

      case BLOCK:
        return new Boolean(isBlock());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return this.__isset.tablename;
      case KEY:
        return this.__isset.key;
      case COLUMNFAMILY_COLUMN:
        return this.__isset.columnFamily_column;
      case TIMESTAMP:
        return this.__isset.timestamp;
      case BLOCK:
        return this.__isset.block;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof remove_args)
        return this.equals((remove_args)that);
      return false;
    }

    public boolean equals(remove_args that) {
      if (that == null)
        return false;

      boolean this_present_tablename = true && (this.tablename != null);
      boolean that_present_tablename = true && (that.tablename != null);
      if (this_present_tablename || that_present_tablename) {
        if (!(this_present_tablename && that_present_tablename))
          return false;
        if (!this.tablename.equals(that.tablename))
          return false;
      }

      boolean this_present_key = true && (this.key != null);
      boolean that_present_key = true && (that.key != null);
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_columnFamily_column = true && (this.columnFamily_column != null);
      boolean that_present_columnFamily_column = true && (that.columnFamily_column != null);
      if (this_present_columnFamily_column || that_present_columnFamily_column) {
        if (!(this_present_columnFamily_column && that_present_columnFamily_column))
          return false;
        if (!this.columnFamily_column.equals(that.columnFamily_column))
          return false;
      }

      boolean this_present_timestamp = true;
      boolean that_present_timestamp = true;
      if (this_present_timestamp || that_present_timestamp) {
        if (!(this_present_timestamp && that_present_timestamp))
          return false;
        if (this.timestamp != that.timestamp)
          return false;
      }

      boolean this_present_block = true;
      boolean that_present_block = true;
      if (this_present_block || that_present_block) {
        if (!(this_present_block && that_present_block))
          return false;
        if (this.block != that.block)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLENAME:
            if (field.type == TType.STRING) {
              this.tablename = iprot.readString();
              this.__isset.tablename = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
              this.__isset.key = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMNFAMILY_COLUMN:
            if (field.type == TType.STRING) {
              this.columnFamily_column = iprot.readString();
              this.__isset.columnFamily_column = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case TIMESTAMP:
            if (field.type == TType.I64) {
              this.timestamp = iprot.readI64();
              this.__isset.timestamp = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case BLOCK:
            if (field.type == TType.BOOL) {
              this.block = iprot.readBool();
              this.__isset.block = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tablename != null) {
        oprot.writeFieldBegin(TABLENAME_FIELD_DESC);
        oprot.writeString(this.tablename);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.columnFamily_column != null) {
        oprot.writeFieldBegin(COLUMN_FAMILY_COLUMN_FIELD_DESC);
        oprot.writeString(this.columnFamily_column);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
      oprot.writeI64(this.timestamp);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(BLOCK_FIELD_DESC);
      oprot.writeBool(this.block);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("remove_args(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("tablename:");
      sb.append(this.tablename);
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      sb.append(this.key);
      first = false;
      if (!first) sb.append(", ");
      sb.append("columnFamily_column:");
      sb.append(this.columnFamily_column);
      first = false;
      if (!first) sb.append(", ");
      sb.append("timestamp:");
      sb.append(this.timestamp);
      first = false;
      if (!first) sb.append(", ");
      sb.append("block:");
      sb.append(this.block);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class remove_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("remove_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);

    public boolean success;
    public static final int SUCCESS = 0;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(remove_result.class, metaDataMap);
    }

    public remove_result() {
    }

    public remove_result(
      boolean success)
    {
      this();
      this.success = success;
      this.__isset.success = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public remove_result(remove_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
    }

    @Override
    public remove_result clone() {
      return new remove_result(this);
    }

    public boolean isSuccess() {
      return this.success;
    }

    public void setSuccess(boolean success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        setSuccess((Boolean)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Boolean(isSuccess());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return this.__isset.success;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof remove_result)
        return this.equals((remove_result)that);
      return false;
    }

    public boolean equals(remove_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.__isset.success) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("remove_result(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("success:");
      sb.append(this.success);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_columns_since_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_columns_since_args");
    private static final TField TABLENAME_FIELD_DESC = new TField("tablename", TType.STRING, (short)-1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)-2);
    private static final TField COLUMN_FAMILY_COLUMN_FIELD_DESC = new TField("columnFamily_column", TType.STRING, (short)-3);
    private static final TField TIME_STAMP_FIELD_DESC = new TField("timeStamp", TType.I64, (short)-4);

    public String tablename;
    public static final int TABLENAME = -1;
    public String key;
    public static final int KEY = -2;
    public String columnFamily_column;
    public static final int COLUMNFAMILY_COLUMN = -3;
    public long timeStamp;
    public static final int TIMESTAMP = -4;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean tablename = false;
      public boolean key = false;
      public boolean columnFamily_column = false;
      public boolean timeStamp = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLENAME, new FieldMetaData("tablename", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMNFAMILY_COLUMN, new FieldMetaData("columnFamily_column", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(TIMESTAMP, new FieldMetaData("timeStamp", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_columns_since_args.class, metaDataMap);
    }

    public get_columns_since_args() {
    }

    public get_columns_since_args(
      String tablename,
      String key,
      String columnFamily_column,
      long timeStamp)
    {
      this();
      this.tablename = tablename;
      this.__isset.tablename = (tablename != null);
      this.key = key;
      this.__isset.key = (key != null);
      this.columnFamily_column = columnFamily_column;
      this.__isset.columnFamily_column = (columnFamily_column != null);
      this.timeStamp = timeStamp;
      this.__isset.timeStamp = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_columns_since_args(get_columns_since_args other) {
      __isset.tablename = other.__isset.tablename;
      if (other.tablename != null) {
        this.tablename = other.tablename;
      }
      __isset.key = other.__isset.key;
      if (other.key != null) {
        this.key = other.key;
      }
      __isset.columnFamily_column = other.__isset.columnFamily_column;
      if (other.columnFamily_column != null) {
        this.columnFamily_column = other.columnFamily_column;
      }
      __isset.timeStamp = other.__isset.timeStamp;
      this.timeStamp = other.timeStamp;
    }

    @Override
    public get_columns_since_args clone() {
      return new get_columns_since_args(this);
    }

    public String getTablename() {
      return this.tablename;
    }

    public void setTablename(String tablename) {
      this.tablename = tablename;
      this.__isset.tablename = (tablename != null);
    }

    public void unsetTablename() {
      this.__isset.tablename = false;
    }

    // Returns true if field tablename is set (has been asigned a value) and false otherwise
    public boolean isSetTablename() {
      return this.__isset.tablename;
    }

    public void setTablenameIsSet(boolean value) {
      this.__isset.tablename = value;
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
      this.__isset.key = (key != null);
    }

    public void unsetKey() {
      this.__isset.key = false;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.__isset.key;
    }

    public void setKeyIsSet(boolean value) {
      this.__isset.key = value;
    }

    public String getColumnFamily_column() {
      return this.columnFamily_column;
    }

    public void setColumnFamily_column(String columnFamily_column) {
      this.columnFamily_column = columnFamily_column;
      this.__isset.columnFamily_column = (columnFamily_column != null);
    }

    public void unsetColumnFamily_column() {
      this.__isset.columnFamily_column = false;
    }

    // Returns true if field columnFamily_column is set (has been asigned a value) and false otherwise
    public boolean isSetColumnFamily_column() {
      return this.__isset.columnFamily_column;
    }

    public void setColumnFamily_columnIsSet(boolean value) {
      this.__isset.columnFamily_column = value;
    }

    public long getTimeStamp() {
      return this.timeStamp;
    }

    public void setTimeStamp(long timeStamp) {
      this.timeStamp = timeStamp;
      this.__isset.timeStamp = true;
    }

    public void unsetTimeStamp() {
      this.__isset.timeStamp = false;
    }

    // Returns true if field timeStamp is set (has been asigned a value) and false otherwise
    public boolean isSetTimeStamp() {
      return this.__isset.timeStamp;
    }

    public void setTimeStampIsSet(boolean value) {
      this.__isset.timeStamp = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLENAME:
        setTablename((String)value);
        break;

      case KEY:
        setKey((String)value);
        break;

      case COLUMNFAMILY_COLUMN:
        setColumnFamily_column((String)value);
        break;

      case TIMESTAMP:
        setTimeStamp((Long)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return getTablename();

      case KEY:
        return getKey();

      case COLUMNFAMILY_COLUMN:
        return getColumnFamily_column();

      case TIMESTAMP:
        return new Long(getTimeStamp());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return this.__isset.tablename;
      case KEY:
        return this.__isset.key;
      case COLUMNFAMILY_COLUMN:
        return this.__isset.columnFamily_column;
      case TIMESTAMP:
        return this.__isset.timeStamp;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_columns_since_args)
        return this.equals((get_columns_since_args)that);
      return false;
    }

    public boolean equals(get_columns_since_args that) {
      if (that == null)
        return false;

      boolean this_present_tablename = true && (this.tablename != null);
      boolean that_present_tablename = true && (that.tablename != null);
      if (this_present_tablename || that_present_tablename) {
        if (!(this_present_tablename && that_present_tablename))
          return false;
        if (!this.tablename.equals(that.tablename))
          return false;
      }

      boolean this_present_key = true && (this.key != null);
      boolean that_present_key = true && (that.key != null);
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_columnFamily_column = true && (this.columnFamily_column != null);
      boolean that_present_columnFamily_column = true && (that.columnFamily_column != null);
      if (this_present_columnFamily_column || that_present_columnFamily_column) {
        if (!(this_present_columnFamily_column && that_present_columnFamily_column))
          return false;
        if (!this.columnFamily_column.equals(that.columnFamily_column))
          return false;
      }

      boolean this_present_timeStamp = true;
      boolean that_present_timeStamp = true;
      if (this_present_timeStamp || that_present_timeStamp) {
        if (!(this_present_timeStamp && that_present_timeStamp))
          return false;
        if (this.timeStamp != that.timeStamp)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLENAME:
            if (field.type == TType.STRING) {
              this.tablename = iprot.readString();
              this.__isset.tablename = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
              this.__isset.key = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMNFAMILY_COLUMN:
            if (field.type == TType.STRING) {
              this.columnFamily_column = iprot.readString();
              this.__isset.columnFamily_column = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case TIMESTAMP:
            if (field.type == TType.I64) {
              this.timeStamp = iprot.readI64();
              this.__isset.timeStamp = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tablename != null) {
        oprot.writeFieldBegin(TABLENAME_FIELD_DESC);
        oprot.writeString(this.tablename);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.columnFamily_column != null) {
        oprot.writeFieldBegin(COLUMN_FAMILY_COLUMN_FIELD_DESC);
        oprot.writeString(this.columnFamily_column);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(TIME_STAMP_FIELD_DESC);
      oprot.writeI64(this.timeStamp);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_columns_since_args(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("tablename:");
      sb.append(this.tablename);
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      sb.append(this.key);
      first = false;
      if (!first) sb.append(", ");
      sb.append("columnFamily_column:");
      sb.append(this.columnFamily_column);
      first = false;
      if (!first) sb.append(", ");
      sb.append("timeStamp:");
      sb.append(this.timeStamp);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_columns_since_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_columns_since_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<column_t> success;
    public static final int SUCCESS = 0;
    public CassandraException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
      public boolean e = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, column_t.class))));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_columns_since_result.class, metaDataMap);
    }

    public get_columns_since_result() {
    }

    public get_columns_since_result(
      List<column_t> success,
      CassandraException e)
    {
      this();
      this.success = success;
      this.__isset.success = (success != null);
      this.e = e;
      this.__isset.e = (e != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_columns_since_result(get_columns_since_result other) {
      __isset.success = other.__isset.success;
      if (other.success != null) {
        List<column_t> __this__success = new ArrayList<column_t>();
        for (column_t other_element : other.success) {
          __this__success.add(new column_t(other_element));
        }
        this.success = __this__success;
      }
      __isset.e = other.__isset.e;
      if (other.e != null) {
        this.e = new CassandraException(other.e);
      }
    }

    @Override
    public get_columns_since_result clone() {
      return new get_columns_since_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<column_t> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(column_t elem) {
      if (this.success == null) {
        this.success = new ArrayList<column_t>();
      }
      this.success.add(elem);
      this.__isset.success = true;
    }

    public List<column_t> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<column_t> success) {
      this.success = success;
      this.__isset.success = (success != null);
    }

    public void unsetSuccess() {
      this.success = null;
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public CassandraException getE() {
      return this.e;
    }

    public void setE(CassandraException e) {
      this.e = e;
      this.__isset.e = (e != null);
    }

    public void unsetE() {
      this.e = null;
      this.__isset.e = false;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.__isset.e;
    }

    public void setEIsSet(boolean value) {
      this.__isset.e = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        setSuccess((List<column_t>)value);
        break;

      case E:
        setE((CassandraException)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return this.__isset.success;
      case E:
        return this.__isset.e;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_columns_since_result)
        return this.equals((get_columns_since_result)that);
      return false;
    }

    public boolean equals(get_columns_since_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && (this.success != null);
      boolean that_present_success = true && (that.success != null);
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && (this.e != null);
      boolean that_present_e = true && (that.e != null);
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list61 = iprot.readListBegin();
                this.success = new ArrayList<column_t>(_list61.size);
                for (int _i62 = 0; _i62 < _list61.size; ++_i62)
                {
                  column_t _elem63;
                  _elem63 = new column_t();
                  _elem63.read(iprot);
                  this.success.add(_elem63);
                }
                iprot.readListEnd();
              }
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new CassandraException();
              this.e.read(iprot);
              this.__isset.e = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.__isset.success) {
        if (this.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          {
            oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
            for (column_t _iter64 : this.success)            {
              _iter64.write(oprot);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
      } else if (this.__isset.e) {
        if (this.e != null) {
          oprot.writeFieldBegin(E_FIELD_DESC);
          this.e.write(oprot);
          oprot.writeFieldEnd();
        }
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_columns_since_result(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      sb.append(this.e);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_slice_super_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_slice_super_args");
    private static final TField TABLENAME_FIELD_DESC = new TField("tablename", TType.STRING, (short)-1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)-2);
    private static final TField COLUMN_FAMILY_SUPER_COLUMN_NAME_FIELD_DESC = new TField("columnFamily_superColumnName", TType.STRING, (short)-3);
    private static final TField START_FIELD_DESC = new TField("start", TType.I32, (short)-4);
    private static final TField COUNT_FIELD_DESC = new TField("count", TType.I32, (short)-5);

    public String tablename;
    public static final int TABLENAME = -1;
    public String key;
    public static final int KEY = -2;
    public String columnFamily_superColumnName;
    public static final int COLUMNFAMILY_SUPERCOLUMNNAME = -3;
    public int start;
    public static final int START = -4;
    public int count;
    public static final int COUNT = -5;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean tablename = false;
      public boolean key = false;
      public boolean columnFamily_superColumnName = false;
      public boolean start = false;
      public boolean count = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLENAME, new FieldMetaData("tablename", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMNFAMILY_SUPERCOLUMNNAME, new FieldMetaData("columnFamily_superColumnName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(START, new FieldMetaData("start", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      put(COUNT, new FieldMetaData("count", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_slice_super_args.class, metaDataMap);
    }

    public get_slice_super_args() {
      this.start = -1;

      this.count = -1;

    }

    public get_slice_super_args(
      String tablename,
      String key,
      String columnFamily_superColumnName,
      int start,
      int count)
    {
      this();
      this.tablename = tablename;
      this.__isset.tablename = (tablename != null);
      this.key = key;
      this.__isset.key = (key != null);
      this.columnFamily_superColumnName = columnFamily_superColumnName;
      this.__isset.columnFamily_superColumnName = (columnFamily_superColumnName != null);
      this.start = start;
      this.__isset.start = true;
      this.count = count;
      this.__isset.count = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_slice_super_args(get_slice_super_args other) {
      __isset.tablename = other.__isset.tablename;
      if (other.tablename != null) {
        this.tablename = other.tablename;
      }
      __isset.key = other.__isset.key;
      if (other.key != null) {
        this.key = other.key;
      }
      __isset.columnFamily_superColumnName = other.__isset.columnFamily_superColumnName;
      if (other.columnFamily_superColumnName != null) {
        this.columnFamily_superColumnName = other.columnFamily_superColumnName;
      }
      __isset.start = other.__isset.start;
      this.start = other.start;
      __isset.count = other.__isset.count;
      this.count = other.count;
    }

    @Override
    public get_slice_super_args clone() {
      return new get_slice_super_args(this);
    }

    public String getTablename() {
      return this.tablename;
    }

    public void setTablename(String tablename) {
      this.tablename = tablename;
      this.__isset.tablename = (tablename != null);
    }

    public void unsetTablename() {
      this.__isset.tablename = false;
    }

    // Returns true if field tablename is set (has been asigned a value) and false otherwise
    public boolean isSetTablename() {
      return this.__isset.tablename;
    }

    public void setTablenameIsSet(boolean value) {
      this.__isset.tablename = value;
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
      this.__isset.key = (key != null);
    }

    public void unsetKey() {
      this.__isset.key = false;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.__isset.key;
    }

    public void setKeyIsSet(boolean value) {
      this.__isset.key = value;
    }

    public String getColumnFamily_superColumnName() {
      return this.columnFamily_superColumnName;
    }

    public void setColumnFamily_superColumnName(String columnFamily_superColumnName) {
      this.columnFamily_superColumnName = columnFamily_superColumnName;
      this.__isset.columnFamily_superColumnName = (columnFamily_superColumnName != null);
    }

    public void unsetColumnFamily_superColumnName() {
      this.__isset.columnFamily_superColumnName = false;
    }

    // Returns true if field columnFamily_superColumnName is set (has been asigned a value) and false otherwise
    public boolean isSetColumnFamily_superColumnName() {
      return this.__isset.columnFamily_superColumnName;
    }

    public void setColumnFamily_superColumnNameIsSet(boolean value) {
      this.__isset.columnFamily_superColumnName = value;
    }

    public int getStart() {
      return this.start;
    }

    public void setStart(int start) {
      this.start = start;
      this.__isset.start = true;
    }

    public void unsetStart() {
      this.__isset.start = false;
    }

    // Returns true if field start is set (has been asigned a value) and false otherwise
    public boolean isSetStart() {
      return this.__isset.start;
    }

    public void setStartIsSet(boolean value) {
      this.__isset.start = value;
    }

    public int getCount() {
      return this.count;
    }

    public void setCount(int count) {
      this.count = count;
      this.__isset.count = true;
    }

    public void unsetCount() {
      this.__isset.count = false;
    }

    // Returns true if field count is set (has been asigned a value) and false otherwise
    public boolean isSetCount() {
      return this.__isset.count;
    }

    public void setCountIsSet(boolean value) {
      this.__isset.count = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLENAME:
        setTablename((String)value);
        break;

      case KEY:
        setKey((String)value);
        break;

      case COLUMNFAMILY_SUPERCOLUMNNAME:
        setColumnFamily_superColumnName((String)value);
        break;

      case START:
        setStart((Integer)value);
        break;

      case COUNT:
        setCount((Integer)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return getTablename();

      case KEY:
        return getKey();

      case COLUMNFAMILY_SUPERCOLUMNNAME:
        return getColumnFamily_superColumnName();

      case START:
        return new Integer(getStart());

      case COUNT:
        return new Integer(getCount());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return this.__isset.tablename;
      case KEY:
        return this.__isset.key;
      case COLUMNFAMILY_SUPERCOLUMNNAME:
        return this.__isset.columnFamily_superColumnName;
      case START:
        return this.__isset.start;
      case COUNT:
        return this.__isset.count;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_slice_super_args)
        return this.equals((get_slice_super_args)that);
      return false;
    }

    public boolean equals(get_slice_super_args that) {
      if (that == null)
        return false;

      boolean this_present_tablename = true && (this.tablename != null);
      boolean that_present_tablename = true && (that.tablename != null);
      if (this_present_tablename || that_present_tablename) {
        if (!(this_present_tablename && that_present_tablename))
          return false;
        if (!this.tablename.equals(that.tablename))
          return false;
      }

      boolean this_present_key = true && (this.key != null);
      boolean that_present_key = true && (that.key != null);
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_columnFamily_superColumnName = true && (this.columnFamily_superColumnName != null);
      boolean that_present_columnFamily_superColumnName = true && (that.columnFamily_superColumnName != null);
      if (this_present_columnFamily_superColumnName || that_present_columnFamily_superColumnName) {
        if (!(this_present_columnFamily_superColumnName && that_present_columnFamily_superColumnName))
          return false;
        if (!this.columnFamily_superColumnName.equals(that.columnFamily_superColumnName))
          return false;
      }

      boolean this_present_start = true;
      boolean that_present_start = true;
      if (this_present_start || that_present_start) {
        if (!(this_present_start && that_present_start))
          return false;
        if (this.start != that.start)
          return false;
      }

      boolean this_present_count = true;
      boolean that_present_count = true;
      if (this_present_count || that_present_count) {
        if (!(this_present_count && that_present_count))
          return false;
        if (this.count != that.count)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLENAME:
            if (field.type == TType.STRING) {
              this.tablename = iprot.readString();
              this.__isset.tablename = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
              this.__isset.key = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMNFAMILY_SUPERCOLUMNNAME:
            if (field.type == TType.STRING) {
              this.columnFamily_superColumnName = iprot.readString();
              this.__isset.columnFamily_superColumnName = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case START:
            if (field.type == TType.I32) {
              this.start = iprot.readI32();
              this.__isset.start = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COUNT:
            if (field.type == TType.I32) {
              this.count = iprot.readI32();
              this.__isset.count = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tablename != null) {
        oprot.writeFieldBegin(TABLENAME_FIELD_DESC);
        oprot.writeString(this.tablename);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.columnFamily_superColumnName != null) {
        oprot.writeFieldBegin(COLUMN_FAMILY_SUPER_COLUMN_NAME_FIELD_DESC);
        oprot.writeString(this.columnFamily_superColumnName);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(START_FIELD_DESC);
      oprot.writeI32(this.start);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(COUNT_FIELD_DESC);
      oprot.writeI32(this.count);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_slice_super_args(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("tablename:");
      sb.append(this.tablename);
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      sb.append(this.key);
      first = false;
      if (!first) sb.append(", ");
      sb.append("columnFamily_superColumnName:");
      sb.append(this.columnFamily_superColumnName);
      first = false;
      if (!first) sb.append(", ");
      sb.append("start:");
      sb.append(this.start);
      first = false;
      if (!first) sb.append(", ");
      sb.append("count:");
      sb.append(this.count);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_slice_super_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_slice_super_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<superColumn_t> success;
    public static final int SUCCESS = 0;
    public CassandraException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
      public boolean e = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, superColumn_t.class))));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_slice_super_result.class, metaDataMap);
    }

    public get_slice_super_result() {
    }

    public get_slice_super_result(
      List<superColumn_t> success,
      CassandraException e)
    {
      this();
      this.success = success;
      this.__isset.success = (success != null);
      this.e = e;
      this.__isset.e = (e != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_slice_super_result(get_slice_super_result other) {
      __isset.success = other.__isset.success;
      if (other.success != null) {
        List<superColumn_t> __this__success = new ArrayList<superColumn_t>();
        for (superColumn_t other_element : other.success) {
          __this__success.add(new superColumn_t(other_element));
        }
        this.success = __this__success;
      }
      __isset.e = other.__isset.e;
      if (other.e != null) {
        this.e = new CassandraException(other.e);
      }
    }

    @Override
    public get_slice_super_result clone() {
      return new get_slice_super_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<superColumn_t> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(superColumn_t elem) {
      if (this.success == null) {
        this.success = new ArrayList<superColumn_t>();
      }
      this.success.add(elem);
      this.__isset.success = true;
    }

    public List<superColumn_t> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<superColumn_t> success) {
      this.success = success;
      this.__isset.success = (success != null);
    }

    public void unsetSuccess() {
      this.success = null;
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public CassandraException getE() {
      return this.e;
    }

    public void setE(CassandraException e) {
      this.e = e;
      this.__isset.e = (e != null);
    }

    public void unsetE() {
      this.e = null;
      this.__isset.e = false;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.__isset.e;
    }

    public void setEIsSet(boolean value) {
      this.__isset.e = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        setSuccess((List<superColumn_t>)value);
        break;

      case E:
        setE((CassandraException)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return this.__isset.success;
      case E:
        return this.__isset.e;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_slice_super_result)
        return this.equals((get_slice_super_result)that);
      return false;
    }

    public boolean equals(get_slice_super_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && (this.success != null);
      boolean that_present_success = true && (that.success != null);
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && (this.e != null);
      boolean that_present_e = true && (that.e != null);
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list65 = iprot.readListBegin();
                this.success = new ArrayList<superColumn_t>(_list65.size);
                for (int _i66 = 0; _i66 < _list65.size; ++_i66)
                {
                  superColumn_t _elem67;
                  _elem67 = new superColumn_t();
                  _elem67.read(iprot);
                  this.success.add(_elem67);
                }
                iprot.readListEnd();
              }
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new CassandraException();
              this.e.read(iprot);
              this.__isset.e = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.__isset.success) {
        if (this.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          {
            oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
            for (superColumn_t _iter68 : this.success)            {
              _iter68.write(oprot);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
      } else if (this.__isset.e) {
        if (this.e != null) {
          oprot.writeFieldBegin(E_FIELD_DESC);
          this.e.write(oprot);
          oprot.writeFieldEnd();
        }
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_slice_super_result(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      sb.append(this.e);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_slice_super_by_names_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_slice_super_by_names_args");
    private static final TField TABLENAME_FIELD_DESC = new TField("tablename", TType.STRING, (short)-1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)-2);
    private static final TField COLUMN_FAMILY_FIELD_DESC = new TField("columnFamily", TType.STRING, (short)-3);
    private static final TField SUPER_COLUMN_NAMES_FIELD_DESC = new TField("superColumnNames", TType.LIST, (short)-4);

    public String tablename;
    public static final int TABLENAME = -1;
    public String key;
    public static final int KEY = -2;
    public String columnFamily;
    public static final int COLUMNFAMILY = -3;
    public List<String> superColumnNames;
    public static final int SUPERCOLUMNNAMES = -4;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean tablename = false;
      public boolean key = false;
      public boolean columnFamily = false;
      public boolean superColumnNames = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLENAME, new FieldMetaData("tablename", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMNFAMILY, new FieldMetaData("columnFamily", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(SUPERCOLUMNNAMES, new FieldMetaData("superColumnNames", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_slice_super_by_names_args.class, metaDataMap);
    }

    public get_slice_super_by_names_args() {
    }

    public get_slice_super_by_names_args(
      String tablename,
      String key,
      String columnFamily,
      List<String> superColumnNames)
    {
      this();
      this.tablename = tablename;
      this.__isset.tablename = (tablename != null);
      this.key = key;
      this.__isset.key = (key != null);
      this.columnFamily = columnFamily;
      this.__isset.columnFamily = (columnFamily != null);
      this.superColumnNames = superColumnNames;
      this.__isset.superColumnNames = (superColumnNames != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_slice_super_by_names_args(get_slice_super_by_names_args other) {
      __isset.tablename = other.__isset.tablename;
      if (other.tablename != null) {
        this.tablename = other.tablename;
      }
      __isset.key = other.__isset.key;
      if (other.key != null) {
        this.key = other.key;
      }
      __isset.columnFamily = other.__isset.columnFamily;
      if (other.columnFamily != null) {
        this.columnFamily = other.columnFamily;
      }
      __isset.superColumnNames = other.__isset.superColumnNames;
      if (other.superColumnNames != null) {
        List<String> __this__superColumnNames = new ArrayList<String>();
        for (String other_element : other.superColumnNames) {
          __this__superColumnNames.add(other_element);
        }
        this.superColumnNames = __this__superColumnNames;
      }
    }

    @Override
    public get_slice_super_by_names_args clone() {
      return new get_slice_super_by_names_args(this);
    }

    public String getTablename() {
      return this.tablename;
    }

    public void setTablename(String tablename) {
      this.tablename = tablename;
      this.__isset.tablename = (tablename != null);
    }

    public void unsetTablename() {
      this.__isset.tablename = false;
    }

    // Returns true if field tablename is set (has been asigned a value) and false otherwise
    public boolean isSetTablename() {
      return this.__isset.tablename;
    }

    public void setTablenameIsSet(boolean value) {
      this.__isset.tablename = value;
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
      this.__isset.key = (key != null);
    }

    public void unsetKey() {
      this.__isset.key = false;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.__isset.key;
    }

    public void setKeyIsSet(boolean value) {
      this.__isset.key = value;
    }

    public String getColumnFamily() {
      return this.columnFamily;
    }

    public void setColumnFamily(String columnFamily) {
      this.columnFamily = columnFamily;
      this.__isset.columnFamily = (columnFamily != null);
    }

    public void unsetColumnFamily() {
      this.__isset.columnFamily = false;
    }

    // Returns true if field columnFamily is set (has been asigned a value) and false otherwise
    public boolean isSetColumnFamily() {
      return this.__isset.columnFamily;
    }

    public void setColumnFamilyIsSet(boolean value) {
      this.__isset.columnFamily = value;
    }

    public int getSuperColumnNamesSize() {
      return (this.superColumnNames == null) ? 0 : this.superColumnNames.size();
    }

    public java.util.Iterator<String> getSuperColumnNamesIterator() {
      return (this.superColumnNames == null) ? null : this.superColumnNames.iterator();
    }

    public void addToSuperColumnNames(String elem) {
      if (this.superColumnNames == null) {
        this.superColumnNames = new ArrayList<String>();
      }
      this.superColumnNames.add(elem);
      this.__isset.superColumnNames = true;
    }

    public List<String> getSuperColumnNames() {
      return this.superColumnNames;
    }

    public void setSuperColumnNames(List<String> superColumnNames) {
      this.superColumnNames = superColumnNames;
      this.__isset.superColumnNames = (superColumnNames != null);
    }

    public void unsetSuperColumnNames() {
      this.superColumnNames = null;
      this.__isset.superColumnNames = false;
    }

    // Returns true if field superColumnNames is set (has been asigned a value) and false otherwise
    public boolean isSetSuperColumnNames() {
      return this.__isset.superColumnNames;
    }

    public void setSuperColumnNamesIsSet(boolean value) {
      this.__isset.superColumnNames = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLENAME:
        setTablename((String)value);
        break;

      case KEY:
        setKey((String)value);
        break;

      case COLUMNFAMILY:
        setColumnFamily((String)value);
        break;

      case SUPERCOLUMNNAMES:
        setSuperColumnNames((List<String>)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return getTablename();

      case KEY:
        return getKey();

      case COLUMNFAMILY:
        return getColumnFamily();

      case SUPERCOLUMNNAMES:
        return getSuperColumnNames();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return this.__isset.tablename;
      case KEY:
        return this.__isset.key;
      case COLUMNFAMILY:
        return this.__isset.columnFamily;
      case SUPERCOLUMNNAMES:
        return this.__isset.superColumnNames;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_slice_super_by_names_args)
        return this.equals((get_slice_super_by_names_args)that);
      return false;
    }

    public boolean equals(get_slice_super_by_names_args that) {
      if (that == null)
        return false;

      boolean this_present_tablename = true && (this.tablename != null);
      boolean that_present_tablename = true && (that.tablename != null);
      if (this_present_tablename || that_present_tablename) {
        if (!(this_present_tablename && that_present_tablename))
          return false;
        if (!this.tablename.equals(that.tablename))
          return false;
      }

      boolean this_present_key = true && (this.key != null);
      boolean that_present_key = true && (that.key != null);
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_columnFamily = true && (this.columnFamily != null);
      boolean that_present_columnFamily = true && (that.columnFamily != null);
      if (this_present_columnFamily || that_present_columnFamily) {
        if (!(this_present_columnFamily && that_present_columnFamily))
          return false;
        if (!this.columnFamily.equals(that.columnFamily))
          return false;
      }

      boolean this_present_superColumnNames = true && (this.superColumnNames != null);
      boolean that_present_superColumnNames = true && (that.superColumnNames != null);
      if (this_present_superColumnNames || that_present_superColumnNames) {
        if (!(this_present_superColumnNames && that_present_superColumnNames))
          return false;
        if (!this.superColumnNames.equals(that.superColumnNames))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLENAME:
            if (field.type == TType.STRING) {
              this.tablename = iprot.readString();
              this.__isset.tablename = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
              this.__isset.key = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMNFAMILY:
            if (field.type == TType.STRING) {
              this.columnFamily = iprot.readString();
              this.__isset.columnFamily = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case SUPERCOLUMNNAMES:
            if (field.type == TType.LIST) {
              {
                TList _list69 = iprot.readListBegin();
                this.superColumnNames = new ArrayList<String>(_list69.size);
                for (int _i70 = 0; _i70 < _list69.size; ++_i70)
                {
                  String _elem71;
                  _elem71 = iprot.readString();
                  this.superColumnNames.add(_elem71);
                }
                iprot.readListEnd();
              }
              this.__isset.superColumnNames = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tablename != null) {
        oprot.writeFieldBegin(TABLENAME_FIELD_DESC);
        oprot.writeString(this.tablename);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.columnFamily != null) {
        oprot.writeFieldBegin(COLUMN_FAMILY_FIELD_DESC);
        oprot.writeString(this.columnFamily);
        oprot.writeFieldEnd();
      }
      if (this.superColumnNames != null) {
        oprot.writeFieldBegin(SUPER_COLUMN_NAMES_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.superColumnNames.size()));
          for (String _iter72 : this.superColumnNames)          {
            oprot.writeString(_iter72);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_slice_super_by_names_args(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("tablename:");
      sb.append(this.tablename);
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      sb.append(this.key);
      first = false;
      if (!first) sb.append(", ");
      sb.append("columnFamily:");
      sb.append(this.columnFamily);
      first = false;
      if (!first) sb.append(", ");
      sb.append("superColumnNames:");
      sb.append(this.superColumnNames);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_slice_super_by_names_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_slice_super_by_names_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public List<superColumn_t> success;
    public static final int SUCCESS = 0;
    public CassandraException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
      public boolean e = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, superColumn_t.class))));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_slice_super_by_names_result.class, metaDataMap);
    }

    public get_slice_super_by_names_result() {
    }

    public get_slice_super_by_names_result(
      List<superColumn_t> success,
      CassandraException e)
    {
      this();
      this.success = success;
      this.__isset.success = (success != null);
      this.e = e;
      this.__isset.e = (e != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_slice_super_by_names_result(get_slice_super_by_names_result other) {
      __isset.success = other.__isset.success;
      if (other.success != null) {
        List<superColumn_t> __this__success = new ArrayList<superColumn_t>();
        for (superColumn_t other_element : other.success) {
          __this__success.add(new superColumn_t(other_element));
        }
        this.success = __this__success;
      }
      __isset.e = other.__isset.e;
      if (other.e != null) {
        this.e = new CassandraException(other.e);
      }
    }

    @Override
    public get_slice_super_by_names_result clone() {
      return new get_slice_super_by_names_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<superColumn_t> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(superColumn_t elem) {
      if (this.success == null) {
        this.success = new ArrayList<superColumn_t>();
      }
      this.success.add(elem);
      this.__isset.success = true;
    }

    public List<superColumn_t> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<superColumn_t> success) {
      this.success = success;
      this.__isset.success = (success != null);
    }

    public void unsetSuccess() {
      this.success = null;
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public CassandraException getE() {
      return this.e;
    }

    public void setE(CassandraException e) {
      this.e = e;
      this.__isset.e = (e != null);
    }

    public void unsetE() {
      this.e = null;
      this.__isset.e = false;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.__isset.e;
    }

    public void setEIsSet(boolean value) {
      this.__isset.e = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        setSuccess((List<superColumn_t>)value);
        break;

      case E:
        setE((CassandraException)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return this.__isset.success;
      case E:
        return this.__isset.e;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_slice_super_by_names_result)
        return this.equals((get_slice_super_by_names_result)that);
      return false;
    }

    public boolean equals(get_slice_super_by_names_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && (this.success != null);
      boolean that_present_success = true && (that.success != null);
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && (this.e != null);
      boolean that_present_e = true && (that.e != null);
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list73 = iprot.readListBegin();
                this.success = new ArrayList<superColumn_t>(_list73.size);
                for (int _i74 = 0; _i74 < _list73.size; ++_i74)
                {
                  superColumn_t _elem75;
                  _elem75 = new superColumn_t();
                  _elem75.read(iprot);
                  this.success.add(_elem75);
                }
                iprot.readListEnd();
              }
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new CassandraException();
              this.e.read(iprot);
              this.__isset.e = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.__isset.success) {
        if (this.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          {
            oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
            for (superColumn_t _iter76 : this.success)            {
              _iter76.write(oprot);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
      } else if (this.__isset.e) {
        if (this.e != null) {
          oprot.writeFieldBegin(E_FIELD_DESC);
          this.e.write(oprot);
          oprot.writeFieldEnd();
        }
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_slice_super_by_names_result(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      sb.append(this.e);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_superColumn_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_superColumn_args");
    private static final TField TABLENAME_FIELD_DESC = new TField("tablename", TType.STRING, (short)-1);
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)-2);
    private static final TField COLUMN_FAMILY_FIELD_DESC = new TField("columnFamily", TType.STRING, (short)-3);

    public String tablename;
    public static final int TABLENAME = -1;
    public String key;
    public static final int KEY = -2;
    public String columnFamily;
    public static final int COLUMNFAMILY = -3;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean tablename = false;
      public boolean key = false;
      public boolean columnFamily = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLENAME, new FieldMetaData("tablename", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(COLUMNFAMILY, new FieldMetaData("columnFamily", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_superColumn_args.class, metaDataMap);
    }

    public get_superColumn_args() {
    }

    public get_superColumn_args(
      String tablename,
      String key,
      String columnFamily)
    {
      this();
      this.tablename = tablename;
      this.__isset.tablename = (tablename != null);
      this.key = key;
      this.__isset.key = (key != null);
      this.columnFamily = columnFamily;
      this.__isset.columnFamily = (columnFamily != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_superColumn_args(get_superColumn_args other) {
      __isset.tablename = other.__isset.tablename;
      if (other.tablename != null) {
        this.tablename = other.tablename;
      }
      __isset.key = other.__isset.key;
      if (other.key != null) {
        this.key = other.key;
      }
      __isset.columnFamily = other.__isset.columnFamily;
      if (other.columnFamily != null) {
        this.columnFamily = other.columnFamily;
      }
    }

    @Override
    public get_superColumn_args clone() {
      return new get_superColumn_args(this);
    }

    public String getTablename() {
      return this.tablename;
    }

    public void setTablename(String tablename) {
      this.tablename = tablename;
      this.__isset.tablename = (tablename != null);
    }

    public void unsetTablename() {
      this.__isset.tablename = false;
    }

    // Returns true if field tablename is set (has been asigned a value) and false otherwise
    public boolean isSetTablename() {
      return this.__isset.tablename;
    }

    public void setTablenameIsSet(boolean value) {
      this.__isset.tablename = value;
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
      this.__isset.key = (key != null);
    }

    public void unsetKey() {
      this.__isset.key = false;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.__isset.key;
    }

    public void setKeyIsSet(boolean value) {
      this.__isset.key = value;
    }

    public String getColumnFamily() {
      return this.columnFamily;
    }

    public void setColumnFamily(String columnFamily) {
      this.columnFamily = columnFamily;
      this.__isset.columnFamily = (columnFamily != null);
    }

    public void unsetColumnFamily() {
      this.__isset.columnFamily = false;
    }

    // Returns true if field columnFamily is set (has been asigned a value) and false otherwise
    public boolean isSetColumnFamily() {
      return this.__isset.columnFamily;
    }

    public void setColumnFamilyIsSet(boolean value) {
      this.__isset.columnFamily = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLENAME:
        setTablename((String)value);
        break;

      case KEY:
        setKey((String)value);
        break;

      case COLUMNFAMILY:
        setColumnFamily((String)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return getTablename();

      case KEY:
        return getKey();

      case COLUMNFAMILY:
        return getColumnFamily();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return this.__isset.tablename;
      case KEY:
        return this.__isset.key;
      case COLUMNFAMILY:
        return this.__isset.columnFamily;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_superColumn_args)
        return this.equals((get_superColumn_args)that);
      return false;
    }

    public boolean equals(get_superColumn_args that) {
      if (that == null)
        return false;

      boolean this_present_tablename = true && (this.tablename != null);
      boolean that_present_tablename = true && (that.tablename != null);
      if (this_present_tablename || that_present_tablename) {
        if (!(this_present_tablename && that_present_tablename))
          return false;
        if (!this.tablename.equals(that.tablename))
          return false;
      }

      boolean this_present_key = true && (this.key != null);
      boolean that_present_key = true && (that.key != null);
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_columnFamily = true && (this.columnFamily != null);
      boolean that_present_columnFamily = true && (that.columnFamily != null);
      if (this_present_columnFamily || that_present_columnFamily) {
        if (!(this_present_columnFamily && that_present_columnFamily))
          return false;
        if (!this.columnFamily.equals(that.columnFamily))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLENAME:
            if (field.type == TType.STRING) {
              this.tablename = iprot.readString();
              this.__isset.tablename = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
              this.__isset.key = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case COLUMNFAMILY:
            if (field.type == TType.STRING) {
              this.columnFamily = iprot.readString();
              this.__isset.columnFamily = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tablename != null) {
        oprot.writeFieldBegin(TABLENAME_FIELD_DESC);
        oprot.writeString(this.tablename);
        oprot.writeFieldEnd();
      }
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      if (this.columnFamily != null) {
        oprot.writeFieldBegin(COLUMN_FAMILY_FIELD_DESC);
        oprot.writeString(this.columnFamily);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_superColumn_args(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("tablename:");
      sb.append(this.tablename);
      first = false;
      if (!first) sb.append(", ");
      sb.append("key:");
      sb.append(this.key);
      first = false;
      if (!first) sb.append(", ");
      sb.append("columnFamily:");
      sb.append(this.columnFamily);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class get_superColumn_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_superColumn_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public superColumn_t success;
    public static final int SUCCESS = 0;
    public CassandraException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
      public boolean e = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, superColumn_t.class)));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_superColumn_result.class, metaDataMap);
    }

    public get_superColumn_result() {
    }

    public get_superColumn_result(
      superColumn_t success,
      CassandraException e)
    {
      this();
      this.success = success;
      this.__isset.success = (success != null);
      this.e = e;
      this.__isset.e = (e != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_superColumn_result(get_superColumn_result other) {
      __isset.success = other.__isset.success;
      if (other.success != null) {
        this.success = new superColumn_t(other.success);
      }
      __isset.e = other.__isset.e;
      if (other.e != null) {
        this.e = new CassandraException(other.e);
      }
    }

    @Override
    public get_superColumn_result clone() {
      return new get_superColumn_result(this);
    }

    public superColumn_t getSuccess() {
      return this.success;
    }

    public void setSuccess(superColumn_t success) {
      this.success = success;
      this.__isset.success = (success != null);
    }

    public void unsetSuccess() {
      this.success = null;
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public CassandraException getE() {
      return this.e;
    }

    public void setE(CassandraException e) {
      this.e = e;
      this.__isset.e = (e != null);
    }

    public void unsetE() {
      this.e = null;
      this.__isset.e = false;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.__isset.e;
    }

    public void setEIsSet(boolean value) {
      this.__isset.e = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        setSuccess((superColumn_t)value);
        break;

      case E:
        setE((CassandraException)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return this.__isset.success;
      case E:
        return this.__isset.e;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_superColumn_result)
        return this.equals((get_superColumn_result)that);
      return false;
    }

    public boolean equals(get_superColumn_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && (this.success != null);
      boolean that_present_success = true && (that.success != null);
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_e = true && (this.e != null);
      boolean that_present_e = true && (that.e != null);
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new superColumn_t();
              this.success.read(iprot);
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new CassandraException();
              this.e.read(iprot);
              this.__isset.e = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.__isset.success) {
        if (this.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          this.success.write(oprot);
          oprot.writeFieldEnd();
        }
      } else if (this.__isset.e) {
        if (this.e != null) {
          oprot.writeFieldBegin(E_FIELD_DESC);
          this.e.write(oprot);
          oprot.writeFieldEnd();
        }
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_superColumn_result(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      sb.append(this.e);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class batch_insert_superColumn_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("batch_insert_superColumn_args");
    private static final TField BATCH_MUTATION_SUPER_FIELD_DESC = new TField("batchMutationSuper", TType.STRUCT, (short)-1);

    public batch_mutation_super_t batchMutationSuper;
    public static final int BATCHMUTATIONSUPER = -1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean batchMutationSuper = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(BATCHMUTATIONSUPER, new FieldMetaData("batchMutationSuper", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, batch_mutation_super_t.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(batch_insert_superColumn_args.class, metaDataMap);
    }

    public batch_insert_superColumn_args() {
    }

    public batch_insert_superColumn_args(
      batch_mutation_super_t batchMutationSuper)
    {
      this();
      this.batchMutationSuper = batchMutationSuper;
      this.__isset.batchMutationSuper = (batchMutationSuper != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public batch_insert_superColumn_args(batch_insert_superColumn_args other) {
      __isset.batchMutationSuper = other.__isset.batchMutationSuper;
      if (other.batchMutationSuper != null) {
        this.batchMutationSuper = new batch_mutation_super_t(other.batchMutationSuper);
      }
    }

    @Override
    public batch_insert_superColumn_args clone() {
      return new batch_insert_superColumn_args(this);
    }

    public batch_mutation_super_t getBatchMutationSuper() {
      return this.batchMutationSuper;
    }

    public void setBatchMutationSuper(batch_mutation_super_t batchMutationSuper) {
      this.batchMutationSuper = batchMutationSuper;
      this.__isset.batchMutationSuper = (batchMutationSuper != null);
    }

    public void unsetBatchMutationSuper() {
      this.batchMutationSuper = null;
      this.__isset.batchMutationSuper = false;
    }

    // Returns true if field batchMutationSuper is set (has been asigned a value) and false otherwise
    public boolean isSetBatchMutationSuper() {
      return this.__isset.batchMutationSuper;
    }

    public void setBatchMutationSuperIsSet(boolean value) {
      this.__isset.batchMutationSuper = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case BATCHMUTATIONSUPER:
        setBatchMutationSuper((batch_mutation_super_t)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case BATCHMUTATIONSUPER:
        return getBatchMutationSuper();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case BATCHMUTATIONSUPER:
        return this.__isset.batchMutationSuper;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof batch_insert_superColumn_args)
        return this.equals((batch_insert_superColumn_args)that);
      return false;
    }

    public boolean equals(batch_insert_superColumn_args that) {
      if (that == null)
        return false;

      boolean this_present_batchMutationSuper = true && (this.batchMutationSuper != null);
      boolean that_present_batchMutationSuper = true && (that.batchMutationSuper != null);
      if (this_present_batchMutationSuper || that_present_batchMutationSuper) {
        if (!(this_present_batchMutationSuper && that_present_batchMutationSuper))
          return false;
        if (!this.batchMutationSuper.equals(that.batchMutationSuper))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case BATCHMUTATIONSUPER:
            if (field.type == TType.STRUCT) {
              this.batchMutationSuper = new batch_mutation_super_t();
              this.batchMutationSuper.read(iprot);
              this.__isset.batchMutationSuper = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.batchMutationSuper != null) {
        oprot.writeFieldBegin(BATCH_MUTATION_SUPER_FIELD_DESC);
        this.batchMutationSuper.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("batch_insert_superColumn_args(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("batchMutationSuper:");
      sb.append(this.batchMutationSuper);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class batch_insert_superColumn_blocking_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("batch_insert_superColumn_blocking_args");
    private static final TField BATCH_MUTATION_SUPER_FIELD_DESC = new TField("batchMutationSuper", TType.STRUCT, (short)-1);

    public batch_mutation_super_t batchMutationSuper;
    public static final int BATCHMUTATIONSUPER = -1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean batchMutationSuper = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(BATCHMUTATIONSUPER, new FieldMetaData("batchMutationSuper", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, batch_mutation_super_t.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(batch_insert_superColumn_blocking_args.class, metaDataMap);
    }

    public batch_insert_superColumn_blocking_args() {
    }

    public batch_insert_superColumn_blocking_args(
      batch_mutation_super_t batchMutationSuper)
    {
      this();
      this.batchMutationSuper = batchMutationSuper;
      this.__isset.batchMutationSuper = (batchMutationSuper != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public batch_insert_superColumn_blocking_args(batch_insert_superColumn_blocking_args other) {
      __isset.batchMutationSuper = other.__isset.batchMutationSuper;
      if (other.batchMutationSuper != null) {
        this.batchMutationSuper = new batch_mutation_super_t(other.batchMutationSuper);
      }
    }

    @Override
    public batch_insert_superColumn_blocking_args clone() {
      return new batch_insert_superColumn_blocking_args(this);
    }

    public batch_mutation_super_t getBatchMutationSuper() {
      return this.batchMutationSuper;
    }

    public void setBatchMutationSuper(batch_mutation_super_t batchMutationSuper) {
      this.batchMutationSuper = batchMutationSuper;
      this.__isset.batchMutationSuper = (batchMutationSuper != null);
    }

    public void unsetBatchMutationSuper() {
      this.batchMutationSuper = null;
      this.__isset.batchMutationSuper = false;
    }

    // Returns true if field batchMutationSuper is set (has been asigned a value) and false otherwise
    public boolean isSetBatchMutationSuper() {
      return this.__isset.batchMutationSuper;
    }

    public void setBatchMutationSuperIsSet(boolean value) {
      this.__isset.batchMutationSuper = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case BATCHMUTATIONSUPER:
        setBatchMutationSuper((batch_mutation_super_t)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case BATCHMUTATIONSUPER:
        return getBatchMutationSuper();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case BATCHMUTATIONSUPER:
        return this.__isset.batchMutationSuper;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof batch_insert_superColumn_blocking_args)
        return this.equals((batch_insert_superColumn_blocking_args)that);
      return false;
    }

    public boolean equals(batch_insert_superColumn_blocking_args that) {
      if (that == null)
        return false;

      boolean this_present_batchMutationSuper = true && (this.batchMutationSuper != null);
      boolean that_present_batchMutationSuper = true && (that.batchMutationSuper != null);
      if (this_present_batchMutationSuper || that_present_batchMutationSuper) {
        if (!(this_present_batchMutationSuper && that_present_batchMutationSuper))
          return false;
        if (!this.batchMutationSuper.equals(that.batchMutationSuper))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case BATCHMUTATIONSUPER:
            if (field.type == TType.STRUCT) {
              this.batchMutationSuper = new batch_mutation_super_t();
              this.batchMutationSuper.read(iprot);
              this.__isset.batchMutationSuper = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.batchMutationSuper != null) {
        oprot.writeFieldBegin(BATCH_MUTATION_SUPER_FIELD_DESC);
        this.batchMutationSuper.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("batch_insert_superColumn_blocking_args(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("batchMutationSuper:");
      sb.append(this.batchMutationSuper);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class batch_insert_superColumn_blocking_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("batch_insert_superColumn_blocking_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.BOOL, (short)0);
    private static final TField E_FIELD_DESC = new TField("e", TType.STRUCT, (short)1);

    public boolean success;
    public static final int SUCCESS = 0;
    public CassandraException e;
    public static final int E = 1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
      public boolean e = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
      put(E, new FieldMetaData("e", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(batch_insert_superColumn_blocking_result.class, metaDataMap);
    }

    public batch_insert_superColumn_blocking_result() {
    }

    public batch_insert_superColumn_blocking_result(
      boolean success,
      CassandraException e)
    {
      this();
      this.success = success;
      this.__isset.success = true;
      this.e = e;
      this.__isset.e = (e != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public batch_insert_superColumn_blocking_result(batch_insert_superColumn_blocking_result other) {
      __isset.success = other.__isset.success;
      this.success = other.success;
      __isset.e = other.__isset.e;
      if (other.e != null) {
        this.e = new CassandraException(other.e);
      }
    }

    @Override
    public batch_insert_superColumn_blocking_result clone() {
      return new batch_insert_superColumn_blocking_result(this);
    }

    public boolean isSuccess() {
      return this.success;
    }

    public void setSuccess(boolean success) {
      this.success = success;
      this.__isset.success = true;
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public CassandraException getE() {
      return this.e;
    }

    public void setE(CassandraException e) {
      this.e = e;
      this.__isset.e = (e != null);
    }

    public void unsetE() {
      this.e = null;
      this.__isset.e = false;
    }

    // Returns true if field e is set (has been asigned a value) and false otherwise
    public boolean isSetE() {
      return this.__isset.e;
    }

    public void setEIsSet(boolean value) {
      this.__isset.e = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        setSuccess((Boolean)value);
        break;

      case E:
        setE((CassandraException)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return new Boolean(isSuccess());

      case E:
        return getE();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return this.__isset.success;
      case E:
        return this.__isset.e;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof batch_insert_superColumn_blocking_result)
        return this.equals((batch_insert_superColumn_blocking_result)that);
      return false;
    }

    public boolean equals(batch_insert_superColumn_blocking_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_e = true && (this.e != null);
      boolean that_present_e = true && (that.e != null);
      if (this_present_e || that_present_e) {
        if (!(this_present_e && that_present_e))
          return false;
        if (!this.e.equals(that.e))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.BOOL) {
              this.success = iprot.readBool();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case E:
            if (field.type == TType.STRUCT) {
              this.e = new CassandraException();
              this.e.read(iprot);
              this.__isset.e = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.__isset.success) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeBool(this.success);
        oprot.writeFieldEnd();
      } else if (this.__isset.e) {
        if (this.e != null) {
          oprot.writeFieldBegin(E_FIELD_DESC);
          this.e.write(oprot);
          oprot.writeFieldEnd();
        }
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("batch_insert_superColumn_blocking_result(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("e:");
      sb.append(this.e);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class touch_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("touch_args");
    private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)-1);
    private static final TField F_DATA_FIELD_DESC = new TField("fData", TType.BOOL, (short)-2);

    public String key;
    public static final int KEY = -1;
    public boolean fData;
    public static final int FDATA = -2;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean key = false;
      public boolean fData = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      put(FDATA, new FieldMetaData("fData", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.BOOL)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(touch_args.class, metaDataMap);
    }

    public touch_args() {
    }

    public touch_args(
      String key,
      boolean fData)
    {
      this();
      this.key = key;
      this.__isset.key = (key != null);
      this.fData = fData;
      this.__isset.fData = true;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public touch_args(touch_args other) {
      __isset.key = other.__isset.key;
      if (other.key != null) {
        this.key = other.key;
      }
      __isset.fData = other.__isset.fData;
      this.fData = other.fData;
    }

    @Override
    public touch_args clone() {
      return new touch_args(this);
    }

    public String getKey() {
      return this.key;
    }

    public void setKey(String key) {
      this.key = key;
      this.__isset.key = (key != null);
    }

    public void unsetKey() {
      this.__isset.key = false;
    }

    // Returns true if field key is set (has been asigned a value) and false otherwise
    public boolean isSetKey() {
      return this.__isset.key;
    }

    public void setKeyIsSet(boolean value) {
      this.__isset.key = value;
    }

    public boolean isFData() {
      return this.fData;
    }

    public void setFData(boolean fData) {
      this.fData = fData;
      this.__isset.fData = true;
    }

    public void unsetFData() {
      this.__isset.fData = false;
    }

    // Returns true if field fData is set (has been asigned a value) and false otherwise
    public boolean isSetFData() {
      return this.__isset.fData;
    }

    public void setFDataIsSet(boolean value) {
      this.__isset.fData = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case KEY:
        setKey((String)value);
        break;

      case FDATA:
        setFData((Boolean)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case KEY:
        return getKey();

      case FDATA:
        return new Boolean(isFData());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case KEY:
        return this.__isset.key;
      case FDATA:
        return this.__isset.fData;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof touch_args)
        return this.equals((touch_args)that);
      return false;
    }

    public boolean equals(touch_args that) {
      if (that == null)
        return false;

      boolean this_present_key = true && (this.key != null);
      boolean that_present_key = true && (that.key != null);
      if (this_present_key || that_present_key) {
        if (!(this_present_key && that_present_key))
          return false;
        if (!this.key.equals(that.key))
          return false;
      }

      boolean this_present_fData = true;
      boolean that_present_fData = true;
      if (this_present_fData || that_present_fData) {
        if (!(this_present_fData && that_present_fData))
          return false;
        if (this.fData != that.fData)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case KEY:
            if (field.type == TType.STRING) {
              this.key = iprot.readString();
              this.__isset.key = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case FDATA:
            if (field.type == TType.BOOL) {
              this.fData = iprot.readBool();
              this.__isset.fData = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.key != null) {
        oprot.writeFieldBegin(KEY_FIELD_DESC);
        oprot.writeString(this.key);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(F_DATA_FIELD_DESC);
      oprot.writeBool(this.fData);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("touch_args(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("key:");
      sb.append(this.key);
      first = false;
      if (!first) sb.append(", ");
      sb.append("fData:");
      sb.append(this.fData);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getStringProperty_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getStringProperty_args");
    private static final TField PROPERTY_NAME_FIELD_DESC = new TField("propertyName", TType.STRING, (short)-1);

    public String propertyName;
    public static final int PROPERTYNAME = -1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean propertyName = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PROPERTYNAME, new FieldMetaData("propertyName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getStringProperty_args.class, metaDataMap);
    }

    public getStringProperty_args() {
    }

    public getStringProperty_args(
      String propertyName)
    {
      this();
      this.propertyName = propertyName;
      this.__isset.propertyName = (propertyName != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getStringProperty_args(getStringProperty_args other) {
      __isset.propertyName = other.__isset.propertyName;
      if (other.propertyName != null) {
        this.propertyName = other.propertyName;
      }
    }

    @Override
    public getStringProperty_args clone() {
      return new getStringProperty_args(this);
    }

    public String getPropertyName() {
      return this.propertyName;
    }

    public void setPropertyName(String propertyName) {
      this.propertyName = propertyName;
      this.__isset.propertyName = (propertyName != null);
    }

    public void unsetPropertyName() {
      this.__isset.propertyName = false;
    }

    // Returns true if field propertyName is set (has been asigned a value) and false otherwise
    public boolean isSetPropertyName() {
      return this.__isset.propertyName;
    }

    public void setPropertyNameIsSet(boolean value) {
      this.__isset.propertyName = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PROPERTYNAME:
        setPropertyName((String)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PROPERTYNAME:
        return getPropertyName();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PROPERTYNAME:
        return this.__isset.propertyName;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getStringProperty_args)
        return this.equals((getStringProperty_args)that);
      return false;
    }

    public boolean equals(getStringProperty_args that) {
      if (that == null)
        return false;

      boolean this_present_propertyName = true && (this.propertyName != null);
      boolean that_present_propertyName = true && (that.propertyName != null);
      if (this_present_propertyName || that_present_propertyName) {
        if (!(this_present_propertyName && that_present_propertyName))
          return false;
        if (!this.propertyName.equals(that.propertyName))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PROPERTYNAME:
            if (field.type == TType.STRING) {
              this.propertyName = iprot.readString();
              this.__isset.propertyName = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.propertyName != null) {
        oprot.writeFieldBegin(PROPERTY_NAME_FIELD_DESC);
        oprot.writeString(this.propertyName);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getStringProperty_args(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("propertyName:");
      sb.append(this.propertyName);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getStringProperty_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getStringProperty_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);

    public String success;
    public static final int SUCCESS = 0;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getStringProperty_result.class, metaDataMap);
    }

    public getStringProperty_result() {
    }

    public getStringProperty_result(
      String success)
    {
      this();
      this.success = success;
      this.__isset.success = (success != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getStringProperty_result(getStringProperty_result other) {
      __isset.success = other.__isset.success;
      if (other.success != null) {
        this.success = other.success;
      }
    }

    @Override
    public getStringProperty_result clone() {
      return new getStringProperty_result(this);
    }

    public String getSuccess() {
      return this.success;
    }

    public void setSuccess(String success) {
      this.success = success;
      this.__isset.success = (success != null);
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        setSuccess((String)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return this.__isset.success;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getStringProperty_result)
        return this.equals((getStringProperty_result)that);
      return false;
    }

    public boolean equals(getStringProperty_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && (this.success != null);
      boolean that_present_success = true && (that.success != null);
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRING) {
              this.success = iprot.readString();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.__isset.success) {
        if (this.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          oprot.writeString(this.success);
          oprot.writeFieldEnd();
        }
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getStringProperty_result(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("success:");
      sb.append(this.success);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getStringListProperty_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getStringListProperty_args");
    private static final TField PROPERTY_NAME_FIELD_DESC = new TField("propertyName", TType.STRING, (short)-1);

    public String propertyName;
    public static final int PROPERTYNAME = -1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean propertyName = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PROPERTYNAME, new FieldMetaData("propertyName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getStringListProperty_args.class, metaDataMap);
    }

    public getStringListProperty_args() {
    }

    public getStringListProperty_args(
      String propertyName)
    {
      this();
      this.propertyName = propertyName;
      this.__isset.propertyName = (propertyName != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getStringListProperty_args(getStringListProperty_args other) {
      __isset.propertyName = other.__isset.propertyName;
      if (other.propertyName != null) {
        this.propertyName = other.propertyName;
      }
    }

    @Override
    public getStringListProperty_args clone() {
      return new getStringListProperty_args(this);
    }

    public String getPropertyName() {
      return this.propertyName;
    }

    public void setPropertyName(String propertyName) {
      this.propertyName = propertyName;
      this.__isset.propertyName = (propertyName != null);
    }

    public void unsetPropertyName() {
      this.__isset.propertyName = false;
    }

    // Returns true if field propertyName is set (has been asigned a value) and false otherwise
    public boolean isSetPropertyName() {
      return this.__isset.propertyName;
    }

    public void setPropertyNameIsSet(boolean value) {
      this.__isset.propertyName = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PROPERTYNAME:
        setPropertyName((String)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PROPERTYNAME:
        return getPropertyName();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PROPERTYNAME:
        return this.__isset.propertyName;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getStringListProperty_args)
        return this.equals((getStringListProperty_args)that);
      return false;
    }

    public boolean equals(getStringListProperty_args that) {
      if (that == null)
        return false;

      boolean this_present_propertyName = true && (this.propertyName != null);
      boolean that_present_propertyName = true && (that.propertyName != null);
      if (this_present_propertyName || that_present_propertyName) {
        if (!(this_present_propertyName && that_present_propertyName))
          return false;
        if (!this.propertyName.equals(that.propertyName))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PROPERTYNAME:
            if (field.type == TType.STRING) {
              this.propertyName = iprot.readString();
              this.__isset.propertyName = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.propertyName != null) {
        oprot.writeFieldBegin(PROPERTY_NAME_FIELD_DESC);
        oprot.writeString(this.propertyName);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getStringListProperty_args(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("propertyName:");
      sb.append(this.propertyName);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getStringListProperty_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getStringListProperty_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);

    public List<String> success;
    public static final int SUCCESS = 0;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getStringListProperty_result.class, metaDataMap);
    }

    public getStringListProperty_result() {
    }

    public getStringListProperty_result(
      List<String> success)
    {
      this();
      this.success = success;
      this.__isset.success = (success != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getStringListProperty_result(getStringListProperty_result other) {
      __isset.success = other.__isset.success;
      if (other.success != null) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
    }

    @Override
    public getStringListProperty_result clone() {
      return new getStringListProperty_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
      this.__isset.success = true;
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public void setSuccess(List<String> success) {
      this.success = success;
      this.__isset.success = (success != null);
    }

    public void unsetSuccess() {
      this.success = null;
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        setSuccess((List<String>)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return this.__isset.success;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getStringListProperty_result)
        return this.equals((getStringListProperty_result)that);
      return false;
    }

    public boolean equals(getStringListProperty_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && (this.success != null);
      boolean that_present_success = true && (that.success != null);
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list77 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list77.size);
                for (int _i78 = 0; _i78 < _list77.size; ++_i78)
                {
                  String _elem79;
                  _elem79 = iprot.readString();
                  this.success.add(_elem79);
                }
                iprot.readListEnd();
              }
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.__isset.success) {
        if (this.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          {
            oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
            for (String _iter80 : this.success)            {
              oprot.writeString(_iter80);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getStringListProperty_result(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("success:");
      sb.append(this.success);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class describeTable_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("describeTable_args");
    private static final TField TABLE_NAME_FIELD_DESC = new TField("tableName", TType.STRING, (short)-1);

    public String tableName;
    public static final int TABLENAME = -1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean tableName = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(TABLENAME, new FieldMetaData("tableName", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(describeTable_args.class, metaDataMap);
    }

    public describeTable_args() {
    }

    public describeTable_args(
      String tableName)
    {
      this();
      this.tableName = tableName;
      this.__isset.tableName = (tableName != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public describeTable_args(describeTable_args other) {
      __isset.tableName = other.__isset.tableName;
      if (other.tableName != null) {
        this.tableName = other.tableName;
      }
    }

    @Override
    public describeTable_args clone() {
      return new describeTable_args(this);
    }

    public String getTableName() {
      return this.tableName;
    }

    public void setTableName(String tableName) {
      this.tableName = tableName;
      this.__isset.tableName = (tableName != null);
    }

    public void unsetTableName() {
      this.__isset.tableName = false;
    }

    // Returns true if field tableName is set (has been asigned a value) and false otherwise
    public boolean isSetTableName() {
      return this.__isset.tableName;
    }

    public void setTableNameIsSet(boolean value) {
      this.__isset.tableName = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case TABLENAME:
        setTableName((String)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return getTableName();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case TABLENAME:
        return this.__isset.tableName;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof describeTable_args)
        return this.equals((describeTable_args)that);
      return false;
    }

    public boolean equals(describeTable_args that) {
      if (that == null)
        return false;

      boolean this_present_tableName = true && (this.tableName != null);
      boolean that_present_tableName = true && (that.tableName != null);
      if (this_present_tableName || that_present_tableName) {
        if (!(this_present_tableName && that_present_tableName))
          return false;
        if (!this.tableName.equals(that.tableName))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case TABLENAME:
            if (field.type == TType.STRING) {
              this.tableName = iprot.readString();
              this.__isset.tableName = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.tableName != null) {
        oprot.writeFieldBegin(TABLE_NAME_FIELD_DESC);
        oprot.writeString(this.tableName);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("describeTable_args(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("tableName:");
      sb.append(this.tableName);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class describeTable_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("describeTable_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);

    public String success;
    public static final int SUCCESS = 0;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(describeTable_result.class, metaDataMap);
    }

    public describeTable_result() {
    }

    public describeTable_result(
      String success)
    {
      this();
      this.success = success;
      this.__isset.success = (success != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public describeTable_result(describeTable_result other) {
      __isset.success = other.__isset.success;
      if (other.success != null) {
        this.success = other.success;
      }
    }

    @Override
    public describeTable_result clone() {
      return new describeTable_result(this);
    }

    public String getSuccess() {
      return this.success;
    }

    public void setSuccess(String success) {
      this.success = success;
      this.__isset.success = (success != null);
    }

    public void unsetSuccess() {
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        setSuccess((String)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return this.__isset.success;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof describeTable_result)
        return this.equals((describeTable_result)that);
      return false;
    }

    public boolean equals(describeTable_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && (this.success != null);
      boolean that_present_success = true && (that.success != null);
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRING) {
              this.success = iprot.readString();
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.__isset.success) {
        if (this.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          oprot.writeString(this.success);
          oprot.writeFieldEnd();
        }
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("describeTable_result(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("success:");
      sb.append(this.success);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class executeQuery_args implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("executeQuery_args");
    private static final TField QUERY_FIELD_DESC = new TField("query", TType.STRING, (short)-1);

    public String query;
    public static final int QUERY = -1;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean query = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(QUERY, new FieldMetaData("query", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(executeQuery_args.class, metaDataMap);
    }

    public executeQuery_args() {
    }

    public executeQuery_args(
      String query)
    {
      this();
      this.query = query;
      this.__isset.query = (query != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public executeQuery_args(executeQuery_args other) {
      __isset.query = other.__isset.query;
      if (other.query != null) {
        this.query = other.query;
      }
    }

    @Override
    public executeQuery_args clone() {
      return new executeQuery_args(this);
    }

    public String getQuery() {
      return this.query;
    }

    public void setQuery(String query) {
      this.query = query;
      this.__isset.query = (query != null);
    }

    public void unsetQuery() {
      this.__isset.query = false;
    }

    // Returns true if field query is set (has been asigned a value) and false otherwise
    public boolean isSetQuery() {
      return this.__isset.query;
    }

    public void setQueryIsSet(boolean value) {
      this.__isset.query = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case QUERY:
        setQuery((String)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case QUERY:
        return getQuery();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case QUERY:
        return this.__isset.query;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof executeQuery_args)
        return this.equals((executeQuery_args)that);
      return false;
    }

    public boolean equals(executeQuery_args that) {
      if (that == null)
        return false;

      boolean this_present_query = true && (this.query != null);
      boolean that_present_query = true && (that.query != null);
      if (this_present_query || that_present_query) {
        if (!(this_present_query && that_present_query))
          return false;
        if (!this.query.equals(that.query))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case QUERY:
            if (field.type == TType.STRING) {
              this.query = iprot.readString();
              this.__isset.query = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.query != null) {
        oprot.writeFieldBegin(QUERY_FIELD_DESC);
        oprot.writeString(this.query);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("executeQuery_args(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("query:");
      sb.append(this.query);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class executeQuery_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("executeQuery_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public CqlResult_t success;
    public static final int SUCCESS = 0;

    private final Isset __isset = new Isset();
    private static final class Isset implements java.io.Serializable {
      public boolean success = false;
    }

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, CqlResult_t.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(executeQuery_result.class, metaDataMap);
    }

    public executeQuery_result() {
    }

    public executeQuery_result(
      CqlResult_t success)
    {
      this();
      this.success = success;
      this.__isset.success = (success != null);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public executeQuery_result(executeQuery_result other) {
      __isset.success = other.__isset.success;
      if (other.success != null) {
        this.success = new CqlResult_t(other.success);
      }
    }

    @Override
    public executeQuery_result clone() {
      return new executeQuery_result(this);
    }

    public CqlResult_t getSuccess() {
      return this.success;
    }

    public void setSuccess(CqlResult_t success) {
      this.success = success;
      this.__isset.success = (success != null);
    }

    public void unsetSuccess() {
      this.success = null;
      this.__isset.success = false;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.__isset.success;
    }

    public void setSuccessIsSet(boolean value) {
      this.__isset.success = value;
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        setSuccess((CqlResult_t)value);
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return this.__isset.success;
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof executeQuery_result)
        return this.equals((executeQuery_result)that);
      return false;
    }

    public boolean equals(executeQuery_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && (this.success != null);
      boolean that_present_success = true && (that.success != null);
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new CqlResult_t();
              this.success.read(iprot);
              this.__isset.success = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.__isset.success) {
        if (this.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
          this.success.write(oprot);
          oprot.writeFieldEnd();
        }
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("executeQuery_result(");
      boolean first = true;

      if (!first) sb.append(", ");
      sb.append("success:");
      sb.append(this.success);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

}

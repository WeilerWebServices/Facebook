/**
* Facebook Internet Explorer Toolbar Software License 
* Copyright (c) 2009 Facebook, Inc. 
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (which, together with any graphical images included with such
* software, are collectively referred to below as the "Software") to (a) use,
* reproduce, display, distribute, execute, and transmit the Software, (b)
* prepare derivative works of the Software (excluding any graphical images
* included with the Software, which may not be modified or altered), and (c)
* permit third-parties to whom the Software is furnished to do so, all
* subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.  
*
* Facebook, Inc. retains ownership of the Software and all associated
* intellectual property rights.  All rights not expressly granted in this
* license are reserved by Facebook, Inc.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/

#include "Stdafx.h"

#include <Msi.h>
#include <Msiquery.h>
#include <sstream>

#include "Resource.h"

#include "CommonConstants.h"
#include "MsiUtils.h"

namespace facebook {

/**
 * Create file name for transform file
 * @param localeId locale Id for language transform
 * @return transform file name
 */
String createFileName(int localeId) {
  // Create transform file name
  std::wstringstream result;
  result << localeId << kTransformExtension;

  return result.str();
}

/**
 * Returns path to temp folder
 * @return path to temp folder
 */
String getTmpPath() {
  String result = kEmptyString;
  // _MAX_PATH - Max length of the full path
  Char tempPath[_MAX_PATH];
  int returnCode = GetTempPath(_MAX_PATH, tempPath);
  if (returnCode > 0) {
    result = tempPath;
  }
  
  return result;
}

/**
 * Copy file from resources to the target path
 * @param resource id of the file
 * @param target file path with file name
 */
void copyFile(int resId, String filePath) {
  // Load file from resource
  HRSRC resourceHandle = FindResource(NULL, MAKEINTRESOURCE(resId), RT_RCDATA);
  if (resourceHandle == NULL) {
    ::MessageBox(0, kErrorMsiIdentification.c_str(),
      kErrorBoxTitle.c_str(), MB_OK | MB_ICONERROR);
    return;
  }
  HGLOBAL data = LoadResource(NULL, resourceHandle);
  LPVOID resource = LockResource(data);
  DWORD resourceSize = SizeofResource(NULL, resourceHandle);
  // Create and copy to the filePath folder from loaded resource
  HANDLE fileHandle = CreateFile(filePath.c_str(),
    GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
  
  DWORD bytesWritten;
  BOOL writeResult = WriteFile(fileHandle, resource, resourceSize, &bytesWritten, NULL);
  if (!writeResult) {
    ::MessageBox(0, kErrorFileCopy.c_str(),
      kErrorBoxTitle.c_str(), MB_OK | MB_ICONERROR);
    return;
  }

  FreeResource(data);
  CloseHandle(fileHandle); 
}

void prepareMsiData(int localeId) {
  String msiFilePath = getTmpPath() + kMsiFileName;
  // Copy msi file to temp
  copyFile(IDR_MSI, msiFilePath);
  
  // Don't need transform for English (United States)
  if (localeId != kEnglishLocalId) {
    String transformFile = createFileName(localeId);
    String transformFilePath = getTmpPath() + transformFile;
    // Copy mst file to temp if needed
    copyFile(localeId, transformFilePath);
  }
}

void runMsi(int localeId) {
  String msiFilePath = getTmpPath() + kMsiFileName;

  // Crete parameter string for msiexec
  std::wstringstream parameter;
  parameter << "/i \"" << msiFilePath << "\""
            << " LanguageChoice=\"" << localeIdToShortLocale(localeId) << "\"";
  // Don't need transform for English (United States)
  if (localeId != kEnglishLocalId) {
    String transformFile = createFileName(localeId);
    String transformFilePath = getTmpPath() + transformFile;
    parameter  << " transforms=\"" << transformFilePath  << "\"";
  }

  // Execute msiexec with the parameter from above
  ShellExecute(NULL, _T("open"), _T("msiexec.exe"),
    parameter.str().c_str(), NULL, SW_SHOWNORMAL);
}

String getMsiProductCode() {
  String productGuid = kEmptyString;

  // Copy msi file from resources to the temp folder
  prepareMsiData(kEnglishLocalId);
  MSIHANDLE msiHandle;
  String path = getTmpPath() + kMsiFileName;
  // Open msi file
  UINT result = MsiOpenPackageEx(path.c_str(),
    MSIOPENPACKAGEFLAGS_IGNOREMACHINESTATE, &msiHandle);
  if (result != ERROR_SUCCESS) {
    return productGuid;
  }

  // Get Product code property string length
  DWORD length = 0;
  result = MsiGetProperty(msiHandle, _T("ProductCode"), _T(""), &length);
  if (ERROR_MORE_DATA != result) {
    return productGuid;
  }
  // Get Product code property
  // increment length for termination character
  Char* productCode = new Char[++length];
  MsiGetProperty(msiHandle, _T("ProductCode"), productCode, &length);
  productGuid = productCode;
  delete[] productCode;

  // Delete msi file from temp folder, close handles
  MsiCloseHandle(msiHandle);
  DeleteFile(path.c_str());

  return productGuid;
}

bool isProductInstalled(String productCode) {
  bool result = false;

  if (productCode == kEmptyString) {
    return result;
  }

  HKEY key = NULL;
  String uninstallRegPath = kUninstallPath + _T("\\") + productCode;
  // Determine if reg key exist
  HRESULT isExist = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
    uninstallRegPath.c_str(), 0, KEY_READ, &key);

  if (isExist == ERROR_SUCCESS) {
    result = true;
    ::RegCloseKey(key);
  }

  return result;
}

} // !namespace facebook
/**
* Facebook Internet Explorer Toolbar Software License 
* Copyright (c) 2009 Facebook, Inc. 
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (which, together with any graphical images included with such
* software, are collectively referred to below as the "Software") to (a) use,
* reproduce, display, distribute, execute, and transmit the Software, (b)
* prepare derivative works of the Software (excluding any graphical images
* included with the Software, which may not be modified or altered), and (c)
* permit third-parties to whom the Software is furnished to do so, all
* subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.  
*
* Facebook, Inc. retains ownership of the Software and all associated
* intellectual property rights.  All rights not expressly granted in this
* license are reserved by Facebook, Inc.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/ 


#ifndef PROTOCOLIMPL_H
#define PROTOCOLIMPL_H

#include <urlmon.h>
#include "BaseObject.h"

namespace facebook {

namespace Detail {

/**
 * struct InterfaceHelperData
 *
 * Helper structure to bind interfaces together
 */
struct InterfaceHelperData{
  DWORD_PTR offsetItf;
  DWORD_PTR offsetUnk;
  const IID* iidBase;
};

template <class itf, class impl, DWORD_PTR offsetUnk, const IID* iidBase>
struct InterfaceHelper{
  static InterfaceHelperData data;
};

template <class itf, class impl, DWORD_PTR offsetUnk, const IID* iidBase>
InterfaceHelperData
  InterfaceHelper<itf, impl, offsetUnk, iidBase>::
      data = {offsetofclass(itf, impl), offsetUnk, iidBase};

#define COM_INTERFACE_ENTRY_HELPER(itf, punk)\
  {&_ATL_IIDOF(itf),\
  (DWORD_PTR)&::facebook::Detail::InterfaceHelper<\
    itf, _ComMapClass,\
    (DWORD_PTR)offsetof(_ComMapClass, punk),\
    0\
  >::data,\
  ::facebook::Detail::QueryHepler<_ComMapClass>::\
    QueryInterfaceHelperT\
  },

#define COM_INTERFACE_ENTRY_HELPER2(itf, punk, itfBase)\
  {&_ATL_IIDOF(itf),\
  (DWORD_PTR)&::facebook::Detail::InterfaceHelper<\
    itf, _ComMapClass,\
    (DWORD_PTR)offsetof(_ComMapClass, punk),\
    &_ATL_IIDOF(itfBase)\
  >::data,\
  ::facebook::Detail::QueryHepler<_ComMapClass>::\
    QueryInterfaceHelperT\
  },

#define DECLARE_GET_TARGET_UNKNOWN(x) \
  inline IUnknown* GetTargetUnknown() {return x;}

// Workaround for VC6's deficiencies in dealing with function templates.
// We'd use non-member template functions, but VC6 does not handle those well.
// Static members of class templates work much better, and we don't need
// parameter deduction here
template <class T>
struct QueryHepler{
  static HRESULT WINAPI QueryInterfaceHelperT(void* buffer, REFIID riid,
    LPVOID* resultPointer, DWORD_PTR dw);
};

HRESULT WINAPI QueryInterfaceHelper(void* buffer, REFIID riid,
  LPVOID* resultPointer, DWORD_PTR dw, IUnknown* target, IUnknown* wrapper);

HRESULT QueryServiceHelper(REFGUID guidService,
  IUnknown* thisPointer, REFIID riid, void** resultPointer,
  IServiceProvider* clientProvider);

} // !namespace facebook::Detail

/**
 * class IInternetProtocolImpl
 *
 * Implementation of the default protocol handler interfaces
 */
class ATL_NO_VTABLE IInternetProtocolImpl :
  public IBaseObject,
  public IInternetProtocol,
  public IInternetProtocolInfo,
  public IInternetPriority,
  public IInternetThreadSwitch,
  public IWinInetHttpInfo {

public:

  void ReleaseAll();

  DECLARE_GET_TARGET_UNKNOWN(internetProtocolUnk_)

public:

  // IBasicObject
  STDMETHODIMP SetTargetUnknown(IUnknown* target);
  STDMETHODIMP setTargetWindow(HWND window);

  // IInternetProtocolRoot
  STDMETHODIMP Start(
    /* [in] */ LPCWSTR url,
    /* [in] */ IInternetProtocolSink *outProtocolSink,
    /* [in] */ IInternetBindInfo *outBindInfo,
    /* [in] */ DWORD parameter,
    /* [in] */ HANDLE_PTR reserved);

  STDMETHODIMP Continue(
    /* [in] */ PROTOCOLDATA *protocolData);

  STDMETHODIMP Abort(
    /* [in] */ HRESULT reason,
    /* [in] */ DWORD options);

  STDMETHODIMP Terminate(
    /* [in] */ DWORD options);

  STDMETHODIMP Suspend();

  STDMETHODIMP Resume();

  // IInternetProtocol
  STDMETHODIMP Read(
    /* [in, out] */ void *buffer,
    /* [in] */ ULONG bufferSize,
    /* [out] */ ULONG *readBuffer);

  STDMETHODIMP Seek(
    /* [in] */ LARGE_INTEGER moveSize,
    /* [in] */ DWORD origin,
    /* [out] */ ULARGE_INTEGER *newPosition);

  STDMETHODIMP LockRequest(
    /* [in] */ DWORD options);

  STDMETHODIMP UnlockRequest();

  // IInternetProtocolInfo
  STDMETHODIMP ParseUrl(
    /* [in] */ LPCWSTR url,
    /* [in] */ PARSEACTION ParseAction,
    /* [in] */ DWORD parseFlags,
    /* [out] */ LPWSTR resultString,
    /* [in] */ DWORD resultSize,
    /* [out] */ DWORD *result,
    /* [in] */ DWORD reserved);

  STDMETHODIMP CombineUrl(
    /* [in] */ LPCWSTR baseUrl,
    /* [in] */ LPCWSTR relativeUrl,
    /* [in] */ DWORD combineFlags,
    /* [out] */ LPWSTR resultString,
    /* [in] */ DWORD resultSize,
    /* [out] */ DWORD *result,
    /* [in] */ DWORD reserved);

  STDMETHODIMP CompareUrl(
    /* [in] */ LPCWSTR url1,
    /* [in] */ LPCWSTR url2,
    /* [in] */ DWORD compareFlags);

  STDMETHODIMP QueryInfo(
    /* [in] */ LPCWSTR url,
    /* [in] */ QUERYOPTION QueryOption,
    /* [in] */ DWORD queryFlags,
    /* [in, out] */ LPVOID bufferPointer,
    /* [in] */ DWORD bufferSize,
    /* [in, out] */ DWORD *buffer,
    /* [in] */ DWORD reserved);

  // IInternetPriority
  STDMETHODIMP SetPriority(
    /* [in] */ LONG priority);

  STDMETHODIMP GetPriority(
    /* [out] */ LONG *priority);

  // IInternetThreadSwitch
  STDMETHODIMP Prepare();

  STDMETHODIMP Continue();

  // IWinInetInfo
  STDMETHODIMP QueryOption(
    /* [in] */ DWORD option,
    /* [in, out] */ LPVOID bufferPointer,
    /* [in, out] */ DWORD *buffer);

  // IWinInetHttpInfo
  STDMETHODIMP QueryInfo(
    /* [in] */ DWORD option,
    /* [in, out] */ LPVOID bufferPointer,
    /* [in, out] */ DWORD *buffer,
    /* [in, out] */ DWORD *flags,
    /* [in, out] */ DWORD *reserved);

public:

  CComPtr<IUnknown> internetProtocolUnk_;
  CComPtr<IInternetProtocol> internetProtocol_;
  CComPtr<IInternetProtocolInfo> internetProtocolInfo_;
  CComPtr<IInternetPriority> internetPriority_;
  CComPtr<IInternetThreadSwitch> internetThreadSwitch_;
  CComPtr<IWinInetInfo> winInetInfo_;
  CComPtr<IWinInetHttpInfo> winInetHttpInfo_;
  HWND targetWindow_;

};

/**
 * class IInternetProtocolSinkImpl
 *
 * Implementation of the default protocol handler sink interfaces
 * 
 */
class ATL_NO_VTABLE IInternetProtocolSinkImpl :
  public IInternetProtocolSink,
  public IServiceProvider,
  public IInternetBindInfo{
public:
  HRESULT OnStart(LPCWSTR url, IInternetProtocolSink *outProtocolSink,
    IInternetBindInfo *outBindInfo, DWORD parameter, HANDLE_PTR reserved,
    IInternetProtocol* targetProtocol);
  void ReleaseAll();

  DECLARE_GET_TARGET_UNKNOWN(internetProtocolSink_)

  IServiceProvider* GetClientServiceProvider();

  HRESULT QueryServiceFromClient(REFGUID guidService, REFIID riid,
    void** createdObject);
  template <class Q>
  HRESULT QueryServiceFromClient(REFGUID guidService, Q** resultPointer) {
    return QueryServiceFromClient(guidService, _ATL_IIDOF(Q),
      reinterpret_cast<void**>(resultPointer));
  }
  template <class Q>
  HRESULT QueryServiceFromClient(Q** resultPointer) {
    return QueryServiceFromClient(_ATL_IIDOF(Q), _ATL_IIDOF(Q),
      reinterpret_cast<void**>(resultPointer));
  }
public:
  // IInternetProtocolSink
  STDMETHODIMP Switch(
    /* [in] */ PROTOCOLDATA *protocolData);

  STDMETHODIMP ReportProgress(
    /* [in] */ ULONG statusCode,
    /* [in] */ LPCWSTR statusText);

  STDMETHODIMP ReportData(
    /* [in] */ DWORD grfBSCF,
    /* [in] */ ULONG progress,
    /* [in] */ ULONG progressMax);

  STDMETHODIMP ReportResult(
    /* [in] */ HRESULT result,
    /* [in] */ DWORD errorCode,
    /* [in] */ LPCWSTR resultString);

  // IServiceProvider
  STDMETHODIMP QueryService(
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [out] */ void** createdObject);

  // IInternetBindInfo
  STDMETHODIMP GetBindInfo(
    /* [out] */ DWORD *bindFlags,
    /* [in, out] */ BINDINFO *bindInfo);

  STDMETHODIMP GetBindString(
    /* [in] */ ULONG stringType,
    /* [in, out] */ LPOLESTR *bindString,
    /* [in] */ ULONG el,
    /* [in, out] */ ULONG *fetched);
public:
  CComPtr<IInternetProtocolSink> internetProtocolSink_;
  CComPtr<IServiceProvider> serviceProvider_;
  CComPtr<IInternetBindInfo> internetBindInfo_;
  CComPtr<IInternetProtocol> targetProtocol_;
};

 /**
  * class InternetProtocolSink
  *
  * Sink Object that will be used to pu together 
  * default and custom internet protocol sinks 
  * 
  */

template <class T>
class InternetProtocolSink :
  public CComObjectRootEx<CComSingleThreadModel>,
  public IInternetProtocolSinkImpl{
public:
  HRESULT OnStart(LPCWSTR url, IInternetProtocolSink *outProtocolSink,
    IInternetBindInfo *outBindInfo, DWORD parameter, HANDLE_PTR reserved,
    IInternetProtocol* targetProtocol);

  STDMETHODIMP setTargetWindow(HWND window);
  HWND getTargetWindow() {return targetWindow_;}

  STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void** resultPointer);

  HRESULT _InternalQueryService(REFGUID guidService, REFIID riid,
    void** createdObject);

  BEGIN_COM_MAP(InternetProtocolSink)
    COM_INTERFACE_ENTRY(IServiceProvider)
    COM_INTERFACE_ENTRY(IInternetProtocolSink)
    COM_INTERFACE_ENTRY_HELPER(IServiceProvider,
      serviceProvider_.p)
    COM_INTERFACE_ENTRY(IInternetBindInfo)
  END_COM_MAP()
private:
  HWND targetWindow_;
};

/**
 * class ComObjectInstance
 *
 * Helper class that allows to easily imlement any interface
 * 
 */

template <class Base>
class ComObjectInstance : public Base{
public:
  ComObjectInstance(IUnknown* resultInterface);

  STDMETHODIMP QueryInterface(REFIID iid, void** createdObject);

  template <class Q>
  HRESULT STDMETHODCALLTYPE QueryInterface(Q** resultPointer) {
    return QueryInterface(__uuidof(Q), (void**)resultPointer);
  }

  STDMETHODIMP_(ULONG) AddRef();
  STDMETHODIMP_(ULONG) Release();

private:
  IUnknown* resultInterface_;
};

/**
 * class CustomSinkStartPolicy
 *
 * Wrapper over InternetProtocolSink interface 
 * to subscribe to the protocol events
 * 
 */

template <class Sink>
class CustomSinkStartPolicy{
public:
  CustomSinkStartPolicy(IUnknown* resultInterface);

  HRESULT OnStart(LPCWSTR url,
    IInternetProtocolSink *outProtocolSink, IInternetBindInfo *outBindInfo,
    DWORD parameter, HANDLE_PTR reserved, IInternetProtocol* targetProtocol);

  ComObjectInstance<Sink> internetSink_;
};

/**
 * class InternetProtocol
 *
 * Custom implementation of the protocol handler
 * 
 */

template <class StartPolicy>
class ATL_NO_VTABLE InternetProtocol :
  public CComObjectRootEx<CComSingleThreadModel>,
  public IInternetProtocolImpl,
  public StartPolicy{
public:
  InternetProtocol();

  BEGIN_COM_MAP(InternetProtocol)
    COM_INTERFACE_ENTRY(IBaseObject)
    COM_INTERFACE_ENTRY(IInternetProtocolRoot)
    COM_INTERFACE_ENTRY(IInternetProtocol)
    COM_INTERFACE_ENTRY_HELPER(IInternetProtocolInfo,
      internetProtocolInfo_.p)
    COM_INTERFACE_ENTRY_HELPER(IInternetPriority,
      internetPriority_.p)
    COM_INTERFACE_ENTRY_HELPER(IInternetThreadSwitch,
      internetThreadSwitch_.p)
    COM_INTERFACE_ENTRY_HELPER(IWinInetInfo, winInetInfo_.p)
    COM_INTERFACE_ENTRY_HELPER2(IWinInetHttpInfo,
      winInetHttpInfo_.p, IWinInetInfo)
  END_COM_MAP()

  // IInternetProtocolRoot
  STDMETHODIMP Start(LPCWSTR url, IInternetProtocolSink *outProtocolSink,
    IInternetBindInfo *outBindInfo, DWORD parameter, HANDLE_PTR reserved);
};

} // !namespace facebook

#include "ProtocolImpl.inl"

#endif // PROTOCOLIMPL_H

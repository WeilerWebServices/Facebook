/**
* Facebook Internet Explorer Toolbar Software License 
* Copyright (c) 2009 Facebook, Inc. 
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (which, together with any graphical images included with such
* software, are collectively referred to below as the "Software") to (a) use,
* reproduce, display, distribute, execute, and transmit the Software, (b)
* prepare derivative works of the Software (excluding any graphical images
* included with the Software, which may not be modified or altered), and (c)
* permit third-parties to whom the Software is furnished to do so, all
* subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.  
*
* Facebook, Inc. retains ownership of the Software and all associated
* intellectual property rights.  All rights not expressly granted in this
* license are reserved by Facebook, Inc.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/ 


#include "stdafx.h"
#include "SessionSink.h"

#include "wininet.h"

#pragma warning(disable : 4146)
#pragma warning(disable : 4278) 
#include <boost/algorithm/string.hpp>

#include "../common/ToolbarMessages.h"

namespace facebook {

String parseCookie(String data, String cookie) {
  String result = _T("");
  size_t startPosition = data.find(cookie);
  if (startPosition == String::npos) {
    return result;
  }
  String startLetter = data.substr(startPosition - 1, 1);
  // we need start of the cookie name
  if (startLetter != String(_T(" "))) {
     return result;
  }
  size_t endPosition = data.find(_T(";"), startPosition);
  result = data.substr(startPosition, endPosition - startPosition);
  //add expiration, if it exists
  size_t expirePosition = data.find(_T("expires="));
  if (expirePosition != String::npos) {
    endPosition = data.find(_T(";"), expirePosition);
    result += _T("; ") + data.substr(expirePosition, endPosition - expirePosition);
  }

  //add expiration, if it exists
//  expirePosition = data.find(_T("httponly"));
 // if (expirePosition != String::npos) {
//    result += _T("; httponly");
//  }
  result += _T("\t");
  return result;
}

// ---------------------------------------------------------------------
// class SessionSink
// ---------------------------------------------------------------------

void SessionSink::processHeader(String header) {
  using namespace boost;
  std::vector<String> responseParts;
  split(responseParts, header, boost::is_any_of(_T("\r")));
  String cookies = _T("");
  // collect the set cookie entries
  int size = responseParts.size();
  for (int index = 0; index < size; ++index) {
    if (responseParts[index].empty()) {
      continue;
    }
    // find the cookies entries
    if (responseParts[index].find(_T("Set-Cookie")) == 
        String::npos) {
      continue;
    }
    // get only facebook cookies
    if (responseParts[index].find(_T(".facebook.com")) == 
        String::npos) {
      continue;
    }
    // if the command is to delete cookies then do not catch it
    if (responseParts[index].find(_T("deleted")) !=
      String::npos) {
        continue;
    }
    // get the xs cookie
    cookies += parseCookie(responseParts[index], _T("xs="));
    
    //get the c_user cookie
    cookies += parseCookie(responseParts[index], _T("c_user="));
  }
  if (!cookies.empty()) {
    SendMessage(getTargetWindow(), TBM_COOKIES, (WPARAM)cookies.c_str(), 0);
  }
}

STDMETHODIMP SessionSink::BeginningTransaction(
  /* [in] */ LPCWSTR url,
  /* [in] */ LPCWSTR headers,
  /* [in] */ DWORD reserved,
  /* [out] */ LPWSTR *additionalHeaders) {
  USES_CONVERSION;

  if (additionalHeaders) {
    *additionalHeaders = 0;
  }
  // made the default handling
  CComPtr<IHttpNegotiate> spHttpNegotiate;
  QueryServiceFromClient(&spHttpNegotiate);
  HRESULT hr = spHttpNegotiate ?
    spHttpNegotiate->BeginningTransaction(url, headers,
      reserved, additionalHeaders) :
    S_OK;
  return hr;
}

STDMETHODIMP SessionSink::OnResponse(
  /* [in] */ DWORD responseCode,
  /* [in] */ LPCWSTR responseHeaders,
  /* [in] */ LPCWSTR requestHeaders,
  /* [out] */ LPWSTR *additionalRequestHeaders) {
  USES_CONVERSION;
  if (additionalRequestHeaders) {
    *additionalRequestHeaders = 0;
  }
  // made the default handling
  CComPtr<IHttpNegotiate> spHttpNegotiate;
  QueryServiceFromClient(&spHttpNegotiate);
  HRESULT hr = spHttpNegotiate ?
    spHttpNegotiate->OnResponse(responseCode, responseHeaders,
      requestHeaders, additionalRequestHeaders) :
    S_OK;

  processHeader(responseHeaders);
  return hr;
}

STDMETHODIMP SessionSink::ReportProgress(
  /* [in] */ ULONG statusCode,
  /* [in] */ LPCWSTR statusText) {
  USES_CONVERSION;
  // made the default handling
  ATLASSERT(internetProtocolSink_ != 0);
  HRESULT hr = internetProtocolSink_ ?
    internetProtocolSink_->ReportProgress(statusCode, statusText) :
    S_OK;

  if(statusCode == BINDSTATUS_REDIRECTING) {
		//To get redirect headers during a redirect
		//No OnResponse is fired for a redirect
		//Get raw request headers and send them to client

    CComPtr<IWinInetHttpInfo> winInetHttpInfo;
		HRESULT hrTemp = targetProtocol_->QueryInterface(IID_IWinInetHttpInfo,
			reinterpret_cast<void**>(&winInetHttpInfo));

    String headers = _T("");
    if(SUCCEEDED(hrTemp)) {
			DWORD size = 0; 
      DWORD flags = 0;
			hrTemp = winInetHttpInfo->QueryInfo( HTTP_QUERY_RAW_HEADERS_CRLF,
				0, &size, &flags, 0);
			if(SUCCEEDED(hrTemp)) {
				LPSTR buffer = new CHAR[size + 1];
				buffer[size] = '\0';
				hrTemp = winInetHttpInfo->QueryInfo( HTTP_QUERY_RAW_HEADERS_CRLF,
					buffer, &size, &flags, 0);
				if(SUCCEEDED(hrTemp)) {
					NarrowString narrow = NarrowString(buffer);
          headers = toWiden(narrow);
				}
				delete [] buffer;
			}
		}
		processHeader(headers);
  }
  return hr;
}
} // !namespace facebook
/**
* Facebook Internet Explorer Toolbar Software License 
* Copyright (c) 2009 Facebook, Inc. 
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (which, together with any graphical images included with such
* software, are collectively referred to below as the "Software") to (a) use,
* reproduce, display, distribute, execute, and transmit the Software, (b)
* prepare derivative works of the Software (excluding any graphical images
* included with the Software, which may not be modified or altered), and (c)
* permit third-parties to whom the Software is furnished to do so, all
* subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.  
*
* Facebook, Inc. retains ownership of the Software and all associated
* intellectual property rights.  All rights not expressly granted in this
* license are reserved by Facebook, Inc.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/ 


#ifndef PROTOCOLCF_INL
#define PROTOCOLCF_INL

#include "BaseObject.h"

namespace facebook {

// ---------------------------------------------------------------------
// class ProtocolClassFactory
// ---------------------------------------------------------------------

inline STDMETHODIMP ProtocolClassFactory::CreateInstance(
  IUnknown* resultInterface, REFIID riid, void** resultObject) {
  ATLASSERT(resultObject != 0);
  if (!resultObject) {
    return E_POINTER;
  }
  *resultObject = 0;

  CComPtr<IUnknown> unknownTarget;
  HRESULT hr = CreateInstanceTarget(&unknownTarget);
  ATLASSERT(SUCCEEDED(hr) && unknownTarget != 0);

  CComPtr<IUnknown> spUnkObject;
  if (SUCCEEDED(hr)) {
    hr = BaseClass::CreateInstance(resultInterface, riid,
      reinterpret_cast<void**>(&spUnkObject));
    ATLASSERT(SUCCEEDED(hr) && spUnkObject != 0);
  }

  if (SUCCEEDED(hr)) {
    CComPtr<IBaseObject> baseObj;
    hr = spUnkObject->QueryInterface(&baseObj);
    ATLASSERT(SUCCEEDED(hr) && baseObj != 0);
    if (SUCCEEDED(hr)) {
      hr = baseObj->SetTargetUnknown(unknownTarget);
      baseObj->setTargetWindow(targetWindow_);
      ATLASSERT(SUCCEEDED(hr));
    }
  }

  if (SUCCEEDED(hr)) {
    *resultObject = spUnkObject.Detach();
  }
  return hr;
}

inline HRESULT ProtocolClassFactory::CreateInstanceTarget(
  IUnknown** targetProtocol) {
  ATLASSERT(targetProtocol != 0);
  if (!targetProtocol) {
    return E_POINTER;
  }
  *targetProtocol = 0;

  CComPtr<IClassFactory> targetFactoryObject;
  HRESULT hr = GetTargetClassFactory(&targetFactoryObject);
  ATLASSERT(SUCCEEDED(hr) && targetFactoryObject != 0);
  if (SUCCEEDED(hr)) {
    hr = targetFactoryObject->CreateInstance(0, IID_IInternetProtocolRoot,
      reinterpret_cast<void**>(targetProtocol));
    ATLASSERT(SUCCEEDED(hr) && *targetProtocol != 0);
  }
  return hr;
}

inline HRESULT ProtocolClassFactory::GetTargetClassFactory(
  IClassFactory** targetFactory) {
  return targetFactory_.CopyTo(targetFactory);
}

inline HRESULT ProtocolClassFactory::SetTargetClassFactory(
  IClassFactory* factory) {
  HRESULT hr = (factory ? factory->LockServer(TRUE) : S_OK);
  if (SUCCEEDED(hr)) {
    if (targetFactory_) {
      // LockServer(FALSE) is assumed to always succeed. Otherwise,
      // it is impossible to implement correct semantics
      HRESULT hr1 = targetFactory_->LockServer(FALSE);
      hr1;
      ATLASSERT(SUCCEEDED(hr1));
    }
    targetFactory_ = factory;
  }
  return hr;
}

inline HRESULT ProtocolClassFactory::SetTargetCLSID(REFCLSID classId,
  DWORD classContext) {
  CComPtr<IClassFactory> targetFactoryObject;
  HRESULT hr = CoGetClassObject(classId, classContext, 0, IID_IClassFactory,
    reinterpret_cast<void**>(&targetFactoryObject));
  ATLASSERT(SUCCEEDED(hr) && targetFactoryObject != 0);
  if (SUCCEEDED(hr)) {
    hr = SetTargetClassFactory(targetFactoryObject);
    ATLASSERT(SUCCEEDED(hr));
  }
  return hr;
}

inline void ProtocolClassFactory::FinalRelease() {
  // No need to be thread safe here
  if (targetFactory_) {
    // LockServer(FALSE) is assumed to always succeed.
    HRESULT hr = targetFactory_->LockServer(FALSE);
    hr;
    ATLASSERT(SUCCEEDED(hr));

    targetFactory_.Release();
  }
}

// ---------------------------------------------------------------------
// struct MetaFactory
// ---------------------------------------------------------------------

template <class Protocol>
inline HRESULT MetaFactory<Protocol>::
  CreateInstance(ProtocolClassFactory** resultObject, HWND window) {
  ATLASSERT(resultObject != 0);
  if (!resultObject) {
    return E_POINTER;
  }

  HRESULT hr = E_OUTOFMEMORY;
  void* buffer = static_cast<void*>(CreatorClass::CreateInstance);
  CComObjectNoLock<ProtocolClassFactory>* p = 0;
  ATLTRY(p = new CComObjectNoLock<ProtocolClassFactory>(buffer))
  if (p != NULL) {
    p->SetVoid(buffer);
    p->setTargetWindow(window);
    p->InternalFinalConstructAddRef();
    hr = p->FinalConstruct();
    p->InternalFinalConstructRelease();
    if (FAILED(hr)) {
      delete p;
      p = 0;
    }
  }
  *resultObject = p;
  return hr;
}

template <class Protocol>
inline HRESULT MetaFactory<Protocol>::
  CreateInstance(IClassFactory* targetInterface, 
                 IClassFactory** targetFactory, HWND window) {
  if (!targetFactory) {
    return E_POINTER;
  }
  *targetFactory = 0;

  ProtocolClassFactory* pObj = 0;
  HRESULT hr = CreateInstance(&pObj);
  ATLASSERT(SUCCEEDED(hr) && pObj != 0);
  if (SUCCEEDED(hr)) {
    pObj->AddRef();

    hr = pObj->SetTargetClassFactory(targetInterface);
    pObj->setTargetWindow(window);
    ATLASSERT(SUCCEEDED(hr));

    if (SUCCEEDED(hr)) {
      hr = pObj->QueryInterface(IID_IClassFactory,
        reinterpret_cast<void**>(targetFactory));
      ATLASSERT(SUCCEEDED(hr) && *targetFactory != 0);
    }
    pObj->Release();
  }
  return hr;
}

template <class Protocol>
inline HRESULT MetaFactory<Protocol>::
  CreateInstance(REFCLSID clsidTarget, 
                 IClassFactory** targetFactory, HWND window) {
  if (!targetFactory) {
    return E_POINTER;
  }
  *targetFactory = 0;

  ProtocolClassFactory* pObj = 0;
  HRESULT hr = CreateInstance(&pObj, window);
  ATLASSERT(SUCCEEDED(hr) && pObj != 0);
  if (SUCCEEDED(hr)) {
    pObj->AddRef();

    hr = pObj->SetTargetCLSID(clsidTarget);
    pObj->setTargetWindow(window);
    ATLASSERT(SUCCEEDED(hr));

    if (SUCCEEDED(hr)) {
      hr = pObj->QueryInterface(IID_IClassFactory,
        reinterpret_cast<void**>(targetFactory));
      ATLASSERT(SUCCEEDED(hr) && *targetFactory != 0);
    }
    pObj->Release();
  }
  return hr;
}

} // !namespace facebook

#endif // PROTOCOLCF_INL

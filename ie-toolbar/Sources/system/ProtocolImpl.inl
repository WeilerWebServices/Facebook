/**
* Facebook Internet Explorer Toolbar Software License 
* Copyright (c) 2009 Facebook, Inc. 
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (which, together with any graphical images included with such
* software, are collectively referred to below as the "Software") to (a) use,
* reproduce, display, distribute, execute, and transmit the Software, (b)
* prepare derivative works of the Software (excluding any graphical images
* included with the Software, which may not be modified or altered), and (c)
* permit third-parties to whom the Software is furnished to do so, all
* subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.  
*
* Facebook, Inc. retains ownership of the Software and all associated
* intellectual property rights.  All rights not expressly granted in this
* license are reserved by Facebook, Inc.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/ 


#ifndef PROTOCOLIMPL_INL
#define PROTOCOLIMPL_INL

namespace facebook {

namespace Detail {

template <class T>
inline HRESULT WINAPI QueryHepler<T>::
  QueryInterfaceHelperT(void* buffer, REFIID riid, LPVOID* resultPointer, DWORD_PTR dw) {
  ATLASSERT(buffer != 0);
  T* pT = static_cast<T*>(buffer);

  IUnknown* target = pT->GetTargetUnknown();
  ATLASSERT(target != 0);
  if (!target) {
    ATLTRACE(_T("Interface queried before target unknown is set"));
    return E_UNEXPECTED;
  }

  IUnknown* wrapper = pT->GetUnknown();

  typename T::ObjectLock lock(pT);
  return QueryInterfaceHelper(
    buffer, riid, resultPointer, dw, target, wrapper);
}

inline HRESULT WINAPI QueryInterfaceHelper(void* buffer, REFIID riid,
  LPVOID* resultPointer, DWORD_PTR dw, IUnknown* target, IUnknown* wrapper) {
  ATLASSERT(buffer != 0);
  ATLASSERT(resultPointer != 0);
  ATLASSERT(dw != 0);
  ATLASSERT(target != 0);

  const InterfaceHelperData& data =
    *reinterpret_cast<const InterfaceHelperData*>(dw);

  IUnknown** ppUnk = reinterpret_cast<IUnknown**>(
    static_cast<char*>(buffer) + data.offsetUnk);

  HRESULT hr = S_OK;
  if (!*ppUnk) {
    CComPtr<IUnknown> unkownObject;
    hr = target->QueryInterface(riid,
      reinterpret_cast<void**>(&unkownObject));
    ATLASSERT(FAILED(hr) || unkownObject != 0);
    if (SUCCEEDED(hr)) {
      *ppUnk = unkownObject.Detach();

      // Need to QI for base interface to fill in base target pointer
      if (data.iidBase) {
        ATLASSERT(wrapper != 0);
        hr = wrapper->QueryInterface(*data.iidBase,
          reinterpret_cast<void**>(&unkownObject));
        // since QI for derived interface succeeded,
        // QI for base interface must succeed, too
        ATLASSERT(SUCCEEDED(hr));
      }
    }
  }
  if (SUCCEEDED(hr)) {
    CComPtr<IUnknown> spItf = reinterpret_cast<IUnknown*>(
      static_cast<char*>(buffer) + data.offsetItf);
    *resultPointer = spItf.Detach();
  } else {
    ATLASSERT(_T("Interface not supported by target unknown"));
  }
  return hr;
}

inline HRESULT QueryServiceHelper(REFGUID guidService,
  IUnknown* thisPointer, REFIID riid, void** resultPointer,
  IServiceProvider* clientProvider) {
  ATLASSERT(thisPointer != 0);
  CComPtr<IUnknown> dummyObject;
  HRESULT hr = clientProvider ?
    clientProvider->QueryService(guidService, riid,
      reinterpret_cast<void**>(&dummyObject)) :
    E_NOINTERFACE;
  if (SUCCEEDED(hr)) {
    hr = thisPointer->QueryInterface(riid, resultPointer);
  }
  return hr;
}

} // !namespace facebook::Detail


// ---------------------------------------------------------------------
// class IInternetProtocolImpl
// ---------------------------------------------------------------------

inline STDMETHODIMP IInternetProtocolImpl::SetTargetUnknown(
  IUnknown* target) {
  ATLASSERT(target != 0);
  if (!target) {
    return E_POINTER;
  }

  // This method should only be called once, and be the only source
  // of target interface pointers.
  ATLASSERT(internetProtocolUnk_ == 0);
  ATLASSERT(internetProtocol_ == 0);
  if (internetProtocolUnk_ || internetProtocol_) {
    return E_UNEXPECTED;
  }

  // We expect the target unknown to implement at least IInternetProtocol
  // Otherwise we reject it
  HRESULT hr = target->QueryInterface(&internetProtocol_);
  ATLASSERT(FAILED(hr) || internetProtocol_ != 0);
  if (FAILED(hr)) {
    return hr;
  }

  ATLASSERT(internetProtocolInfo_ == 0);
  ATLASSERT(internetPriority_ == 0);
  ATLASSERT(internetThreadSwitch_ == 0);
  ATLASSERT(winInetInfo_ == 0);
  ATLASSERT(winInetHttpInfo_ == 0);

  internetProtocolUnk_ = target;
  return S_OK;
}

inline STDMETHODIMP IInternetProtocolImpl::setTargetWindow(HWND window) {
  targetWindow_ = window;
  return S_OK;
}

inline void IInternetProtocolImpl::ReleaseAll() {
  internetProtocolUnk_.Release();
  internetProtocol_.Release();
  internetProtocolInfo_.Release();
  internetPriority_.Release();
  internetThreadSwitch_.Release();
  winInetInfo_.Release();
  winInetHttpInfo_.Release();
}

// IInternetProtocolRoot
inline STDMETHODIMP IInternetProtocolImpl::Start(
  /* [in] */ LPCWSTR url,
  /* [in] */ IInternetProtocolSink *outProtocolSink,
  /* [in] */ IInternetBindInfo *outBindInfo,
  /* [in] */ DWORD parameter,
  /* [in] */ HANDLE_PTR reserved) {
  ATLASSERT(internetProtocol_ != 0);
  return internetProtocol_ ?
    internetProtocol_->Start(url, outProtocolSink, outBindInfo, parameter,
      reserved) :
    E_UNEXPECTED;
}

inline STDMETHODIMP IInternetProtocolImpl::Continue(
  /* [in] */ PROTOCOLDATA *protocolData) {
  ATLASSERT(internetProtocol_ != 0);
  return internetProtocol_ ?
    internetProtocol_->Continue(protocolData) :
    E_UNEXPECTED;
}

inline STDMETHODIMP IInternetProtocolImpl::Abort(
  /* [in] */ HRESULT reason,
  /* [in] */ DWORD options) {
  ATLASSERT(internetProtocol_ != 0);
  return internetProtocol_ ?
    internetProtocol_->Abort(reason, options) :
    E_UNEXPECTED;
}

inline STDMETHODIMP IInternetProtocolImpl::Terminate(
  /* [in] */ DWORD options) {
  ATLASSERT(internetProtocol_ != 0);
  return internetProtocol_ ?
    internetProtocol_->Terminate(options) :
    E_UNEXPECTED;
}

inline STDMETHODIMP IInternetProtocolImpl::Suspend() {
  ATLASSERT(internetProtocol_ != 0);
  return internetProtocol_ ?
    internetProtocol_->Suspend() :
    E_UNEXPECTED;
}

inline STDMETHODIMP IInternetProtocolImpl::Resume() {
  ATLASSERT(internetProtocol_ != 0);
  return internetProtocol_ ?
    internetProtocol_->Resume() :
    E_UNEXPECTED;
}

// IInternetProtocol
inline STDMETHODIMP IInternetProtocolImpl::Read(
  /* [in, out] */ void *buffer,
  /* [in] */ ULONG bufferSize,
  /* [out] */ ULONG *readBuffer) {
  ATLASSERT(internetProtocol_ != 0);
  return internetProtocol_ ?
    internetProtocol_->Read(buffer, bufferSize, readBuffer) :
    E_UNEXPECTED;
}

inline STDMETHODIMP IInternetProtocolImpl::Seek(
  /* [in] */ LARGE_INTEGER moveSize,
  /* [in] */ DWORD origin,
  /* [out] */ ULARGE_INTEGER *newPosition) {
  ATLASSERT(internetProtocol_ != 0);
  return internetProtocol_ ?
    internetProtocol_->Seek(moveSize, origin, newPosition) :
    E_UNEXPECTED;
}

inline STDMETHODIMP IInternetProtocolImpl::LockRequest(
  /* [in] */ DWORD options) {
  ATLASSERT(internetProtocol_ != 0);
  return internetProtocol_ ?
    internetProtocol_->LockRequest(options) :
    E_UNEXPECTED;
}

inline STDMETHODIMP IInternetProtocolImpl::UnlockRequest() {
  ATLASSERT(internetProtocol_ != 0);
  return internetProtocol_ ?
    internetProtocol_->UnlockRequest() :
    E_UNEXPECTED;
}

// IInternetProtocolInfo
inline STDMETHODIMP IInternetProtocolImpl::ParseUrl(
  /* [in] */ LPCWSTR url,
  /* [in] */ PARSEACTION ParseAction,
  /* [in] */ DWORD parseFlags,
  /* [out] */ LPWSTR resultString,
  /* [in] */ DWORD resultSize,
  /* [out] */ DWORD *result,
  /* [in] */ DWORD reserved) {
  ATLASSERT(internetProtocolInfo_ != 0);
  return internetProtocolInfo_ ?
    internetProtocolInfo_->ParseUrl(url, ParseAction, parseFlags,
      resultString, resultSize, result, reserved) :
    E_UNEXPECTED;
}

inline STDMETHODIMP IInternetProtocolImpl::CombineUrl(
  /* [in] */ LPCWSTR baseUrl,
  /* [in] */ LPCWSTR relativeUrl,
  /* [in] */ DWORD combineFlags,
  /* [out] */ LPWSTR resultString,
  /* [in] */ DWORD resultSize,
  /* [out] */ DWORD *result,
  /* [in] */ DWORD reserved) {
  ATLASSERT(internetProtocolInfo_ != 0);
  return internetProtocolInfo_ ?
    internetProtocolInfo_->CombineUrl(baseUrl, relativeUrl,
      combineFlags, resultString, resultSize, result, reserved) :
    E_UNEXPECTED;
}

inline STDMETHODIMP IInternetProtocolImpl::CompareUrl(
  /* [in] */ LPCWSTR url1,
  /* [in] */ LPCWSTR url2,
  /* [in] */ DWORD compareFlags) {
  ATLASSERT(internetProtocolInfo_ != 0);
  return internetProtocolInfo_ ?
    internetProtocolInfo_->CompareUrl(url1,url2, compareFlags) :
    E_UNEXPECTED;
}

inline STDMETHODIMP IInternetProtocolImpl::QueryInfo(
  /* [in] */ LPCWSTR url,
  /* [in] */ QUERYOPTION QueryOption,
  /* [in] */ DWORD queryFlags,
  /* [in, out] */ LPVOID bufferPointer,
  /* [in] */ DWORD bufferSize,
  /* [in, out] */ DWORD *buffer,
  /* [in] */ DWORD reserved) {
  ATLASSERT(internetProtocolInfo_ != 0);
  return internetProtocolInfo_ ?
    internetProtocolInfo_->QueryInfo(url, QueryOption, queryFlags,
      bufferPointer, bufferSize, buffer, reserved) :
    E_UNEXPECTED;
}

// IInternetPriority
inline STDMETHODIMP IInternetProtocolImpl::SetPriority(
  /* [in] */ LONG priority) {
  ATLASSERT(internetPriority_ != 0);
  return internetPriority_ ?
    internetPriority_->SetPriority(priority) :
    E_UNEXPECTED;
}

inline STDMETHODIMP IInternetProtocolImpl::GetPriority(
  /* [out] */ LONG *priority) {
  ATLASSERT(internetPriority_ != 0);
  return internetPriority_ ?
    internetPriority_->GetPriority(priority) :
  E_UNEXPECTED;
}

// IInternetThreadSwitch
inline STDMETHODIMP IInternetProtocolImpl::Prepare() {
  ATLASSERT(internetThreadSwitch_ != 0);
  return internetThreadSwitch_ ?
    internetThreadSwitch_->Prepare() :
  E_UNEXPECTED;
}

inline STDMETHODIMP IInternetProtocolImpl::Continue() {
  ATLASSERT(internetThreadSwitch_ != 0);
  return internetThreadSwitch_ ?
    internetThreadSwitch_->Continue() :
  E_UNEXPECTED;
}

// IWinInetInfo
inline STDMETHODIMP IInternetProtocolImpl::QueryOption(
  /* [in] */ DWORD option,
  /* [in, out] */ LPVOID bufferPointer,
  /* [in, out] */ DWORD *buffer) {
  ATLASSERT(winInetInfo_ != 0);
  return winInetInfo_ ?
    winInetInfo_->QueryOption(option, bufferPointer, buffer) :
    E_UNEXPECTED;
}

// IWinInetHttpInfo
inline STDMETHODIMP IInternetProtocolImpl::QueryInfo(
  /* [in] */ DWORD option,
  /* [in, out] */ LPVOID bufferPointer,
  /* [in, out] */ DWORD *buffer,
  /* [in, out] */ DWORD *flags,
  /* [in, out] */ DWORD *reserved) {
  ATLASSERT(winInetHttpInfo_  != 0);
  return winInetHttpInfo_ ?
    winInetHttpInfo_->QueryInfo(option, bufferPointer, buffer, flags,
      reserved) :
    E_UNEXPECTED;
}

// ---------------------------------------------------------------------
// class IInternetProtocolSinkImpl
// ---------------------------------------------------------------------

inline HRESULT IInternetProtocolSinkImpl::OnStart(LPCWSTR url,
  IInternetProtocolSink *outProtocolSink, IInternetBindInfo *outBindInfo,
  DWORD parameter, HANDLE_PTR reserved, IInternetProtocol* targetProtocol) {

  UNREFERENCED_PARAMETER(reserved);
  UNREFERENCED_PARAMETER(parameter);
  UNREFERENCED_PARAMETER(url);
  ATLASSERT(outProtocolSink != 0);
  ATLASSERT(outBindInfo != 0);
  ATLASSERT(targetProtocol != 0);
  if (!outProtocolSink || !outBindInfo || !targetProtocol) {
    return E_POINTER;
  }

  // This method should only be called once, and be the only source
  // of target interface pointers.
  ATLASSERT(internetProtocolSink_ == 0);
  ATLASSERT(internetBindInfo_ == 0);
  ATLASSERT(targetProtocol_ == 0);
  if (internetProtocolSink_ || internetBindInfo_ || targetProtocol_) {
    return E_UNEXPECTED;
  }

  ATLASSERT(serviceProvider_ == 0);

  internetProtocolSink_ = outProtocolSink;
  internetBindInfo_ = outBindInfo;
  targetProtocol_ = targetProtocol;
  return S_OK;
}

inline void IInternetProtocolSinkImpl::ReleaseAll() {
  internetProtocolSink_.Release();
  serviceProvider_.Release();
  internetBindInfo_.Release();
  targetProtocol_.Release();
}

inline IServiceProvider* IInternetProtocolSinkImpl::GetClientServiceProvider() {
  return serviceProvider_;
}

inline HRESULT IInternetProtocolSinkImpl::QueryServiceFromClient(
  REFGUID guidService, REFIID riid, void** createdObject) {
  HRESULT hr = S_OK;
  CComPtr<IServiceProvider> clientProviderObject = serviceProvider_;
  if (!clientProviderObject) {
    hr = internetProtocolSink_->QueryInterface(&clientProviderObject);
    ATLASSERT(SUCCEEDED(hr) && clientProviderObject != 0);
  }
  if (SUCCEEDED(hr)) {
    hr = clientProviderObject->QueryService(guidService, riid, createdObject);
  }
  return hr;
}

// IInternetProtocolSink
inline STDMETHODIMP IInternetProtocolSinkImpl::Switch(
  /* [in] */ PROTOCOLDATA *protocolData) {
  ATLASSERT(internetProtocolSink_ != 0);
  return internetProtocolSink_ ?
    internetProtocolSink_->Switch(protocolData) :
    E_UNEXPECTED;
}

inline STDMETHODIMP IInternetProtocolSinkImpl::ReportProgress(
  /* [in] */ ULONG statusCode,
  /* [in] */ LPCWSTR statusText) {
  ATLASSERT(internetProtocolSink_ != 0);
  return internetProtocolSink_ ?
    internetProtocolSink_->ReportProgress(statusCode, statusText) :
    E_UNEXPECTED;
}

inline STDMETHODIMP IInternetProtocolSinkImpl::ReportData(
  /* [in] */ DWORD grfBSCF,
  /* [in] */ ULONG progress,
  /* [in] */ ULONG progressMax) {
  ATLASSERT(internetProtocolSink_ != 0);
  return internetProtocolSink_ ?
    internetProtocolSink_->ReportData(grfBSCF, progress,
      progressMax) :
    E_UNEXPECTED;
}

inline STDMETHODIMP IInternetProtocolSinkImpl::ReportResult(
  /* [in] */ HRESULT result,
  /* [in] */ DWORD errorCode,
  /* [in] */ LPCWSTR resultString) {
  ATLASSERT(internetProtocolSink_ != 0);
  return internetProtocolSink_ ?
    internetProtocolSink_->ReportResult(result, errorCode, resultString) :
    E_UNEXPECTED;
}

// IServiceProvider
inline STDMETHODIMP IInternetProtocolSinkImpl::QueryService(
  /* [in] */ REFGUID guidService,
  /* [in] */ REFIID riid,
  /* [out] */ void** createdObject) {
  ATLASSERT(serviceProvider_ != 0);
  return serviceProvider_ ?
    serviceProvider_->QueryService(guidService, riid, createdObject) :
    E_UNEXPECTED;
}

// IInternetBindInfo
inline STDMETHODIMP IInternetProtocolSinkImpl::GetBindInfo(
  /* [out] */ DWORD *bindFlags,
  /* [in, out] */ BINDINFO *bindInfo) {
  ATLASSERT(internetBindInfo_ != 0);
  return internetBindInfo_ ?
    internetBindInfo_->GetBindInfo(bindFlags, bindInfo) :
    E_UNEXPECTED;
}

inline STDMETHODIMP IInternetProtocolSinkImpl::GetBindString(
  /* [in] */ ULONG stringType,
  /* [in, out] */ LPOLESTR *bindString,
  /* [in] */ ULONG el,
  /* [in, out] */ ULONG *fetched) {
  ATLASSERT(internetBindInfo_ != 0);
  return internetBindInfo_ ?
    internetBindInfo_->GetBindString(stringType, bindString, el,
      fetched) :
    E_UNEXPECTED;
}

// ---------------------------------------------------------------------
// class InternetProtocolSink
// ---------------------------------------------------------------------

template <class T>
inline HRESULT InternetProtocolSink<T>::OnStart(
  LPCWSTR url, IInternetProtocolSink *outProtocolSink,
  IInternetBindInfo *outBindInfo,  DWORD parameter, HANDLE_PTR reserved,
  IInternetProtocol* targetProtocol) {
  ATLASSERT(serviceProvider_ == 0);
  if (serviceProvider_) {
    return E_UNEXPECTED;
  }
  HRESULT hr = IInternetProtocolSinkImpl::OnStart(url, outProtocolSink, outBindInfo, parameter,
    reserved, targetProtocol);
  if (SUCCEEDED(hr)) {
    outProtocolSink->QueryInterface(&serviceProvider_);
  }
  return hr;
}

template <class T>
inline STDMETHODIMP InternetProtocolSink<T>::setTargetWindow(
  HWND window) {

  targetWindow_ = window;
  return S_OK;
}

template <class T>
inline HRESULT InternetProtocolSink<T>::
  _InternalQueryService(REFGUID guidService, REFIID riid, void** createdObject) {
  return E_NOINTERFACE;
}

template <class T>
inline STDMETHODIMP InternetProtocolSink<T>::QueryService(
  REFGUID guidService, REFIID riid, void** resultPointer) {
  T* pT = static_cast<T*>(this);
  HRESULT hr = pT->_InternalQueryService(guidService, riid, resultPointer);
  if (FAILED(hr) && serviceProvider_) {
    hr = serviceProvider_->QueryService(guidService, riid, resultPointer);
  }
  return hr;
}

// ---------------------------------------------------------------------
// class ComObjectInstance
// ---------------------------------------------------------------------

template<class Base>
inline ComObjectInstance<Base>::ComObjectInstance(IUnknown* resultInterface) :
  resultInterface_(resultInterface) {
  ATLASSERT(resultInterface_ != 0);
}

template<class Base>
inline STDMETHODIMP ComObjectInstance<Base>::QueryInterface(REFIID iid,
  void** createdObject) {
  return _InternalQueryInterface(iid, createdObject);
}

template<class Base>
inline STDMETHODIMP_(ULONG) ComObjectInstance<Base>::AddRef() {
  if (resultInterface_) {
    resultInterface_->AddRef();
  }
  return InternalAddRef();
}

template<class Base>
inline STDMETHODIMP_(ULONG) ComObjectInstance<Base>::Release() {
  ULONG l = InternalRelease();
  if (!l) {
    ReleaseAll();
  }
  if (resultInterface_) {
    resultInterface_->Release();
  }
  return l;
}

// ---------------------------------------------------------------------
// class CustomSinkStartPolicy
// ---------------------------------------------------------------------

template <class Sink>
inline CustomSinkStartPolicy<Sink>::
  CustomSinkStartPolicy(IUnknown* resultInterface) :
internetSink_(resultInterface) {
}

template <class Sink>
inline HRESULT CustomSinkStartPolicy<Sink>::OnStart(LPCWSTR url,
  IInternetProtocolSink *outProtocolSink, IInternetBindInfo *outBindInfo,
  DWORD parameter, HANDLE_PTR reserved, IInternetProtocol* targetProtocol) {
  ATLASSERT(targetProtocol);
  HRESULT hr = internetSink_.OnStart(url, outProtocolSink, outBindInfo,
    parameter, reserved, targetProtocol);

  CComPtr<IInternetProtocolSink> sinkObject;
  CComPtr<IInternetBindInfo> bindInfoObject;
  if (SUCCEEDED(hr)) {
    hr = internetSink_.QueryInterface(&sinkObject);
    ATLASSERT(SUCCEEDED(hr) && sinkObject != 0);
  }
  if (SUCCEEDED(hr)) {
    hr = internetSink_.QueryInterface(&bindInfoObject);
    ATLASSERT(SUCCEEDED(hr) && bindInfoObject != 0);
  }
  if (SUCCEEDED(hr)) {
    hr = targetProtocol->Start(url, sinkObject, bindInfoObject, parameter,
      reserved);
  }
  return hr;
}

// ---------------------------------------------------------------------
// class InternetProtocol
// ---------------------------------------------------------------------

template <class StartPolicy>
inline InternetProtocol<StartPolicy>::InternetProtocol() :
  StartPolicy(GetUnknown()) {
}

// IInternetProtocolRoot
template <class StartPolicy>
inline STDMETHODIMP InternetProtocol<StartPolicy>::Start(
  LPCWSTR url, IInternetProtocolSink *outProtocolSink,
  IInternetBindInfo *outBindInfo, DWORD parameter, HANDLE_PTR reserved) {
  ATLASSERT(internetProtocol_ != 0);
  if (!internetProtocol_) {
    return E_UNEXPECTED;
  }
  internetSink_.setTargetWindow(targetWindow_);
 
  return StartPolicy::OnStart(url, outProtocolSink, outBindInfo, parameter,
    reserved, internetProtocol_);
}

} // !namespace facebook

#endif // PROTOCOLIMPL_INL

/**
* Facebook Internet Explorer Toolbar Software License 
* Copyright (c) 2009 Facebook, Inc. 
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (which, together with any graphical images included with such
* software, are collectively referred to below as the "Software") to (a) use,
* reproduce, display, distribute, execute, and transmit the Software, (b)
* prepare derivative works of the Software (excluding any graphical images
* included with the Software, which may not be modified or altered), and (c)
* permit third-parties to whom the Software is furnished to do so, all
* subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.  
*
* Facebook, Inc. retains ownership of the Software and all associated
* intellectual property rights.  All rights not expressly granted in this
* license are reserved by Facebook, Inc.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/ 

#include "StdAfx.h"
// #include "afxmt.h"
using namespace ATL;

#include "ClientService.h"
#include "ClientServiceImpl.h"

#import <msxml3.dll>  named_guids
#include "atlcore.h"

#include <iterator>
#include <deque>

#include "Wininet.h"

#include <boost/algorithm/string.hpp>
#include <boost/algorithm/string/erase.hpp>
#pragma warning(disable : 4180)
#include <boost/bind.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/noncopyable.hpp>


#include "ClientServiceMessages.h"

#include "communication/ResponseParser.h"
#include "communication/UpdatesComparator.h"

#include "../common/CommonConstants.h"

#include "../data/ServiceData.h"
#include "../data/NotificationsData.h"

#include "../util/BrowserUtils.h"
#include "../util/LogUtils.h"
#include "../util/ScopeGuard.h"
#include "../util/SessionUtils.h"
#include "../util/StringUtils.h"
#include "../util/RegistryUtils.h"
#include "../util/PtrUtils.h"
#include "../util/md5.h"


using boost::bind;
using boost::ref;
using namespace facebook;
using namespace std;
using namespace ATL;

extern ClientService* clientService;

namespace {

const DWORD UPDATE_TIMEOUT = 30000; // each 30 seconds

// this is a shared resources
// do not forget to synchronize 
// access to them!
ATL::CComCriticalSection facebookDataCritSect;
ServiceData _currentData;
ChangeEventsQueue _toolbarNotifications;
ChangeEventsQueue _popupSelfNotifications;
FriendsChangeEventsQueue _friendsChangesPopupNotifications;
EventsToAlbumsIDsQueue _albumsChanges;
}

//Note:  include communication service and loop 
// after declaring critical section facebookDataCritSect


#include "communication/CommunicationService.cpp"
#include "communication/CommunicationServiceLoop.cpp"

// ---------------------------------------------------------------------
// class ClientServiceImpl
// ---------------------------------------------------------------------

ClientServiceImpl::ClientServiceImpl():
  serviceLoop_(NULL),
  initialUpdate_(true) {
  const HRESULT initRes = facebookDataCritSect.Init();
  if (FAILED(initRes)) {
    _com_raise_error(initRes);
  }
  String result;
  loadSession(result);
  if (!result.empty()) {
   applySession(result);
  }
  startStoredSession();
}

ClientServiceImpl::~ClientServiceImpl() {
   // this will kill serviceLoop_
   // do not try to delete it
   if (serviceLoop_ != NULL) {
      serviceLoop_->postShutdown();
   }
}

void ClientServiceImpl::startStoredSession() {
  LOG4CPLUS_DEBUG(LogUtils::getLogger(), "ClientServiceImpl::startStoredSession");
  SessionInfo sessionInfo;
  const bool restoreRes = restoreSessionInfo(sessionInfo);
  if (!restoreRes) {
    return;
  }
  LOG4CPLUS_DEBUG(LogUtils::getLogger(), "ClientServiceImpl::startStoredSession loaded");
  std::auto_ptr<CommunicationService> communicator;
  communicator.reset(new CommunicationService(sessionInfo));

  const bool isSessionValid = communicator->isSessionStillValid();
  if (isSessionValid) { 
    startSession(communicator.release());
  } else {
    LOG4CPLUS_DEBUG(LogUtils::getLogger(), "ClientServiceImpl::startStoredSession session is invalid");
  }
}

void ClientServiceImpl::startSession(CommunicationService* communicator) {
   // This will start data retrieval thread 
   // Note, we don't own communicator anymore FacebookPeriodicalAsker
   // will take care of it's deallocation.
   const DWORD notifiedThreadID = GetCurrentThreadId();
   serviceLoop_ = new CommunicationServiceLoop(UPDATE_TIMEOUT, 
       communicator, notifiedThreadID);
}

void ClientServiceImpl::login(ULONG parentWindow) {
  if (isLoggedIn()) {
    return;
  }
  String cookie;
  std::auto_ptr<CommunicationService> communicator;
  communicator.reset(new CommunicationService);
  try {
    communicator->login(parentWindow, cookie);
  }
  catch(...) {
  }
   
  if (communicator->isLoggedIn()) {

    // we've logged in.lets try to get the process cookies
    _currentData.setLoginCookies(cookie);

    initialUpdate_ = true;

    clientService->Fire_dataUpdated(FBM_LOADING_DATA);

    storeSessionInfo(communicator->getSessionInfo());
      
    startSession(communicator.release());
  }
}

void ClientServiceImpl::logout() {
  if (serviceLoop_) {
    // this will kill serviceLoop_|
    // do not try to delete it
    serviceLoop_->postLogout();
    serviceLoop_ = 0;
    cleanUpCollectedData();
  }
  saveSession(_T(""));
  cleanupSessionInfo();
  clientService->Fire_dataUpdated(FBM_LOGOUT_INITIATED);
}

void ClientServiceImpl::setStatus(const String& statusString) {
  const XMLRequest setSatusRequest = 
     RequestsComposer::composeSetStatusRequest(statusString);

  serviceLoop_->postCustomRequest(setSatusRequest);
}

void ClientServiceImpl::setSession(const String& session) {
  if (session.empty()) {
    return;
  }
  // no need to set cookies if we are logged in
  if (isLoggedIn()) {
    return;
  }
  saveSession(session);
  applySession(session);

  // then try silent login
  login(0);
}

bool ClientServiceImpl::isLoggedIn() const{
  return (serviceLoop_ != NULL);
}

size_t ClientServiceImpl::getPokesCount() const{
  // lock on construction, unlock on destruction
  ScopeGuard fbCritSectGuard(
        bind(&CComCriticalSection::Lock, ref(facebookDataCritSect)),
        bind(&CComCriticalSection::Unlock, ref(facebookDataCritSect)));
 
  NotificationsData nftnDta = _currentData.getNotificationsData();
  return nftnDta.getPokesCount();
}

size_t ClientServiceImpl::getMessageCount() const{
  ScopeGuard fbCritSectGuard(
        bind(&CComCriticalSection::Lock, ref(facebookDataCritSect)),
        bind(&CComCriticalSection::Unlock, ref(facebookDataCritSect)));

  NotificationsData nftnDta = _currentData.getNotificationsData();
  return nftnDta.getMessageCount();
}

size_t ClientServiceImpl::getRequestsCount() const{
  ScopeGuard fbCritSectGuard(
        bind(&CComCriticalSection::Lock, ref(facebookDataCritSect)),
        bind(&CComCriticalSection::Unlock, ref(facebookDataCritSect)));

  NotificationsData nftnDta = _currentData.getNotificationsData();
  return nftnDta.getRequestsCount();
}

size_t ClientServiceImpl::getEventsCount() const{
  ScopeGuard fbCritSectGuard(
        bind(&CComCriticalSection::Lock, ref(facebookDataCritSect)),
        bind(&CComCriticalSection::Unlock, ref(facebookDataCritSect)));

  NotificationsData nftnDta = _currentData.getNotificationsData();
  return nftnDta.getEventsCount();
}

size_t ClientServiceImpl::getGroupsInvsCount() const{
  ScopeGuard fbCritSectGuard(
        bind(&CComCriticalSection::Lock, ref(facebookDataCritSect)),
        bind(&CComCriticalSection::Unlock, ref(facebookDataCritSect)));

  NotificationsData nftnDta = _currentData.getNotificationsData();
  return nftnDta.getGroupsInvsCount();
}

FriendsList ClientServiceImpl::getFriends() const{
  ScopeGuard fbCritSectGuard(
        bind(&CComCriticalSection::Lock, ref(facebookDataCritSect)),
        bind(&CComCriticalSection::Unlock, ref(facebookDataCritSect)));
  
  return _currentData.getFriends(); 
}

UserData ClientServiceImpl::getLoggedInUser() const{
  ScopeGuard fbCritSectGuard(
     bind(&CComCriticalSection::Lock, ref(facebookDataCritSect)),
     bind(&CComCriticalSection::Unlock, ref(facebookDataCritSect)));

  return _currentData.getLoggedInUser(); 
}

void ClientServiceImpl::cleanUpCollectedData() {
  ScopeGuard fbCritSectGuard(
     bind(&CComCriticalSection::Lock, ref(facebookDataCritSect)),
     bind(&CComCriticalSection::Unlock, ref(facebookDataCritSect)));

  _toolbarNotifications.clear();
  _friendsChangesPopupNotifications.clear();
  _albumsChanges.clear();
  _popupSelfNotifications.clear();
  ServiceData emptyData;
  _currentData = emptyData;
}

bool ClientServiceImpl::canChangeStatus() const{
  if (isNull( serviceLoop_ )) {
    return false;
  }
  // if communication thread is growing data
  // this call will wait till it complete
  return serviceLoop_->hasSetStatusPermission();
}

void ClientServiceImpl::updateView(ULONG changeId) {
  UNREFERENCED_PARAMETER(changeId);
  clientService->Fire_dataUpdated(FBM_UPDATE_VIEW);
}

void ClientServiceImpl::FireUpdates(ClientService* clientService) {
  ScopeGuard fbCritSectGuard(
     bind(&CComCriticalSection::Lock, ref(facebookDataCritSect)),
     bind(&CComCriticalSection::Unlock, ref(facebookDataCritSect)));

  // fire updates about my changes
  while(!_toolbarNotifications.empty()) {
    const DataChangeEvents eventID = _toolbarNotifications.front();
    _toolbarNotifications.pop_front();
    try{
      clientService->Fire_dataUpdated(eventID);
    }
    catch(...) {
    }
  
    if (!initialUpdate_) {
      showSelfNotification(eventID, _currentData);
    }
  }

  // fier notifications about self changes
  while(!_popupSelfNotifications.empty()) {
    const DataChangeEvents changeID = _popupSelfNotifications.front();
    _popupSelfNotifications.pop_front();
    showSelfNotification(changeID, _currentData);
  }

  // fire updates about my friends
  while(!_friendsChangesPopupNotifications.empty()) {
    const EventToFriendIDs eventToFriendIDs = _friendsChangesPopupNotifications.front();
    _friendsChangesPopupNotifications.pop_front();
    const DataChangeEvents changeID = eventToFriendIDs.first;
    const FriendsIDs friendsIDs = eventToFriendIDs.second;
    showFriendsChangePopup(changeID, friendsIDs, _currentData);
  }

  // fire updates about albums
  while(!_albumsChanges.empty()) {
    const EventsToAlbumsIDs eventToAlbumIDs = _albumsChanges.front();
    _albumsChanges.pop_front();
    const DataChangeEvents changeID = eventToAlbumIDs.first;
    const AlbumsIDs albumsIDs = eventToAlbumIDs.second;
    showAlbumsChangePopup(changeID, albumsIDs, _currentData);
  }

  initialUpdate_ = false;
} 

bool ClientServiceImpl::storeSessionInfo(const SessionInfo& sessionInfo) {
  RegStrEntry sessionKeyEntry(HKEY_CURRENT_USER, 
     kFacebookSessionPath, kSessionKeyEntryName, sessionInfo.sessionKey_);

  RegStrEntry sessionUserEntry(HKEY_CURRENT_USER, 
     kFacebookSessionPath, kSessionUserIdEntryName,  sessionInfo.uid_);
  
  RegStrEntry sessionExpireEntry(HKEY_CURRENT_USER, 
      kFacebookSessionPath, kSessionExpiresEntryName,  sessionInfo.expires_);

   RegStrEntry sessionSecretEntry(HKEY_CURRENT_USER, 
     kFacebookSessionPath, kSessionSecretEntryName,  sessionInfo.sessionSecret_);

  return sessionKeyEntry.write() && sessionUserEntry.write() && 
      sessionExpireEntry.write() && sessionSecretEntry.write();
}

bool ClientServiceImpl::restoreSessionInfo(SessionInfo& sessionInfo) {
  RegStrEntry sessionKeyEntry(HKEY_CURRENT_USER, 
     kFacebookSessionPath, kSessionKeyEntryName, _T(""));

  RegStrEntry sessionUserEntry(HKEY_CURRENT_USER, 
     kFacebookSessionPath, kSessionUserIdEntryName,  _T(""));

  RegStrEntry sessionExpireEntry(HKEY_CURRENT_USER, 
     kFacebookSessionPath, kSessionExpiresEntryName,  _T(""));

  RegStrEntry sessionSecretEntry(HKEY_CURRENT_USER, 
     kFacebookSessionPath, kSessionSecretEntryName,  _T(""));
  
  String sessionkey;
  if (!sessionKeyEntry.read() || 
       !sessionUserEntry.read() || 
       !sessionExpireEntry.read() ||
       !sessionSecretEntry.read()) {
     return false;
  }
  
  sessionInfo.sessionKey_ = sessionKeyEntry._value;
  sessionInfo.uid_ = sessionUserEntry._value;
  sessionInfo.expires_ = sessionExpireEntry._value;
  sessionInfo.sessionSecret_ = sessionSecretEntry._value;

  return true;
}

void ClientServiceImpl::cleanupSessionInfo() {
  RegStrEntry sessionKeyEntry(HKEY_CURRENT_USER, 
     kFacebookSessionPath, kSessionKeyEntryName, _T(""));

  RegStrEntry sessionUserEntry(HKEY_CURRENT_USER, 
     kFacebookSessionPath, kSessionUserIdEntryName,  _T(""));
  
  RegStrEntry sessionExpireEntry(HKEY_CURRENT_USER, 
     kFacebookSessionPath, kSessionExpiresEntryName,  _T(""));

  RegStrEntry sessionSecretEntry(HKEY_CURRENT_USER, 
     kFacebookSessionPath, kSessionSecretEntryName,  _T(""));

  sessionKeyEntry.removeKey();
  sessionUserEntry.removeKey();
  sessionExpireEntry.removeKey();
  sessionSecretEntry.removeKey();
}







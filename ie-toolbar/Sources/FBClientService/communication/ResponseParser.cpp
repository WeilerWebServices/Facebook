/**
* Facebook Internet Explorer Toolbar Software License 
* Copyright (c) 2009 Facebook, Inc. 
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (which, together with any graphical images included with such
* software, are collectively referred to below as the "Software") to (a) use,
* reproduce, display, distribute, execute, and transmit the Software, (b)
* prepare derivative works of the Software (excluding any graphical images
* included with the Software, which may not be modified or altered), and (c)
* permit third-parties to whom the Software is furnished to do so, all
* subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.  
*
* Facebook, Inc. retains ownership of the Software and all associated
* intellectual property rights.  All rights not expressly granted in this
* license are reserved by Facebook, Inc.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/ 

#include "StdAfx.h"
#include "ResponseParser.h"

#include "../../util/XMLUtils.h"

#include <boost/lexical_cast.hpp>

namespace facebook{
using namespace XMLUtils;
using boost::lexical_cast;

/* 
 * Server response parsing functins implementation
 * 
 * see http://wiki.developers.facebook.com/index.php/API
 * for an examples of a result xml
 */
namespace {

bool isNull( MSXML2::IXMLDOMNodePtr& node) {
   return XMLUtils::hodeHasAttribute(node, _T("nil"), _T("xsi"));
}

String getResponseErrorCode(MSXML2::IXMLDOMDocumentPtr& xmlResponse) {
    MSXML2::IXMLDOMNodePtr errorNode = xmlResponse->selectSingleNode("error_response");
    MSXML2::IXMLDOMNodePtr errorCodeNode = errorNode->selectSingleNode("error_code");
    if (errorCodeNode != NULL) {
       return XMLUtils::getNodeText(errorCodeNode); 
    }
    return _T("");
}

String getResponseErrorDescription(MSXML2::IXMLDOMDocumentPtr& xmlResponse) {
    MSXML2::IXMLDOMNodePtr errorNode = xmlResponse->selectSingleNode("error_response");
    MSXML2::IXMLDOMNodePtr errorDescrNode = errorNode->selectSingleNode("error_msg");
    if (errorDescrNode != NULL) {
       return XMLUtils::getNodeText(errorDescrNode); 
    }
    
    return _T("");
}

void raiseBadResponseError(MSXML2::IXMLDOMDocumentPtr& xmlResponse) {
   const String errorCode = getResponseErrorCode(xmlResponse);
   if (errorCode.empty()) {
      throw XMLUtils::ParseError();
   }

   const String errorDescr = getResponseErrorDescription(xmlResponse);
   if (errorCode.empty()) {
      throw XMLUtils::ParseError();
   }

   throw ResponseParser::ErrorInResponse(errorCode, errorDescr);
}


UsersIDs parseFriendsRequestsNode(MSXML2::IXMLDOMNodePtr& requestsNode) {

   UsersIDs result;
   MSXML2::IXMLDOMNodeListPtr children;
   const HRESULT getChildNodesRes = requestsNode->get_childNodes(&children);
   if (FAILED(getChildNodesRes)) {
      _com_raise_error(getChildNodesRes);
   }
   
   const size_t requestsCount = XMLUtils::getChildrenCount(requestsNode);

   for(size_t childNum = 0; childNum < requestsCount; ++ childNum) {
      MSXML2::IXMLDOMNodePtr uidNode;       
      const HRESULT getRequestResult = children->get_item(childNum, &uidNode);
      if (FAILED(getRequestResult)) {
         _com_raise_error(getRequestResult);
      }

      const String uid = XMLUtils::getNodeText(uidNode);

      result.push_back(uid);
   }

   return result;
}


UserData parseUser(MSXML2::IXMLDOMNodePtr& userNode) {
   const String uid = XMLUtils::getChildText(userNode, _T("uid"));
   const String name = XMLUtils::getChildText(userNode, _T("name"));

   MSXML2::IXMLDOMNodePtr statusNode = userNode->selectSingleNode("status");
   if (statusNode == NULL) {
      throw XMLUtils::ParseError();
   }

   UserData::Status status;

   try{
      status.message_  = XMLUtils::getChildText(statusNode, _T("message"));
      status.time_ = lexical_cast<size_t>(XMLUtils::getChildText(statusNode, _T("time")));
      status.id_  = XMLUtils::getChildText(statusNode, _T("status_id"));
   }
   catch (XMLUtils::ParseError&) {
      // do nothing
   }


   const String picSmall  =  XMLUtils::getChildText(userNode, _T("pic_small"));
   const String picSquare =  XMLUtils::getChildText(userNode, _T("pic_square"));
   const String wallCount =  XMLUtils::getChildText(userNode, _T("wall_count"));
   const String notesCount = XMLUtils::getChildText(userNode, _T("notes_count"));
   const String profileUpdateTime = XMLUtils::getChildText(userNode, _T("profile_update_time"));

   return  UserData(uid, name, status, picSmall, picSquare, 
      lexical_cast<size_t>(profileUpdateTime.empty() ? _T("0") : profileUpdateTime), 
      lexical_cast<size_t>(notesCount.empty() ? _T("0") : notesCount), 
      lexical_cast<size_t>(wallCount.empty() ? _T("0") : wallCount));
}


UsersList parseUsers(MSXML2::IXMLDOMNodePtr& usersNode) {
   UsersList result;

   MSXML2::IXMLDOMNodeListPtr children;
   const HRESULT getChildNodesRes = usersNode->get_childNodes(&children);
   if (FAILED(getChildNodesRes)) {
      _com_raise_error(getChildNodesRes);
   }

   LONG childrenCount = 0;
   const HRESULT getChildenCountRes = children->get_length(&childrenCount);
   if (FAILED(getChildenCountRes)) {
      _com_raise_error(getChildNodesRes);
   }

   for(int childNum = 0; childNum < childrenCount; ++ childNum) {
      MSXML2::IXMLDOMNodePtr friendNode;       
      const HRESULT getFriendNodeRes = children->get_item(childNum,&friendNode);
      if (FAILED(getFriendNodeRes)) {
         _com_raise_error(getFriendNodeRes);
      }

      const UserData userData = parseUser(friendNode);
      result.push_back(userData);
   }

   return result;
}

}

String ResponseParser::parseCreateTokenResp(const String& response) {
   MSXML2::IXMLDOMDocumentPtr xmlDoc(MSXML2::CLSID_DOMDocument);
   const variant_t xmlLoadRes = xmlDoc->loadXML(toBSTR(response.c_str()));
   if (xmlLoadRes.boolVal == VARIANT_FALSE)
      throw std::exception("failed to load xml");
  
   MSXML2::IXMLDOMNodePtr authNode = xmlDoc->selectSingleNode(_T("auth_createToken_response"));
   if (authNode == NULL) {
      raiseBadResponseError(xmlDoc);
   }

   return XMLUtils::getNodeText(authNode);
}

SessionInfo ResponseParser::parseCreateSessionResp(const String& response) {

  MSXML2::IXMLDOMDocumentPtr xmlDoc(MSXML2::CLSID_DOMDocument);
   const variant_t xmlLoadRes = xmlDoc->loadXML(_bstr_t(response.c_str()));
   if (xmlLoadRes.boolVal == VARIANT_FALSE) {
      throw std::exception("failed to load xml");
   }

   MSXML2::IXMLDOMNodePtr sessionRespNode = xmlDoc->selectSingleNode(_T("auth_getSession_response"));
   if (sessionRespNode == NULL) {
      raiseBadResponseError(xmlDoc);
   }

   MSXML2::IXMLDOMNodePtr sessionKeyNode = sessionRespNode->selectSingleNode(_T("session_key") );
   if (sessionKeyNode == NULL) {
      throw XMLUtils::ParseError();
   }
   const String sessionKey = XMLUtils::getNodeText(sessionKeyNode);

   MSXML2::IXMLDOMNodePtr uidNode = sessionRespNode->selectSingleNode(_T("uid") );
   if (uidNode == NULL) {
      throw XMLUtils::ParseError();
   }
   const String uid = XMLUtils::getNodeText(uidNode);

   MSXML2::IXMLDOMNodePtr expiresNode = sessionRespNode->selectSingleNode(_T("expires"));
   if (expiresNode == NULL) {
      throw XMLUtils::ParseError();
   }
   const String expires = XMLUtils::getNodeText(expiresNode);

   MSXML2::IXMLDOMNodePtr secretNode = sessionRespNode->selectSingleNode(_T("secret"));
   String secret;
   if (secretNode != NULL) {
     // no need of throw - we are in web mode, not application
     // throw XMLUtils::ParseError();
     secret = XMLUtils::getNodeText(secretNode);
   }
   return SessionInfo(sessionKey, uid, expires, secret);
}


NotificationsData ResponseParser::parseGetNotificationsDataResponse(const String& response) {
   using boost::lexical_cast;
   MSXML2::IXMLDOMDocumentPtr xmlDoc(MSXML2::CLSID_DOMDocument);
   const variant_t xmlLoadRes = xmlDoc->loadXML(_bstr_t(response.c_str()));
   if (xmlLoadRes.boolVal == VARIANT_FALSE) {
      throw std::exception("failed to load xml");
   }
   MSXML2::IXMLDOMNodePtr ntfnRespNode = xmlDoc->selectSingleNode(_T("notifications_get_response"));
   if (ntfnRespNode == NULL) {
      raiseBadResponseError(xmlDoc);
   }
   MSXML2::IXMLDOMNodePtr messagesNode = ntfnRespNode->selectSingleNode(_T("messages") );
   if (messagesNode == NULL) {
      throw XMLUtils::ParseError();
   }
   const String messageCount = XMLUtils::getChildText(messagesNode, _T("unread"));

   MSXML2::IXMLDOMNodePtr pokesNode = ntfnRespNode->selectSingleNode(_T("pokes") );
   if (messagesNode == NULL) {
      throw XMLUtils::ParseError();
   }
   const String pokesCount = XMLUtils::getChildText(pokesNode, _T("unread"));

   MSXML2::IXMLDOMNodePtr friendRequestsNode = ntfnRespNode->selectSingleNode(_T("friend_requests") );
   if (friendRequestsNode == NULL) {
      throw XMLUtils::ParseError();
   }
   UsersIDs usersRequestedFriendshipIDs = parseFriendsRequestsNode(friendRequestsNode);

   MSXML2::IXMLDOMNodePtr groupsInvitesNode = ntfnRespNode->selectSingleNode(_T("group_invites") );
   if (groupsInvitesNode == NULL) {
      throw XMLUtils::ParseError();
   }
   const size_t groupsInventationsCount = XMLUtils::getChildrenCount(groupsInvitesNode);

   MSXML2::IXMLDOMNodePtr eventEnvitesNode = ntfnRespNode->selectSingleNode(_T("event_invites") );
   if (eventEnvitesNode == NULL) {
      throw XMLUtils::ParseError();
   }
   const size_t eventInventationsCount = XMLUtils::getChildrenCount(eventEnvitesNode);

   return NotificationsData( lexical_cast<size_t>(pokesCount), 
         lexical_cast<size_t>(messageCount), 
         eventInventationsCount, groupsInventationsCount, 
         usersRequestedFriendshipIDs);
}


bool ResponseParser::parseHasPermissionResponse(const String& response) {
   MSXML2::IXMLDOMDocumentPtr xmlDoc(MSXML2::CLSID_DOMDocument);
   const variant_t xmlLoadRes = xmlDoc->loadXML(toBSTR(response));
   if (xmlLoadRes.boolVal == VARIANT_FALSE)
      throw std::exception("failed to load xml");

   MSXML2::IXMLDOMNodePtr hasPermResponseNode = 
      xmlDoc->selectSingleNode(_T("users_hasAppPermission_response"));
   if (hasPermResponseNode == NULL) {
      raiseBadResponseError(xmlDoc);
   }

   const String responseText = XMLUtils::getNodeText(hasPermResponseNode);
   return responseText == _T("1");
}


FriendsList ResponseParser::parseFriendsListResp(const String& response) {
   MSXML2::IXMLDOMDocumentPtr xmlDoc(MSXML2::CLSID_DOMDocument);
   const variant_t xmlLoadRes = xmlDoc->loadXML(_bstr_t(response.c_str()));
   if (xmlLoadRes.boolVal == VARIANT_FALSE) {
      throw std::exception("failed to load xml");
   }
   FriendsList res;
   MSXML2::IXMLDOMNodePtr fqlQueryResponse = xmlDoc->selectSingleNode(_T("fql_query_response"));
   if (fqlQueryResponse == NULL) {
      raiseBadResponseError(xmlDoc);
   }
   return parseUsers(fqlQueryResponse);
}



FriendsList ResponseParser::parseUsersInfoResp(const String& response) {
   MSXML2::IXMLDOMDocumentPtr xmlDoc(MSXML2::CLSID_DOMDocument);
   const variant_t xmlLoadRes = xmlDoc->loadXML(_bstr_t(response.c_str()));
   if (xmlLoadRes.boolVal == VARIANT_FALSE) {
      throw std::exception("failed to load xml");
   }
   FriendsList res;
   MSXML2::IXMLDOMNodePtr usersInfoResponse = 
      xmlDoc->selectSingleNode(_T("users_getInfo_response"));
   if (usersInfoResponse == NULL) {
      raiseBadResponseError(xmlDoc);
   }
   
   return parseUsers(usersInfoResponse);
}


AlbumsList ResponseParser::parseGetAlbumsResponse(
   const String& response, bool initialResponse) {
   AlbumsList albumsList;

   using boost::lexical_cast;
   MSXML2::IXMLDOMDocumentPtr xmlDoc(MSXML2::CLSID_DOMDocument);
   const variant_t xmlLoadRes = xmlDoc->loadXML(_bstr_t(response.c_str()));
   if (xmlLoadRes.boolVal == VARIANT_FALSE) {
      throw std::exception("failed to load xml");
   }

   MSXML2::IXMLDOMNodePtr fqlQueryResponse = xmlDoc->selectSingleNode(_T("fql_query_response"));
   if (fqlQueryResponse == NULL) {
      raiseBadResponseError(xmlDoc);
   }

   MSXML2::IXMLDOMNodeListPtr children;
   const HRESULT getChildNodesRes = fqlQueryResponse->get_childNodes(&children);
   if (FAILED(getChildNodesRes)) {
      _com_raise_error(getChildNodesRes);
   }

   LONG childrenCount = 0;
   const HRESULT getChildenCountRes = children->get_length(&childrenCount);
   if (FAILED(getChildenCountRes)) {
      _com_raise_error(getChildNodesRes);
   }

   for(int childNum = 0; childNum < childrenCount; ++ childNum) {
      MSXML2::IXMLDOMNodePtr albumNode;       
      const HRESULT getAlbumNodeRes = children->get_item(childNum,&albumNode);
      if (FAILED(getAlbumNodeRes)) 
         _com_raise_error(getAlbumNodeRes);

      const String id = XMLUtils::getChildText(albumNode, _T("aid"));

      const String owner = XMLUtils::getChildText(albumNode, _T("owner"));
      size_t modified = lexical_cast<size_t>(
         XMLUtils::getChildText(albumNode, _T("modified")));

      size_t size = lexical_cast<size_t>(
         XMLUtils::getChildText(albumNode, _T("size")));

      String link = _T("");
      String name = _T("");      

      if (!initialResponse) {

         name = lexical_cast<String>(
            XMLUtils::getChildText(albumNode, _T("name")));

         link = lexical_cast<String>(
            XMLUtils::getChildText(albumNode, _T("link")));
      }

      AlbumData albumData(id, owner, modified,  size, name, link);
      albumsList.push_back(albumData);
   }
   return albumsList;
}


// ---------------------------------------------------------------------
// class ErrorInResponse
// ---------------------------------------------------------------------

ResponseParser::
ErrorInResponse::ErrorInResponse(const String& code, const String& description) {
   try{
      code_ = boost::lexical_cast<int>(code);
      description_ = description;
   } catch(boost::bad_lexical_cast& ) {
      code_ = -1;
   }
}

String ResponseParser::ErrorInResponse::getDescr() const{ 
   return description_;
} 

int ResponseParser::ErrorInResponse::getCode() const{ 
   return code_;
}

} //!namespace facebook


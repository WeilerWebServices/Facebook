/**
* Facebook Internet Explorer Toolbar Software License 
* Copyright (c) 2009 Facebook, Inc. 
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (which, together with any graphical images included with such
* software, are collectively referred to below as the "Software") to (a) use,
* reproduce, display, distribute, execute, and transmit the Software, (b)
* prepare derivative works of the Software (excluding any graphical images
* included with the Software, which may not be modified or altered), and (c)
* permit third-parties to whom the Software is furnished to do so, all
* subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.  
*
* Facebook, Inc. retains ownership of the Software and all associated
* intellectual property rights.  All rights not expressly granted in this
* license are reserved by Facebook, Inc.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HcurrentERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/ 

#include "StdAfx.h"
#include "UpdatesComparator.h"

#include <algorithm>
#include <functional>

#pragma warning(disable : 4180)
#include <boost/bind.hpp>

namespace facebook{
using namespace std;
using boost::bind;


namespace {

const AlbumsList::const_iterator 
   findAlbum(const AlbumsList& albums, const String& albumID) {
   return find_if(albums.begin(), albums.end(),
      bind(equal_to<String>(), 
      bind(&facebook::AlbumData::id_, _1), 
      albumID));
}

template<typename TargetQueueType>
void putChangeToTargetQueue(const DataChangeEvents dataChangeID,
   const String& id,
   TargetQueueType& targetQueue) {
   TargetQueueType::iterator itEventID = 
      std::find_if(targetQueue.begin(), targetQueue.end(), 
      bind( equal_to<DataChangeEvents>(), 
      bind(&TargetQueueType::value_type::first, _1), 
      dataChangeID));

   if (itEventID != targetQueue.end()) {
      (*itEventID).second.push_back(id);
   } else {
      vector<String> ids;
      ids.push_back(id);

      const TargetQueueType::value_type changeToIDPair = 
         make_pair(dataChangeID, ids);

      targetQueue.push_back(changeToIDPair);
   }
}


FriendsList::const_iterator
   findFriend(const facebook::String& friendID, const facebook::FriendsList& friendsList) {
   return find_if(friendsList.begin(), friendsList.end(),
      bind(equal_to<String>(), 
      bind(&facebook::UserData::getID, _1), 
      friendID));
}

void putFriendChange(const DataChangeEvents dataChangeID,
   const String& userID, FriendsChangeEventsQueue& targetQueue) {
   putChangeToTargetQueue<FriendsChangeEventsQueue>(dataChangeID,
      userID, targetQueue);  
}

void putFriendChanges(const ChangeEventsQueue& eventsQueue,
   const String& userID, FriendsChangeEventsQueue& targetQueue) {
   using boost::ref; using boost::cref;
   for_each(eventsQueue.begin(), eventsQueue.end(), 
      bind(putFriendChange , _1, cref(userID), ref(targetQueue)));
}

ChangeEventsQueue analyzeFriendDifference(const UserData& newFriendData, 
                                          const UserData& currentFriendData) {
   ChangeEventsQueue friendChanges;

   if (newFriendData.getProfileUdatedTime() > currentFriendData.getProfileUdatedTime() ) {
      friendChanges.push_back(FBM_FRIEND_UPDATED_PROFILE);
   }

   if (newFriendData.getStatusMessage() !=  currentFriendData.getStatusMessage()) {
      friendChanges.push_back(FBM_FRIEND_UPDATED_STATUS);
   }

   if (newFriendData.getWallPostsCount() > currentFriendData.getWallPostsCount()) {
      friendChanges.push_back(FBM_SOMEONE_WROTE_ON_A_FRIENDS_WALL);
   }

   if (newFriendData.getNotesCount() > currentFriendData.getNotesCount()) {
      friendChanges.push_back(FBM_FRIEND_WROTE_NOTE);
   }

   return friendChanges;
}

} // namespace 



// ---------------------------------------------------------------------
// class UpdatesComparator
// ---------------------------------------------------------------------

ChangeEventsQueue UpdatesComparator::getSelfChanges(const ServiceData& newData, 
                                                     const ServiceData& currentData) {
  ChangeEventsQueue myChanges;

  const NotificationsData currentNotifications = currentData.getNotificationsData();
  const NotificationsData newNotifications = newData.getNotificationsData();
   
  if (newNotifications.getPokesCount() > currentNotifications.getPokesCount()) { 
    myChanges.push_back(FBM_I_HAVE_NEW_POKE);
  }
   
  if (newNotifications.getMessageCount() > currentNotifications.getMessageCount()) {
    myChanges.push_back(FBM_I_HAVE_NEW_MESSAGE);
  }

  if (newNotifications.getRequestsCount() > currentNotifications.getRequestsCount()) {
    myChanges.push_back(FBM_I_HAVE_NEW_FRIEND_REQUEST);
  }
   
  if (newNotifications.getEventsCount() > currentNotifications.getEventsCount()) {
    myChanges.push_back(FBM_I_HAVE_EVENT_NEW_INVINTAION);
  }
   
  if (newNotifications.getGroupsInvsCount() > currentNotifications.getGroupsInvsCount()) {
    myChanges.push_back(FBM_I_HAVE_NEW_GROUP_INVINTATION);
  }


  const UserData newloggedInUserData = newData.getLoggedInUser();
  const UserData currentLoggedInUserData = currentData.getLoggedInUser();
  if (newloggedInUserData.getWallPostsCount()  > currentLoggedInUserData.getWallPostsCount()) {
    myChanges.push_back(FBM_I_HAVE_NEW_WALL_POST);
  }


  return myChanges;
}


ChangeEventsQueue UpdatesComparator::getToolbarDataChanges(const ServiceData& newData, 
                                                           const ServiceData& currentData) {
   ChangeEventsQueue myChanges;

   ChangeEventsQueue res;
   const FriendsList currentFriends = currentData.getFriends();

   const NotificationsData currentNotifications = currentData.getNotificationsData();
   const NotificationsData newNotifications = newData.getNotificationsData();

   const FriendsList newFriends = newData.getFriends();

   bool friendUpdated = true;
   if (newFriends.size() == currentFriends.size()) {

      friendUpdated = !equal(newFriends.begin(), newFriends.end(),
         currentFriends.begin());
   }

   if (friendUpdated) { 
     myChanges.push_back(FBM_MY_FRIENDS_LIST_UPDATED);
   }
   
   if (currentNotifications.getPokesCount() != newNotifications.getPokesCount()) {
     myChanges.push_back(FBM_POKES_COUNT_UPDATED);
   }
   
   if (currentNotifications.getMessageCount() != newNotifications.getMessageCount()) {
     myChanges.push_back(FBM_MESSAGES_CONT_UPDATED);
   }
   
   if (currentNotifications.getRequestsCount() != newNotifications.getRequestsCount()) {
     myChanges.push_back(FBM_REQUESTS_COUNT_PDATED);
   }

   if (currentNotifications.getEventsCount()  != newNotifications.getEventsCount()) {
     myChanges.push_back(FBM_EVENTS_INVINTAIONS_COUNT_UPDATED);
   }

   if (currentNotifications.getGroupsInvsCount() != newNotifications.getGroupsInvsCount()) {
     myChanges.push_back(FBM_GROUPS_INVINTAIONS_COUNT_UPDATED);
   }
   
   const UserData newloggedInUserData = newData.getLoggedInUser();
   const UserData currentLoggedInUserData = currentData.getLoggedInUser();
   if (newloggedInUserData.getStatusMessage() != currentLoggedInUserData.getStatusMessage()) {
     myChanges.push_back(FBM_MY_STATUS_UPDATED);
   }

   return myChanges;
}

FriendsChangeEventsQueue UpdatesComparator::getFriendsChanges(
  const ServiceData& newData, const ServiceData& currentData) {
   FriendsChangeEventsQueue friendsChanges;
   
   const FriendsList newFriends = newData.getFriends();
   
   const FriendsList currentFriends = currentData.getFriends();

   FriendsList::const_iterator itFriends;
   const FriendsList::const_iterator itFriendsEnd = newFriends.end();
   
   for(itFriends = newFriends.begin();  itFriends != itFriendsEnd; ++itFriends) {
       const UserData& newFriendData = *itFriends;

       const FriendsList::const_iterator foundFriend =
         findFriend(newFriendData.getID(), currentFriends);
      
       if (foundFriend != currentFriends.end()) { // friend already existed

          const UserData& currentFriendData = *foundFriend;

          const ChangeEventsQueue friendChanges = 
               analyzeFriendDifference(newFriendData, currentFriendData);

          putFriendChanges(friendChanges, 
             currentFriendData.getID(), friendsChanges);

       } else { // new friend
         ChangeEventsQueue friendChange;
         friendChange.push_back(FBM_I_HAVE_NEW_FRIEND);
         putFriendChanges(friendChange, newFriendData.getID(),  friendsChanges);
       }
   }

   return friendsChanges;
}

EventsToAlbumsIDsQueue UpdatesComparator::getAlbumsChanges(
   const ServiceData& newData,
   const ServiceData& currentData) {
   const AlbumsList& newAlbums = newData.getAlbumsList();
   const AlbumsList& currentAlbums = currentData.getAlbumsList();

   EventsToAlbumsIDsQueue albumsChanges;
   AlbumsList::const_iterator itAlbums;
   const AlbumsList::const_iterator itAlbumsEnd = newAlbums.end();

   for (itAlbums = newAlbums.begin(); itAlbums != itAlbumsEnd; ++itAlbums) {
      const AlbumData& newAlbum = *itAlbums;  
      const AlbumsList::const_iterator foundAlbum = 
         findAlbum(currentAlbums, newAlbum.id_);

      if (foundAlbum != currentAlbums.end()) { // album already existed

         if (newAlbum.size_ >  (*foundAlbum).size_) {
            putChangeToTargetQueue<EventsToAlbumsIDsQueue>(
               FBM_FRIEND_ADDED_PHOTO_TO_ALBUM, newAlbum.id_, albumsChanges);
         }

      } else { // new album

         putChangeToTargetQueue<EventsToAlbumsIDsQueue>(
            FBM_FRIEND_CREATED_ALBUM, newAlbum.id_, albumsChanges);
      }
   }

   return albumsChanges;
}

} //!namespace facebook
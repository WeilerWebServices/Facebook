/**
* Facebook Internet Explorer Toolbar Software License 
* Copyright (c) 2009 Facebook, Inc. 
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (which, together with any graphical images included with such
* software, are collectively referred to below as the "Software") to (a) use,
* reproduce, display, distribute, execute, and transmit the Software, (b)
* prepare derivative works of the Software (excluding any graphical images
* included with the Software, which may not be modified or altered), and (c)
* permit third-parties to whom the Software is furnished to do so, all
* subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.  
*
* Facebook, Inc. retains ownership of the Software and all associated
* intellectual property rights.  All rights not expressly granted in this
* license are reserved by Facebook, Inc.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/ 

#include "StdAfx.h"
#include "IESidebar.h"

#include "../resource.h"
#include "../../common/ToolbarMessages.h"

#include "../system/ClassIds.h"
#include "../system/ClientServiceConnection.h"
#include "../system/ObjectsServer.h"
#include "../system/UserDataObserver.h"
#include "../system/RuntimeContext.h"

#include "../../common/DataChangeEvents.h"

#include "../../common/ResourceMessages.h"

#include "../../util/BrowserUtils.h"
#include "../../util/LogUtils.h"

const SIZE facebook::IESidebar::kMinSidebarSize = {10, 10};
const SIZE facebook::IESidebar::kMaxSidebarSize = {-1, -1};

namespace facebook{

// ---------------------------------------------------------------------
// class IESidebar
// ---------------------------------------------------------------------

IESidebar::IESidebar():
   objRefsCount_(0),
   site_(0),
   parentWindow_(),
   sidebarWindow_(),
   bandId_((DWORD)-1) {
  LOG4CPLUS_DEBUG(LogUtils::getLogger(), _T("IESidebar::IESidebar"));
  ObjectsServer::lock();
  ResourceMessages::subscribeObserver(this);
}


IESidebar::~IESidebar() {
  LOG4CPLUS_DEBUG(LogUtils::getLogger(), _T("IESidebar::~IESidebar"));
  undockFromSite();
  UserDataObserver::releaseInstance();
  ResourceMessages::unsubscribeObserver(this);

  ObjectsServer::unlock();
}


STDMETHODIMP IESidebar::QueryInterface(REFIID interfaceId,
      LPVOID* interfacePointer) {
  *interfacePointer = 0;

  if (IsEqualIID(IID_IUnknown, interfaceId)) {
      *interfacePointer = static_cast<IUnknown*>(
         static_cast<IDeskBand*>(this));
   } else if (IsEqualIID(IID_IOleWindow, interfaceId)) {
      *interfacePointer = static_cast<IOleWindow*>(this);
   } else if (IsEqualIID(IID_IDockingWindow, interfaceId)) {
      *interfacePointer = static_cast<IDockingWindow*>(this);
   } else if (IsEqualIID(IID_IInputObject, interfaceId)) {
      *interfacePointer = static_cast<IInputObject*>(this);
   } else if (IsEqualIID(IID_IObjectWithSite, interfaceId)) {
      *interfacePointer = static_cast<IObjectWithSite*>(this);
   }else if (IsEqualIID(IID_IDeskBand, interfaceId)) {
      *interfacePointer = static_cast<IDeskBand*>(this);
   } else if (IsEqualIID(IID_IPersist, interfaceId)) {
      *interfacePointer = static_cast<IPersist*>(this);
   } else if (IsEqualIID(IID_IPersistStream, interfaceId)) {
      *interfacePointer = static_cast<IPersistStream*>(this);
   }else if (IsEqualIID(IID_IContextMenu, interfaceId)) {
      *interfacePointer = static_cast<IContextMenu*>(this);
   }   

   if (*interfacePointer) {
      reinterpret_cast<IUnknown*>(*interfacePointer)->AddRef();
      return S_OK;
   }

   return E_NOINTERFACE;
}


STDMETHODIMP_(DWORD) IESidebar::AddRef() {
  //LOG4CPLUS_DEBUG(LogUtils::getLogger(), _T("IESidebar::AddRef count=") << objRefsCount_);
  return ++objRefsCount_;
}


STDMETHODIMP_(DWORD) IESidebar::Release() {
  //LOG4CPLUS_DEBUG(LogUtils::getLogger(), _T("IESidebar::Release count=") << objRefsCount_);
  if (--objRefsCount_ == 0) {
    delete this;
    return 0;
  }

  return objRefsCount_;
}


STDMETHODIMP IESidebar::GetWindow(HWND* window) {
  *window = sidebarWindow_.GetSafeHwnd();

  return S_OK;
}


STDMETHODIMP IESidebar::ContextSensitiveHelp(BOOL) {
  return E_NOTIMPL;
}


STDMETHODIMP IESidebar::ShowDW(BOOL show) {
  if (!RuntimeContext::getToolbar()) {
    return S_OK;
  }
  //LOG4CPLUS_DEBUG(LogUtils::getLogger(), "IESidebar::ShowDW show = " << show);
  if (show == TRUE) {
    sidebarWindow_.ShowWindow(SW_SHOW);
    RuntimeContext::getToolbar()->sidebarIsOpen();
    sidebarWindow_.refresh(RuntimeContext::getToolbar()->getState() == IEToolbar::TS_USER_LOGGED_IN);
  } else {
    sidebarWindow_.ShowWindow(SW_HIDE);
    RuntimeContext::getToolbar()->sidebarIsClosed();
  }
  return S_OK;
}


STDMETHODIMP IESidebar::CloseDW(DWORD) {
   return S_OK;
}


STDMETHODIMP IESidebar::ResizeBorderDW(LPCRECT, IUnknown*, BOOL) {
  return E_NOTIMPL;
}


STDMETHODIMP IESidebar::GetBandInfo(DWORD bandId, DWORD, DESKBANDINFO* bandInfo) {
  if (!bandInfo) {
    return E_INVALIDARG;
  }
  bandId_ = bandId;
  DWORD& infoMask = bandInfo->dwMask;

  if (infoMask & DBIM_MINSIZE) {
     bandInfo->ptMinSize.x = kMinSidebarSize.cx;
     bandInfo->ptMinSize.y = kMinSidebarSize.cy;
  }

  if (infoMask & DBIM_MAXSIZE) {
    bandInfo->ptMaxSize.x = kMaxSidebarSize.cx;
    bandInfo->ptMaxSize.y = kMaxSidebarSize.cy;
  }

  if (infoMask & DBIM_INTEGRAL) {
    bandInfo->ptIntegral.x = 1;
    bandInfo->ptIntegral.y = 1;
  }

  if (infoMask & DBIM_ACTUAL) {
    bandInfo->ptActual.x = 0;
    bandInfo->ptActual.y = 0;
  }

  if (infoMask & DBIM_TITLE) {
    lstrcpyW(bandInfo->wszTitle, 
      ResourceMessages::getMessage(kSidebarFacebookSidebar).c_str());
  }

  if (infoMask & DBIM_MODEFLAGS) {
    bandInfo->dwModeFlags = DBIMF_NORMAL;
    bandInfo->dwModeFlags |= DBIMF_VARIABLEHEIGHT;
  }

  if (infoMask & DBIM_BKCOLOR) {
      // Use the default background color by removing this flag.
    infoMask &= ~DBIM_BKCOLOR;
  }

  return S_OK;
}


STDMETHODIMP IESidebar::UIActivateIO(BOOL fActivate, LPMSG) {
  if (fActivate) {
    sidebarWindow_.SetFocus();
  }

  return S_OK;
}


STDMETHODIMP IESidebar::HasFocusIO(void) {
   return S_OK;
}


STDMETHODIMP IESidebar::TranslateAcceleratorIO(LPMSG) {
   return S_OK;
}


STDMETHODIMP IESidebar::SetSite(IUnknown* site) {
  try{
    if(site) {
      dockToSite(site);
    } else {
      undockFromSite();
      return S_OK;
    }
  } catch(_com_error& e) {
      return e.Error();
  }catch(...) {
      return E_FAIL;
  }

  return S_OK;
}


STDMETHODIMP IESidebar::GetSite(REFIID interfaceId, LPVOID* interfacePtr) {
  *interfacePtr = 0;

  if (site_) {
      return site_->QueryInterface(interfaceId, interfacePtr);
  }
  
  return E_FAIL;
}


STDMETHODIMP IESidebar::GetClassID(LPCLSID classId) {
  *classId = CLSID_IESidebar;
  
  return S_OK;
}

STDMETHODIMP IESidebar::IsDirty(void) {
  return S_FALSE;
}


STDMETHODIMP IESidebar::Load(LPSTREAM) {
  return S_OK;
}


STDMETHODIMP IESidebar::Save(LPSTREAM, BOOL) {
   return S_OK;
}


STDMETHODIMP IESidebar::GetSizeMax(ULARGE_INTEGER*) {
  return E_NOTIMPL;
}


STDMETHODIMP IESidebar::QueryContextMenu(HMENU, UINT, UINT, UINT, UINT) {
  return E_NOTIMPL;
}


STDMETHODIMP IESidebar::InvokeCommand(CMINVOKECOMMANDINFO*) {
  return E_NOTIMPL;
}


STDMETHODIMP IESidebar::GetCommandString(UINT_PTR, UINT, UINT*, LPSTR, UINT) {
  return E_NOTIMPL;
}


void IESidebar::postMessage(DWORD Code, WPARAM wParam, LPARAM lParam) {
  sidebarWindow_.PostMessage(Code, wParam, lParam);
}


IWebBrowser2Ptr IESidebar::getParentBrowser() const {
  return browser_;
}


HWND IESidebar::getSidebarWindow() const {
  return sidebarWindow_.GetSafeHwnd();
}


void IESidebar::dockToSite(IUnknown* sitePtr) {
  IUnknownPtr site(sitePtr);

  IOleWindowPtr siteOLEWindow;
  const HRESULT getOleWindowResult = 
    site.QueryInterface(IID_IOleWindow, &siteOLEWindow);

  if (FAILED(getOleWindowResult)) {
    _com_raise_error(getOleWindowResult);
  }

  HWND hParentWindow;
  const HRESULT getParentWindowResult = siteOLEWindow->GetWindow(&hParentWindow);
  if (FAILED(getParentWindowResult)) {
       _com_raise_error(getParentWindowResult);
  }
   
  siteOLEWindow.Release();

  const HRESULT  getSiteResult = site->QueryInterface(IID_IInputObjectSite, 
         (LPVOID*)&site_);

  if (FAILED(getParentWindowResult)) {
    _com_raise_error(getSiteResult);
  }

  const HRESULT getBrwoserRes = BrowserUtils::getWebBrowser(site, browser_);
  if (FAILED(getBrwoserRes)) {
    _com_raise_error(getBrwoserRes);
  }

  parentWindow_.Attach(hParentWindow);

  createSidebarWindow();

  initialUpdateSidebarWindow();
}

void IESidebar::initialUpdateSidebarWindow() {
  //LOG4CPLUS_DEBUG(LogUtils::getLogger(), "IESidebar::initialUpdateSidebarWindow");
  sidebarWindow_.refresh(UserDataObserver::getInstance().isLoggedIn());
}


void IESidebar::createSidebarWindow() {
  CRect clientRect;
  ASSERT(parentWindow_);
  parentWindow_.GetClientRect(clientRect);

  sidebarWindow_.CreateEx(WS_EX_STATICEDGE, 
    0, 0, WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN, clientRect, 
    &parentWindow_, AFX_IDW_PANE_FIRST);

  RuntimeContext::storeSidebar(*this);
}


void IESidebar::undockFromSite() {
  parentWindow_.Detach();

  releaseSite();

  destroySidebarWindow();
}


void IESidebar::releaseSite() {
  if(site_) {
    site_->Release();
    site_ = 0;
  }
}

void IESidebar::releaseParentWindow() {
  parentWindow_.Detach();
}

void IESidebar::destroySidebarWindow() {
  sidebarWindow_.DestroyWindow();
}

void IESidebar::updateView(int changeId) {
  UNREFERENCED_PARAMETER(changeId);
  if (bandId_ == (DWORD)(-1)) {
    return;
  }
  // force the band to be refreshed
  IOleCommandTarget* pOleCommandTarget;
  if(SUCCEEDED(this->GetSite(IID_IOleCommandTarget, (LPVOID*)&pOleCommandTarget))) {
    pOleCommandTarget->Exec(&CGID_DeskBand, DBID_BANDINFOCHANGED, bandId_, NULL, NULL);
    pOleCommandTarget->Release();
  }
}

}// !namespace facebook
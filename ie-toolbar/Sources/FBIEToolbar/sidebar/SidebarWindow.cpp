/**
* Facebook Internet Explorer Toolbar Software License 
* Copyright (c) 2009 Facebook, Inc. 
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (which, together with any graphical images included with such
* software, are collectively referred to below as the "Software") to (a) use,
* reproduce, display, distribute, execute, and transmit the Software, (b)
* prepare derivative works of the Software (excluding any graphical images
* included with the Software, which may not be modified or altered), and (c)
* permit third-parties to whom the Software is furnished to do so, all
* subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.  
*
* Facebook, Inc. retains ownership of the Software and all associated
* intellectual property rights.  All rights not expressly granted in this
* license are reserved by Facebook, Inc.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/

#include "StdAfx.h"
#include "SidebarWindow.h"

#include <limits>
#include <boost/assign/list_inserter.hpp>

#include "../resource.h"

#include "../toolbar/ToolbarSettingsDlg.h"
#include "../system/RuntimeContext.h"
#include "../system/UserDataObserver.h"

#include "../../common/ToolbarMessages.h"
#include "../../common/CommonConstants.h"

#include "../../util/Error.h"
#include "../../util/HtmlUtils.h"
#include "../../common/ResourceMessages.h"
#include "../../util/LogUtils.h"
#include "../../util/RegistryUtils.h"
#include "../../util/ShellUtils.h"

namespace facebook{

// ---------------------------------------------------------------------
// class SidebarWindow
// ---------------------------------------------------------------------

IMPLEMENT_DYNAMIC(SidebarWindow, CWnd)

const size_t SidebarWindow::kFriendsListButtonsHeight = 20;
const size_t SidebarWindow::kFriendsListButtonsTopIdent = 5;

#undef min
#undef max

const size_t SidebarWindow::kInvalidItemIndex 
   = std::numeric_limits<size_t>::max();

const size_t sortModeToResID(const SortMode sortMode) {
   // initialize resource SortMode to reource identifiers map
   typedef std::map<SortMode, size_t> SortModeToResIDMap;
   static SortModeToResIDMap sortModeToResID;
   if (sortModeToResID.empty()) {
     boost::assign::insert( sortModeToResID )
                          ( SORT_BY_NAME, ID_SORT_NAME )
                          ( SORT_BY_LAST_UPDATE_TIME, ID_SORT_LAST_UPDATE_TIME)
                          ( SORT_BY_STATUS_UPDATE_TIME, ID_SORT_STATUS_UPDATE_TIME)
                          ( SORT_BY_PROFILE_UPDATE_TIME, ID_SORT_PROFILE_UPDATE_TIME);
   }
   
   const SortModeToResIDMap::const_iterator itResID = sortModeToResID.find(sortMode);
   if (itResID == sortModeToResID.end()) {
      throw Error(" invalid sort mode specified");
   }
   
   return (*itResID).second;
}


SidebarWindow::SidebarWindow() :
   friendsView_(NULL),
   activeSortMode_(SORT_BY_NAME),
   settingsButtonIndex_(kInvalidItemIndex),
   sortButtonIndex_(kInvalidItemIndex),
   isVisible_(false) {
   DWORD sortMode = static_cast<DWORD>(SORT_BY_NAME);
   RegistryUtils::readDword(HKEY_CURRENT_USER, 
      kToolbarSettingsRegistryPath, kFriendListSortMode, sortMode, SORT_BY_NAME);
  activeSortMode_ = static_cast<SortMode>(sortMode);
   loadSortMenu(sortMenu_);
   //ResourceMessages::subscribeObserver(this);
}

SidebarWindow::~SidebarWindow() {
   // do not try to delete 
   // friends view here 
   // it will be done by 
   // CView::PostNcDestroy()
  //ResourceMessages::unsubscribeObserver(this);
}

CRect SidebarWindow::calculateFriendsViewRect(const CRect& clientRect) const{
   const CPoint leftTop(clientRect.left, clientRect.top);
   const CSize originalSize(clientRect.Width(), clientRect.Height());  
   const CSize htmlViewSize(originalSize.cx, originalSize.cy -
      kFriendsListButtonsHeight - kFriendsListButtonsTopIdent);

   return CRect(leftTop, htmlViewSize);
}

CRect SidebarWindow::calculateToolbarRect(const CRect& friendsViewRect, 
                                          const CRect& clientRect) const{
   CRect res;
   res.SubtractRect(clientRect, friendsViewRect);
   return res;
}

void SidebarWindow::createFriendsView() {
   const CRect zerroRect(0,0,0,0); 
   friendsView_ = new SidebarHtmlView();
   const BOOL createRes = friendsView_->Create(0, 0, 
      WS_CHILD | WS_VISIBLE , zerroRect, this, AFX_IDW_PANE_FIRST);
   if (!createRes) {
      throw Error("failed to created friends view"); 
   }
}


void SidebarWindow::createButtonsToolbar() {
   settingsSortToolbar_.create(*this);
   
   settingsButtonIndex_ = appendSettingsButton();

   settingsSortToolbar_.appendDynamicSpacer();

   sortButtonIndex_ = appendSortButton();
}

const size_t SidebarWindow::appendSettingsButton() {
   TBBUTTON buttonDefn = {0};
   buttonDefn.fsStyle =  BTNS_BUTTON | BTNS_AUTOSIZE | BTNS_SHOWTEXT;
   buttonDefn.fsState = TBSTATE_ENABLED;
   buttonDefn.idCommand = IDC_TBI_SETTINGS;
   buttonDefn.iBitmap = 0;

   const size_t buttonIndex = settingsSortToolbar_.appendButton(buttonDefn);

   settingsSortToolbar_.setItemImageToNone(buttonIndex);
   
   return buttonIndex;
}

const size_t SidebarWindow::appendSortButton() {
   TBBUTTON buttonDefn = {0};
   buttonDefn.fsStyle = BTNS_WHOLEDROPDOWN | BTNS_AUTOSIZE | BTNS_SHOWTEXT;
   buttonDefn.fsState = TBSTATE_ENABLED;
   buttonDefn.idCommand = IDC_TBI_SORT_BY;

   const size_t buttonIndex = settingsSortToolbar_.appendButton(buttonDefn);

   settingsSortToolbar_.setItemImageToNone(buttonIndex);

   return buttonIndex;
}

String SidebarWindow::getSortButtonText() const{
   String res;
   switch(activeSortMode_) {

   case SORT_BY_LAST_UPDATE_TIME:
     res = ResourceMessages::getMessage(kSidebarSortingByLastUpdate);
     break;
   case SORT_BY_STATUS_UPDATE_TIME: 
     res = ResourceMessages::getMessage(kSidebarSortingByStatus);
     break;
   case SORT_BY_PROFILE_UPDATE_TIME:
     res = ResourceMessages::getMessage(kSidebarSortingByProfile);
     break;
   case SORT_BY_NAME:
   default:
      res = ResourceMessages::getMessage(kSidebarSortingByName);
      break;
   }
   return res;
}

void SidebarWindow::changeSortMode(const SortMode& newSortMode) {
   friendsView_->changeSortMode(newSortMode);
   
   activeSortMode_ = newSortMode;
   
   const String sortButtonText = _T("    ") + getSortButtonText();
   settingsSortToolbar_.setItemText(sortButtonIndex_, sortButtonText);
   RegistryUtils::writeDword(HKEY_CURRENT_USER, 
      kToolbarSettingsRegistryPath, kFriendListSortMode, newSortMode);
}

void SidebarWindow::changeFilter(const String& filter) {
   friendsView_->changeFilter(filter);
}

void SidebarWindow::loggedOut() {
  //LOG4CPLUS_DEBUG(LogUtils::getLogger(), "SidebarWindow::loggedOut");
  friendsView_->loggedOut();
}

void SidebarWindow::loading() {
  //LOG4CPLUS_DEBUG(LogUtils::getLogger(), "SidebarWindow::loading");
  friendsView_->loading();
}

void SidebarWindow::loaded(const FriendsList& friendsList) {
 // LOG4CPLUS_DEBUG(LogUtils::getLogger(), "SidebarWindow::loaded");
  friendsView_->loaded(friendsList, false);
  friendsView_->changeSortMode(activeSortMode_);
}

void SidebarWindow::refresh(bool loggedin) {
  //LOG4CPLUS_DEBUG(LogUtils::getLogger(), 
 //   "SidebarWindow::refresh current state = " << 
 //   friendsView_->getViewState() <<
 //   ", new state = " << loggedin <<
 //   ", is currently visible = " << RuntimeContext::isSidebarOpened());
  switch (friendsView_->getViewState()) {
    case SidebarHtmlView::VS_LOADING_FRIENDS:
      break;
    case SidebarHtmlView::VS_INITIAL:
    case SidebarHtmlView::VS_WAIT_LOGIN:{
      if (loggedin) {
        loading();
        UserDataObserver::getInstance().getFriends();
      } else {
        loggedOut();
      }
      break;
    }
    case SidebarHtmlView::VS_FRIENDS_LOADED:{
      if (!loggedin) {
        loggedOut();
      }
      break;
    }
  }
}

BEGIN_MESSAGE_MAP(SidebarWindow, CWnd)
  ON_WM_CREATE()
  ON_WM_SIZE()
  ON_BN_CLICKED(IDC_TBI_SETTINGS, onSettingsButtonClicked)
  ON_COMMAND(ID_SORT_LAST_UPDATE_TIME, onSortByLastUpdateTime)
  ON_COMMAND(ID_SORT_STATUS_UPDATE_TIME, onSortByStatusUpdateTime)
  ON_COMMAND(ID_SORT_PROFILE_UPDATE_TIME, onSortByProfileUpdateTime)
  ON_COMMAND(ID_SORT_NAME, onSortByName)
  ON_MESSAGE(TBM_FILTER_CHANGED, onChangeFriendsFilter)
  ON_MESSAGE(TBM_CUSTOM_KEY_PRESSED, onNavigationKeyPressed)
  ON_MESSAGE(TBM_DATA_CHANGED, onDataChanged)
  ON_MESSAGE(TBM_GET_SIDEBAR_FOCUSED, onGetSidebarFocused)
  ON_WM_SHOWWINDOW()
END_MESSAGE_MAP()


int SidebarWindow::OnCreate(LPCREATESTRUCT createStructure)
{
  CWnd::OnCreate(createStructure);

  createFriendsView();
     
  createButtonsToolbar();

  updateView();

  return 0;
}

void SidebarWindow::OnSize(UINT type, int newWidth, int newHeight) {
  CWnd::OnSize(type, newWidth, newHeight);
  
  if (!friendsView_->GetSafeHwnd() || !settingsSortToolbar_.GetSafeHwnd()) {
    return;
  }

  CRect clientRect;
  GetClientRect(clientRect);

  const CRect friendsViewRect = calculateFriendsViewRect(clientRect);
  const CRect toolbarRect = calculateToolbarRect(friendsViewRect, clientRect);

  settingsSortToolbar_.MoveWindow(toolbarRect);
  friendsView_->MoveWindow(friendsViewRect);
}

void SidebarWindow::onSettingsButtonClicked() {
  ToolbarSettingsDlg dlg(GetParent());
  dlg.DoModal();
}

LRESULT SidebarWindow::onChangeFriendsFilter(WPARAM, LPARAM lParam) {
  std::auto_ptr<String> filterText(reinterpret_cast<String*>(lParam));
  friendsView_->changeFilter(encodeCharEntities(*filterText));
  return 0;
}

void SidebarWindow::onSortByName() {
  changeSortMode(SORT_BY_NAME);
}

void SidebarWindow::onSortByLastUpdateTime() {
  changeSortMode(SORT_BY_LAST_UPDATE_TIME);
}

void SidebarWindow::onSortByStatusUpdateTime() {
  changeSortMode(SORT_BY_STATUS_UPDATE_TIME);
}

void SidebarWindow::onSortByProfileUpdateTime() {
  changeSortMode(SORT_BY_PROFILE_UPDATE_TIME);
}

LRESULT SidebarWindow::onNavigationKeyPressed(WPARAM wParam, LPARAM lParam) {
  // handle special keys for the javascript
  BOOL result = FALSE;
  if (friendsView_->isWindowOurDescendant((HWND)lParam) ||
    isWindowOurDescendant((HWND)lParam) ) {
      TRACE(_T("SidebarWindow::onNavigationKeyPressed\n"));
    friendsView_->translateKeyCodeToJS(wParam);
    result = TRUE;
  }
  return result;
}

bool SidebarWindow::isWindowOurDescendant(const HWND descendantCandidate) const{
  if (GetSafeHwnd() == descendantCandidate) {
    return true;
  }
  CWnd* childWindow = GetWindow(GW_CHILD);
  while(childWindow != NULL) {
    if (childWindow->GetSafeHwnd() == descendantCandidate) {
        return true;
    }
    if (!IsWindow(childWindow->GetSafeHwnd())) {
      return false;
    }
    childWindow = childWindow->GetWindow(GW_CHILD);
  }
  return false;
}

LRESULT SidebarWindow::onGetSidebarFocused(WPARAM wParam, LPARAM lParam) {
  UNREFERENCED_PARAMETER(lParam);
  BOOL result = FALSE;
  if (isWindowOurDescendant((HWND)wParam)) {
    result = TRUE;
  }
  return result;
}

BOOL SidebarWindow::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) {
  // we are interesting in catching TBN_DROPDOWN
  LPNMHDR notifyData = reinterpret_cast<LPNMHDR>(lParam);
  if (notifyData->code == TBN_DROPDOWN) {
    CMenu* sortSubMenu = sortMenu_.GetSubMenu(1);
    if (!sortSubMenu)
      throw Error("Failed to get sort submenu\n");

    //get all the menu items in the current culture
    for (unsigned int index = 0; index < sortSubMenu->GetMenuItemCount(); ++index) {
      ToolbarWindow::updateItem(sortSubMenu, index);
    }

    const UINT trackFlags = TPM_BOTTOMALIGN | TPM_LEFTALIGN | TPM_RIGHTBUTTON;
    CRect sortButtonRect = settingsSortToolbar_.getItemRect(
      sortButtonIndex_);

    settingsSortToolbar_.MapWindowPoints(0, &sortButtonRect);

    sortSubMenu->CheckMenuRadioItem(ID_SORT_LAST_UPDATE_TIME, ID_SORT_NAME,
      sortModeToResID(activeSortMode_) , MF_BYCOMMAND);

    // Determine if MS Windows is right aligned and get position of the sort button
    // depending on it
    int x = isBiDi(LOCALE_SYSTEM_DEFAULT) ? sortButtonRect.right : sortButtonRect.left;
    const BOOL trackResult = sortSubMenu->TrackPopupMenu(trackFlags,
      x, sortButtonRect.top, this);

    if (FALSE == trackResult)
      throw Error("Failed to track sort menu\n");

    *pResult = TBDDRET_DEFAULT;

    return TRUE;
  }
  // catch the dynamic separator redraw 
  if (notifyData->code == NM_CUSTOMDRAW) {
    return onToolbarCustomDraw((LPNMTBCUSTOMDRAW)(lParam),*pResult);
  }

  return CWnd::OnNotify(wParam, lParam, pResult);
}

bool SidebarWindow::onToolbarCustomDraw(LPNMTBCUSTOMDRAW messageInfo,
                                    LRESULT& lResult) {
  if (messageInfo->nmcd.dwDrawStage == CDDS_PREPAINT) {
    lResult = CDRF_NOTIFYITEMDRAW;
    return true;
  }

  if (messageInfo->nmcd.dwDrawStage == CDDS_POSTPAINT) {
    lResult = CDRF_DODEFAULT;
    return true;
  }

  if (messageInfo->nmcd.dwDrawStage == CDDS_ITEMPREPAINT) {
    lResult = CDRF_NOTIFYPOSTPAINT;
    return true;
  }

  if (messageInfo->nmcd.dwDrawStage == CDDS_ITEMPOSTPAINT) {
    // refresh layout on dynamic separator redraw - it may drop our resize
    if (messageInfo->nmcd.dwItemSpec == IDC_TBI_SEPARATOR) {
      settingsSortToolbar_.refreshLayout();
    }
  }
  return false;
}

void SidebarWindow::OnShowWindow(BOOL bShow, UINT nStatus) {
  UNREFERENCED_PARAMETER(nStatus);
  isVisible_ = (bShow == TRUE);
  //LOG4CPLUS_DEBUG(LogUtils::getLogger(), "SidebarWindow::OnShowWindow Show = " << bShow << " status = " << nStatus);
}


LRESULT SidebarWindow::onDataChanged(WPARAM wParam, LPARAM) {
  bool visible = RuntimeContext::isSidebarOpened() || isVisible_;
  //do *not* process data updates if sidebar is closed
  switch(wParam) {
    case FBM_LOADING_DATA:
    break;
   case FBM_JUST_LOGGED_IN:
   case FBM_MY_FRIENDS_LIST_UPDATED:
     if (visible) {
       loaded(
         UserDataObserver::getInstance().getFriends(false));
     }
     break;
   case FBM_LOGOUT_INITIATED:
     loggedOut(); 
     break;
   case FBM_UPDATE_VIEW:
       updateView();
     break;
  }

  return visible ? TRUE : FALSE;
}

void SidebarWindow::loadSortMenu(CMenu& menu) const{
  const BOOL loadResult = menu.LoadMenu(IDR_MENU_POPUP);
  if (FALSE == loadResult) {
    throw Error("Failed to load sort menu\n");
  }
}

void SidebarWindow::updateView(int changeId) {
  UNREFERENCED_PARAMETER(changeId);

  SetWindowText(ResourceMessages::getMessage(kSidebarFacebookSidebar).c_str());
  settingsSortToolbar_.setItemText(settingsButtonIndex_, 
    _T("   ") + ResourceMessages::getMessage(kSidebarSettings));

  settingsSortToolbar_.setItemText(sortButtonIndex_, 
    _T("    ") + getSortButtonText());

  //if (RuntimeContext::isSidebarOpened() && isVisible_) {
    friendsView_->renderHtml();
  //}
}

} //!namespace facebook
/**
* Facebook Internet Explorer Toolbar Software License 
* Copyright (c) 2009 Facebook, Inc. 
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (which, together with any graphical images included with such
* software, are collectively referred to below as the "Software") to (a) use,
* reproduce, display, distribute, execute, and transmit the Software, (b)
* prepare derivative works of the Software (excluding any graphical images
* included with the Software, which may not be modified or altered), and (c)
* permit third-parties to whom the Software is furnished to do so, all
* subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.  
*
* Facebook, Inc. retains ownership of the Software and all associated
* intellectual property rights.  All rights not expressly granted in this
* license are reserved by Facebook, Inc.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/

#include "StdAfx.h"
#include "ToolbarEdit.h"

#include "../../util/Error.h"
#include "../../common/ResourceMessages.h"
#include "../../util/PtrUtils.h"
#include "../../util/WndUtils.h"

namespace facebook {

// ---------------------------------------------------------------------
// class ToolbarEdit
// ---------------------------------------------------------------------


const int verticalTextOffset = 0;

IMPLEMENT_DYNAMIC(ToolbarEdit, CEdit)


// message map declaration ...

BEGIN_MESSAGE_MAP(ToolbarEdit, CEdit)
   ON_WM_CREATE()
   ON_WM_SETFOCUS()
   ON_WM_KILLFOCUS()
   ON_WM_KEYDOWN()
   ON_WM_NCCALCSIZE()
   ON_WM_NCPAINT()
   ON_WM_CTLCOLOR_REFLECT()
END_MESSAGE_MAP()


ToolbarEdit::ToolbarEdit():
   promptText_(),
   promptFont_(),
   promptColor_() {
   backBrush_.CreateSolidBrush(GetSysColor(COLOR_WINDOW));
   ResourceMessages::subscribeObserver(this);
}


ToolbarEdit::~ToolbarEdit() {
   backBrush_.DeleteObject();
   ResourceMessages::unsubscribeObserver(this);
}


int ToolbarEdit::OnCreate(LPCREATESTRUCT createStructure) {
  if (BaseType::OnCreate(createStructure) == -1) {
    return -1;
  }
  return 0;
}


void ToolbarEdit::OnSetFocus(CWnd* oldWindow) {
  TRACE(_T("*** ToolbarEdit::OnSetFocus\n ")); 
  BaseType::OnSetFocus(oldWindow);
  if(noTextEntered()) {
    enterDefaultText();
  }

  notifyParent(NM_SETFOCUS);
}

void ToolbarEdit::OnKillFocus(CWnd* newWindow) {
  TRACE(_T("*** ToolbarEdit::OnKillFocus\n ")); 
  removeTextIfDefault();
  Invalidate(TRUE);
  BaseType::OnKillFocus(newWindow); 
  // notify parent only in the case we lose focus to another window
  // not the same child
  // or if we want to kill focus
  if (!newWindow || !newWindow->GetParent() ||
    newWindow->GetParent() != GetParent()) {
    //notifyParent(NM_KILLFOCUS);
  }
}

void ToolbarEdit::KillFocus() {
  SendMessage(WM_KILLFOCUS);
  notifyParent(NM_KILLFOCUS);
  //::SetFocus(GetParent()->GetSafeHwnd());
}

CWnd* getNextChild(CWnd* currentWindow, UINT orientation) {
  CWnd* result = NULL;
  if (!currentWindow) {
    return result;
  }
  do {
    result = currentWindow->GetNextWindow(orientation);
    if (!result) {
       currentWindow = currentWindow->GetParent();
    } else {
      break;
    }
  }
  while (currentWindow);
  return result;
}

void ToolbarEdit::OnKeyDown(UINT character, UINT repeatCount, UINT flags) {
  
  if (VK_TAB == character) {  
    SHORT res = GetAsyncKeyState(VK_CONTROL);
    if (res < 0) {
    } else {
      const bool shiftPressed = GetKeyState(VK_SHIFT) < 0;

      CWnd* nextChild = getNextChild(this, shiftPressed ? GW_HWNDPREV : GW_HWNDNEXT);
      if (!isNull(nextChild)) {
           nextChild->SetFocus();
      } else {
          KillFocus();
      }
    }
  }
  
  BaseType::OnKeyDown(character, repeatCount, flags);
}

void ToolbarEdit::OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp) {
  SendMessage(WM_SETFONT, (WPARAM)(HFONT)GetStockObject(DEFAULT_GUI_FONT), FALSE);

  UNREFERENCED_PARAMETER(bCalcValidRects);
   
  lpncsp->rgrc[0].top += kTopTextOffset;
  lpncsp->rgrc[0].bottom -= 1;
  
  if(isNull(symbolBitmap_)) {
    lpncsp->rgrc[0].left += kLeftTextOffset;
  }else {
    const CSize symbolSize = getSymbolSize();
    lpncsp->rgrc[0].left += 8 + symbolSize.cx;
  }
  lpncsp->rgrc[0].right -= kLeftTextOffset;
}

void ToolbarEdit::OnNcPaint() {
  Default();
  CWindowDC dc(this);
  CRect rectWnd = getFormattingRect(*this);

  if(isNull(symbolBitmap_)) {

    //recalculate the client reclangle
    CRect clientArea;
    GetClientRect(clientArea);

    if (rectWnd.Width() < clientArea.Width()) {
      rectWnd.InflateRect(0, 0, clientArea.Width() - rectWnd.Width(), 0);       
    }
    rectWnd.InflateRect(-1, -1, 8, 8);

    // fill all other with background color
    dc.FillSolidRect(rectWnd, GetSysColor(COLOR_WINDOW));
   } else {
    const CSize symbolSize = getSymbolSize();
    const CPoint symbolPos(kLeftTextOffset, kTopTextOffset);
    rectWnd.InflateRect(-1, -1, 12 + symbolSize.cx, 8);
    dc.FillSolidRect(rectWnd, GetSysColor(COLOR_WINDOW));
    CDC memoryContext;
    memoryContext.CreateCompatibleDC(&dc);
    memoryContext.SetMapMode(dc.GetMapMode());

    memoryContext.SelectObject(getPtr(symbolBitmap_));

    dc.BitBlt(symbolPos.x, symbolPos.y, 
      symbolPos.x + symbolSize.cx,
      symbolPos.y + symbolSize.cy, 
      &memoryContext, 0, 0, SRCCOPY);
      
    ReleaseDC(&memoryContext);
  }
  Invalidate();

}

HBRUSH ToolbarEdit::CtlColor(CDC* pDC, UINT nCtlColor) {
  UNREFERENCED_PARAMETER(nCtlColor);
  HBRUSH hbr = NULL;
  if(shouldDrawPrompt()) {
    CBrush brBkgnd;
    backBrush_.DeleteObject();
    backBrush_.CreateSolidBrush(GetSysColor(COLOR_WINDOW));
    hbr = (HBRUSH)backBrush_; // Passing a Handle to the Brush
    pDC->SetTextColor(promptColor_);
    pDC->SetBkColor(GetSysColor(COLOR_WINDOW));
  }
  return hbr;
}

BOOL ToolbarEdit::PreCreateWindow(CREATESTRUCT& createStruct) {
  createStruct.style |= ES_MULTILINE | ES_AUTOHSCROLL | WS_TABSTOP;
  createStruct.dwExStyle |= WS_EX_STATICEDGE;
  return BaseType::PreCreateWindow(createStruct);
}

String ToolbarEdit::getEnteredText() const {
  const CString text = getWindowText(*this);
  return String(text.GetString());
}


void ToolbarEdit::setText(const String& text) {
  if (text.empty()) {
    SetWindowText(promptText_.c_str());
  } else {
    SetWindowText(text.c_str());
  }
  Invalidate();
}

void ToolbarEdit::setPromptText(const String& text) {
  promptText_ = text;
  
  Invalidate();
}

String ToolbarEdit::getPromptText() const {
   return promptText_;
}


void ToolbarEdit::setPromptColor(const COLORREF color) {
  promptColor_ = color;

  Invalidate();
}


void ToolbarEdit::setPromptFont(const facebook::FontPtr font) {
  promptFont_ = font;

  Invalidate();
}


void ToolbarEdit::setDefaultText(const String& text) {
  defaultText_ = text;
  if (!text.empty()) {
    defaultText_ += _T(" ");
  }
  Invalidate();
}


ToolbarEdit::Margins ToolbarEdit::getMargins() const {
  const DWORD margins = GetMargins();
  return std::make_pair(LOWORD(margins), HIWORD(margins));
}


bool ToolbarEdit::noTextEntered() const {
  const String enteredText = getWindowText(*this);
  
  return (enteredText == promptText_ || enteredText.empty());
}

bool ToolbarEdit::shouldDrawPrompt() const {
  return noTextEntered() && !hasFocus(*this);
}


void ToolbarEdit::notifyParent(const UINT code) const {
  NMHDR nmh;
  nmh.code = code;
  nmh.idFrom = GetDlgCtrlID();
  nmh.hwndFrom = m_hWnd;

  CWnd* const parent = GetParent();
  if (isNull(parent)) {
    throw Error("Failed to get parent window\n");
  }

  parent->SendMessage(WM_NOTIFY, WPARAM(m_hWnd), LPARAM(&nmh));
}


void ToolbarEdit::enterDefaultText() {
  setWindowText(*this, defaultText_);

  scrollToCurLineEnd();
}

void ToolbarEdit::removeTextIfDefault() {
  const String enteredText = getWindowText(*this);

  if (enteredText.empty() || enteredText == defaultText_) {
    setWindowText(*this, promptText_);
  }
}


void ToolbarEdit::scrollToCurLineEnd() {
  const unsigned int selectPostion = LineLength(- 1);

  SetSel(selectPostion, selectPostion, TRUE);
}

void ToolbarEdit::setSymbolBitmap(const BitmapPtr bitmap) {
  symbolBitmap_ = bitmap;

  Invalidate();
}

CSize ToolbarEdit::getSymbolSize() const {
  if (isNull(symbolBitmap_)) {
      return CSize();
  } else {
    return getBitmapSize(symbolBitmap_);
  }
}

} //!namespace facebook

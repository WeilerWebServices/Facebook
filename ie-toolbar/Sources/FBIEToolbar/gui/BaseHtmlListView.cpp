/**
* Facebook Internet Explorer Toolbar Software License 
* Copyright (c) 2009 Facebook, Inc. 
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (which, together with any graphical images included with such
* software, are collectively referred to below as the "Software") to (a) use,
* reproduce, display, distribute, execute, and transmit the Software, (b)
* prepare derivative works of the Software (excluding any graphical images
* included with the Software, which may not be modified or altered), and (c)
* permit third-parties to whom the Software is furnished to do so, all
* subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.  
*
* Facebook, Inc. retains ownership of the Software and all associated
* intellectual property rights.  All rights not expressly granted in this
* license are reserved by Facebook, Inc.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/ 

#include "StdAfx.h"
#include "BaseHtmlListView.h"

#include <windows.h>

#pragma warning(disable : 4146)
#pragma warning(disable : 4278) 

#include <boost/algorithm/string.hpp>
#include <boost/bind.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string/replace.hpp>

#include "../FriendListXmlBuilder.h"
#include "../resource.h"
#include "../XslLangCache.h"

#include "../system/ClassIds.h"
#include "../system/RuntimeContext.h"
#include "../system/UserDataObserver.h"

#include "../../common/CommonConstants.h"
#include "../../common/ResourceMessages.h"
#include "../../common/UrlUtils.h"

#include "../../util/BrowserUtils.h"
#include "../../util/ComWrappers.h"
#include "../../util/ModuleUtils.h"
#include "../../util/JavaScriptUtils.h"

#include "../../util/LogUtils.h"
#include "../../util/ResourceUtils.h"
#include "../../util/ScopeGuard.h"
#include "../../util/StringUtils.h"
#include "../../util/XMLUtils.h"
#include "../../util/XSLTUtils.h"

namespace facebook{

using boost::bind;
using namespace std;
    

// ---------------------------------------------------------------------
// class BaseHtmlListView
// ---------------------------------------------------------------------

BEGIN_MESSAGE_MAP(BaseHtmlListView, GenericHtmlView)
END_MESSAGE_MAP()

BaseHtmlListView::BaseHtmlListView()  : 
   sortMode_(SORT_BY_NAME),
   fullFriendsList_(),
   filter_(_T("")),
   viewState_(VS_INITIAL),
   longListLoaded_(false) {
}

BaseHtmlListView::BaseHtmlListView(ActionHandler actionHandler):
                           GenericHtmlView(actionHandler),
                           sortMode_(SORT_BY_NAME),
                           fullFriendsList_(),
                           filter_(_T("")),
                           viewState_(VS_WAIT_LOGIN) {   
}
         

BaseHtmlListView::~BaseHtmlListView() {
}


BaseHtmlListView::ViewState BaseHtmlListView::getViewState() const {
   return viewState_;
}

void BaseHtmlListView::changeSortMode(const SortMode& sortMode) {
   sortMode_ = sortMode;
   renderHtml();
}

void BaseHtmlListView::changeFilter(const String& filter,bool needReload) {
  filter_ = filter;
  if (needReload) {
    renderHtml();
  }
}


String BaseHtmlListView::getXsl() {
  friendsXSL_ = XslLangCache::Instance()->getXsl(getFriendsListXslResource(), _T("XSLT"));

  return friendsXSL_;
}

bool BaseHtmlListView::isLongListLoaded() const {  
  return longListLoaded_;
}

void BaseHtmlListView::renderHtml() {
   // generate html and write it to the HtmlView
   writeHtml(getHTMLDoc() ,getListHtml());
}

String BaseHtmlListView::getListHtml() {
  using boost::replace_all;
  // result html to write to browser
  String result; 
  longListLoaded_ = false;  // html template for messages
  String messageHtml = loadStringFromResources(IDR_MESSAGE_VIEW, 
    RT_HTML);

  // message to put into html template
  String message;

  // action related to message to put into html template
  String action;

  // if not logged in - show "Login..." message
  if (viewState_ == VS_WAIT_LOGIN || viewState_ == VS_INITIAL) {
    message = ResourceMessages::getMessage(kHtmlLoginFromTheToolbar);
    action = kPleaseLogin;
  } else if (viewState_ == VS_LOADING_FRIENDS) { 
    // for loading state.... show "Loading...." message
    message = ResourceMessages::getMessage(kHtmlLoadingFriendsList);
    action = kLoadingFriendsList;
  } else if (viewState_ == VS_FRIENDS_LOADED) {
    // when friends list is loaded, analyze list 
    // according to the following rules:
    
    // create copy of friend list to process sorting and apply filter 
    FriendsList friendsToShow = fullFriendsList_;
    applyFilter(friendsToShow, filter_);
    applySort(friendsToShow, sortMode_);

    // handle situations when friends list is empty...
    if(friendsToShow.empty()) {

      //if we are not searching then "No friends to show...." 
      if(filter_.empty()) {
        message = ResourceMessages::getMessage(kHtmlNoFriendsToShow);
        action = kNoFriendToShow;
      } else{
        // otherwise lets look for friend on web site....
        message = ResourceMessages::getMessage(kHtmlPressEnterToFindFriend);
        action = kPressEnterToFindFriend;

        replace_all(message, _T("{1}"), filter_);

        // change the filter to not include ' and \

        replace_all(filter_, _T("'"), _T("@app:quat;"));
        replace_all(filter_, _T("\\"), _T("@app:slash;"));
        replace_all(filter_, _T("\""), _T("@app:dquat;"));

        replace_all(action, _T("%s"), filter_);
      } 
    } else if (!isCustomHtmlView(friendsToShow, result)) {
      // sidebar and search popup handles some list states, lets  delegate 
      // corresponding work to them
      // otherwise generate html based on processed friends list 
      const String friendsXML = FriendsListXmlBuilder::friendsToXml(friendsToShow); 
      result = XSLTUtils::generateHtml(getXsl(), friendsXML);
      longListLoaded_ = true;  
    }
  }
  
  if (result.empty()) {
    replace_all(messageHtml, _T("@message"), message);
    replace_all(messageHtml, _T("@action"), action);

    result = messageHtml;
  }

  return result;
}

bool BaseHtmlListView::isCustomHtmlView(const FriendsList &friendsToShow, 
                                                  String &result) {
  UNREFERENCED_PARAMETER(friendsToShow);
  UNREFERENCED_PARAMETER(result);
  return false;
}


void  BaseHtmlListView::loaded(const FriendsList& friendsList, 
                               const bool needRefresh) {
  fullFriendsList_ = friendsList;
  viewState_ = VS_FRIENDS_LOADED;
  if (needRefresh) {
    renderHtml();
  }
}


void BaseHtmlListView::loggedOut() {
  if (viewState_ == VS_WAIT_LOGIN) {
    return;
  }
   viewState_ = VS_WAIT_LOGIN;
   renderHtml();
}

void BaseHtmlListView::loading() {
  viewState_ = VS_LOADING_FRIENDS;
  renderHtml();
}

void BaseHtmlListView::processBrowserCommand(const String& commandURL, bool needEncode) {
   using namespace boost;
   String changedCommand = commandURL;
   if (isCustomAction(changedCommand)) {
     changedCommand.erase(0, kCustomActionPrefix.size());
   }

   // cleanup utility symbols
   String parsedString = changedCommand;
   // replace items back ()were replaced in BaseHtmlListView::getListHtml()
   replace_all(parsedString, _T("@app:quat;"), _T("'"));
   replace_all(parsedString, _T("@app:dquat;"), _T("\""));
   replace_all(parsedString, _T("@app:slash;"), _T("\\"));

   erase_all(parsedString, _T("@"));
   erase_all(parsedString, _T(":"));
   trim(parsedString);


   // extract page name and userID
   std::vector<String> commandParts;
   split(commandParts, parsedString, boost::is_any_of(_T("_")));

   const String page = commandParts[0];
   const String userID = commandParts[1];
   // get additional parameters if any
   String additionalParams;
   if (commandParts.size() > 2) {
      additionalParams = _T("&") + commandParts[2];
   }
   
   // use current browser to perform action from the list

   IWebBrowser2Ptr browser = RuntimeContext::getBrowser();
   BrowserUtils::navigate(browser, buildActionURL(page,  userID, needEncode) + additionalParams);
}

String BaseHtmlListView::getViewAction(String url) {
  const String kMessagePrefix = _T("app");
  if (url.find(kMessagePrefix) == 0) {
    return url.substr(kMessagePrefix.size());
  } else {
    return _T("");
  }
}


bool BaseHtmlListView::translateKeyCodeToJS(const UINT keyCode) {
   CStringArray emptyParams;
   CComPtr<IHTMLDocument2>  htmlDoc = getHTMLDoc();
   switch (keyCode) {
   case VK_UP:
      callJSFunc(htmlDoc, _T("externalKeyUp"), emptyParams);
      break;
   case VK_DOWN:
      callJSFunc(htmlDoc, _T("externalKeyDown"), emptyParams);
      break;
   case VK_HOME:
      callJSFunc(htmlDoc, _T("externalKeyHome"), emptyParams);
      break;
   case VK_END:
      callJSFunc(htmlDoc, _T("externalKeyEnd"), emptyParams);
      break;
   case VK_NEXT:
      callJSFunc(htmlDoc, _T("externalKeyPgDown"), emptyParams);
      break;
   case VK_PRIOR:
      callJSFunc(htmlDoc, _T("externalKeyPgUp"), emptyParams);
      break;
   case VK_RETURN:
      callJSFunc(htmlDoc, _T("externalKeyReturn"), emptyParams);
      break;
   case VK_SPACE:
      callJSFunc(htmlDoc, _T("externalKeySpace"), emptyParams);
      break;
   default:
     return false;
      // nothing to translate
      break;
   }
   return true;
}

bool BaseHtmlListView::isWindowOurDescendant(const HWND descendantCandidate) const{
   CWnd* childWindow = GetWindow(GW_CHILD);
   while(childWindow != 0) {
      if (childWindow->m_hWnd == descendantCandidate) {
          return true;
      }
      childWindow = childWindow->GetWindow(GW_CHILD);
   }
   return false;
}

BOOL BaseHtmlListView::LoadFromResource(int resourceID) {
   String resourceHtml = loadStringFromResources(resourceID, RT_HTML);

   writeHtml(getHTMLDoc(), resourceHtml);
   return true;
}

void BaseHtmlListView::processContent(String& content) {
  using boost::replace_all;

  // handle default path variable from resources: 
  
  //processing {toolbar-css-path}
  int toolbarCssId = IDR_TOOLBAR_CSS;
  if (ResourceMessages::isTextRightAligned()) {
    toolbarCssId = IDR_TOOLBAR_CSS_RTL;
  }

  String resourceUrl = buildHtmlResourceUrl(getModuleFileName(AfxGetInstanceHandle()), 
    toolbarCssId);
   
  replace_all(content, _T("@toolbar-css-path"), resourceUrl);

  //processing {toolbar-js-path}
  resourceUrl = buildHtmlResourceUrl(getModuleFileName(AfxGetInstanceHandle()), 
    IDR_TOOLBAR_JS);
   
  replace_all(content, _T("@toolbar-js-path"), resourceUrl);

  //processing {lib-js-path}
  resourceUrl = buildHtmlResourceUrl(getModuleFileName(AfxGetInstanceHandle()), 
    IDR_LIB_JS);
   
  replace_all(content, _T("@lib-js-path"), resourceUrl);

}


}

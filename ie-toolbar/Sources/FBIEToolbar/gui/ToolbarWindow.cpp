/**
* Facebook Internet Explorer Toolbar Software License 
* Copyright (c) 2009 Facebook, Inc. 
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (which, together with any graphical images included with such
* software, are collectively referred to below as the "Software") to (a) use,
* reproduce, display, distribute, execute, and transmit the Software, (b)
* prepare derivative works of the Software (excluding any graphical images
* included with the Software, which may not be modified or altered), and (c)
* permit third-parties to whom the Software is furnished to do so, all
* subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.  
*
* Facebook, Inc. retains ownership of the Software and all associated
* intellectual property rights.  All rights not expressly granted in this
* license are reserved by Facebook, Inc.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/

#include "StdAfx.h"
#include "ToolbarWindow.h"

#include <limits>
#include <boost/lexical_cast.hpp>
#include <boost/shared_array.hpp>

#include "../resource.h"

#include "../../common/ResourceMessages.h"
#include "../../common/ToolbarMessages.h"
#include "../../util/Error.h"
#include "../../util/GdiUtils.h"
#include "../../util/PtrUtils.h"
#include "../../util/WndUtils.h"

#undef min
#undef max


using namespace facebook;

// ---------------------------------------------------------------------
// class ToolbarWindow
// ---------------------------------------------------------------------


IMPLEMENT_DYNAMIC(ToolbarWindow, CToolBar)


BEGIN_MESSAGE_MAP(ToolbarWindow, CToolBar)
   ON_WM_CREATE()
   ON_WM_DESTROY()
   ON_WM_SIZE()
   ON_WM_SETFOCUS()
   ON_WM_KILLFOCUS()
   ON_NOTIFY_RANGE(NM_SETFOCUS, 0, (WORD)(-1), OnNmSetFocus) 
   ON_NOTIFY_RANGE(NM_KILLFOCUS, 0, (WORD)(-1), OnNmKillFocus) 
   ON_WM_CLOSE()
END_MESSAGE_MAP()

// static fields initialization
const size_t ToolbarWindow::invalidItemIndex_ =
      std::numeric_limits<size_t>::max();


ToolbarWindow::ToolbarWindow():
   dynamicSpacerIndex_(invalidItemIndex_),
   buttonsImageList_(),
   hotButtonsImageList_() {
}

ToolbarWindow::~ToolbarWindow() {
}


int ToolbarWindow::OnCreate(LPCREATESTRUCT createStructure) {
  if (BaseType::OnCreate(createStructure) == -1) {
    return -1;
  }

  return 0;
}

void ToolbarWindow::OnDestroy() {
}

void ToolbarWindow::OnSize(UINT type, int newWidth, int newHeight) {
   UNREFERENCED_PARAMETER(type);
   UNREFERENCED_PARAMETER(newHeight);
   resize(newWidth);
}

void ToolbarWindow::OnSetFocus(CWnd* const oldWindow) {
  if (oldWindow && oldWindow->GetParent() == this) {
    return;  // don't activate if we come from our children
  }
  CWnd* firstChild = GetWindow(GW_CHILD);
  if (firstChild) {
    firstChild->SetFocus();
  }
}

void ToolbarWindow::OnKillFocus(CWnd* const newWindow) {
  BaseType::OnKillFocus(newWindow);
   TRACE(_T("*** ToolbarWindow::OnKillFocus\n "));
}

void ToolbarWindow::OnNmSetFocus(UINT id, NMHDR* messageHdr, LRESULT* lResult) {
  UNREFERENCED_PARAMETER(id);
  UNREFERENCED_PARAMETER(lResult);
  CWnd* const parent = GetParent();
  if (isNull(parent)) {
     throw Error("Failed to get parent window\n");
  }
  parent->SendNotifyMessage(WM_NOTIFY, WPARAM(GetDlgCtrlID()), LPARAM(messageHdr));
}

void ToolbarWindow::OnNmKillFocus(UINT id, NMHDR* messageHdr, LRESULT* lResult) {
  UNREFERENCED_PARAMETER(id);
  UNREFERENCED_PARAMETER(lResult);
  CWnd* const parent = GetParent();
  if (isNull(parent)) {
     throw Error("Failed to get parent window\n");
  }
  parent->SendNotifyMessage(WM_NOTIFY, WPARAM(GetDlgCtrlID()), LPARAM(messageHdr));
}

void ToolbarWindow::OnClose() {
}

void ToolbarWindow::create(CWnd& parentWindow) {
  const DWORD windowStyles = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN |
        WS_TABSTOP | CBRS_ALIGN_TOP;

  const DWORD controlStyles =
        TBSTYLE_FLAT | TBSTYLE_LIST | TBSTYLE_TRANSPARENT | TBSTYLE_TOOLTIPS;
         
  const DWORD controlExStyles = WS_EX_CONTROLPARENT |
        TBSTYLE_EX_DRAWDDARROWS | TBSTYLE_EX_MIXEDBUTTONS;
   
  const BOOL createResult = CreateEx(&parentWindow, controlStyles,
        windowStyles);
  if (FALSE == createResult) {
     throw Error("Failed to create toolbar window\n");
  } 
  GetToolBarCtrl().SetExtendedStyle(controlExStyles);
}


size_t ToolbarWindow::appendButton(const TBBUTTON& buttonDefn) {
  CToolBarCtrl& toolbarCtrl = GetToolBarCtrl();

  TBBUTTON copy(buttonDefn);
  const BOOL insertResult = toolbarCtrl.InsertButton(-1, &copy);
  if (FALSE == insertResult) {
     throw Error("Failed to append button to toolbar\n");
  }

  return toolbarCtrl.GetButtonCount() - 1;
}


size_t ToolbarWindow::appendSeparator() {
  TBBUTTON buttonDefn = {0};
  buttonDefn.fsStyle = BTNS_SEP;
  
  return appendButton(buttonDefn);
}


size_t ToolbarWindow::appendFixedSpacer(const size_t space) {
  const size_t separatorIndex = appendSeparator();

  setItemWidth(separatorIndex, space);

  return separatorIndex;
}


size_t ToolbarWindow::appendDynamicSpacer() {

  TBBUTTON buttonDefn = {0};
  buttonDefn.fsStyle = BTNS_BUTTON | BTNS_SHOWTEXT;
  buttonDefn.fsState = 0;
  buttonDefn.idCommand = IDC_TBI_SEPARATOR;
  buttonDefn.iBitmap = -1;

  dynamicSpacerIndex_ = appendButton(buttonDefn);
  setItemText(dynamicSpacerIndex_, _T(""));
  
  return dynamicSpacerIndex_;
}


CRect ToolbarWindow::getItemRect(const size_t itemIndex) const {
  CRect itemRect;
  GetItemRect(itemIndex, &itemRect);
   
  return itemRect;
}


CRect ToolbarWindow::getControlItemRect(const size_t itemIndex) const {
  const CRect itemRect = getItemRect(itemIndex);

  const size_t horizontalPadding = getHorizontalPadding();
  const size_t verticalPadding = 2;

  const CRect controlRect(itemRect.TopLeft() + CPoint(2, verticalPadding),
        CSize(itemRect.Width() - horizontalPadding,
        itemRect.Height() - verticalPadding - 1));

  return controlRect;
}


void ToolbarWindow::setItemWidth(const size_t itemIndex, const size_t newWidth) {
  CToolBarCtrl& toolbarCtrl = GetToolBarCtrl();
  
  TBBUTTONINFO buttonInfo = {0};
  buttonInfo.cbSize = sizeof(buttonInfo);
  buttonInfo.dwMask = TBIF_BYINDEX | TBIF_SIZE;
  buttonInfo.cx = WORD(newWidth);

  const BOOL setInfoResult = toolbarCtrl.SetButtonInfo(itemIndex,
        &buttonInfo);
  if (FALSE == setInfoResult) {
     throw Error("Failed to add fixed spacer\n");
  }
}

CRect ToolbarWindow::getItemsRect(const size_t startIndex,
          const size_t endIndex) const {
  CToolBarCtrl& toolbarCtrl = GetToolBarCtrl();

  const size_t buttonCount = toolbarCtrl.GetButtonCount();

  size_t buttonIndex = startIndex;

  CRect itemsRect;
  GetItemRect(buttonIndex, &itemsRect);

  ++buttonIndex;

  const size_t exactEndIndex = endIndex ?
        std::min(endIndex, buttonCount) : buttonCount;

  CRect itemRect;

  for (; buttonIndex < exactEndIndex; ++buttonIndex) {
      GetItemRect(buttonIndex, &itemRect);
      itemsRect.UnionRect(&itemsRect, itemRect);
   }

   return itemsRect;
}

void ToolbarWindow::resize(size_t toolbarWidth) {
  CRect rect;
  GetClientRect(rect);
  // adjust the size for ie8 (incoming width is bigger sometimes)
  if (toolbarWidth > (size_t)rect.Width()) {
    toolbarWidth = rect.Width();
  }
  if (!toolbarWidth) {
    return;
  }
  rearrangeItems(toolbarWidth);
}

void ToolbarWindow::rearrangeItems(const size_t toolbarWidth) {
  if (resizeDynamicSpacers(toolbarWidth)) {
    rearrangeControlItems();
  }
}

bool ToolbarWindow::resizeDynamicSpacers(const size_t toolbarWidth) {
  bool resizeNeeded = false;
  const CRect leftItemsRect = getItemsRect(0, dynamicSpacerIndex_);
  const CRect rightItemsRect = getItemsRect(dynamicSpacerIndex_ + 1);

  const size_t leftItemsWidth = leftItemsRect.Width();
  const size_t rightItemsWidth = rightItemsRect.Width();
  const size_t itemsWidth = leftItemsWidth + rightItemsWidth;

  const size_t minSpacerWidth = getHorizontalPadding();

  const size_t newSpacerWidth =
    toolbarWidth > (itemsWidth + minSpacerWidth) ?
    toolbarWidth - itemsWidth : minSpacerWidth;

  CRect itemRect = getItemRect(dynamicSpacerIndex_);
  if ((size_t)itemRect.Width() != newSpacerWidth) {
    setItemWidth(dynamicSpacerIndex_, newSpacerWidth);
    resizeNeeded = true;
  }
  return resizeNeeded;
}

void ToolbarWindow::rearrangeControlItems() {
  CWnd* childWindow = GetWindow(GW_CHILD);
  while (childWindow) {
    const int commandId = childWindow->GetDlgCtrlID();
    const int index = CommandToIndex(commandId);
    CRect itemRect = getControlItemRect(index);
    childWindow->MoveWindow(itemRect, TRUE);
    childWindow = childWindow->GetNextWindow();
  }
}


void ToolbarWindow::refreshLayout() {
  if (isPendingRefreshLayout()) {
    return;
  }

  CRect toolbarRect;
  GetParent()->GetClientRect(toolbarRect);

  const LPARAM lParam = MAKELPARAM(toolbarRect.Width(), toolbarRect.Height());

  PostMessage(WM_SIZE, 0, lParam);
}


bool ToolbarWindow::isPendingRefreshLayout() const {
   return isMessagePending(m_hWnd, WM_SIZE);
}


size_t ToolbarWindow::getHorizontalPadding() const {
   int horizontalPadding = 0;
   int verticalPadding = 0;
   GetToolBarCtrl().GetPadding(horizontalPadding, verticalPadding);

   return horizontalPadding;
}


size_t ToolbarWindow::getVerticalPadding() const {
   int horizontalPadding = 0;
   int verticalPadding = 0;
   GetToolBarCtrl().GetPadding(horizontalPadding, verticalPadding);

   return verticalPadding;
}


int ToolbarWindow::getItemCommand(const size_t itemIndex) const {
   CToolBarCtrl& toolbarCtrl = GetToolBarCtrl();

   TBBUTTONINFO buttonInfo = {0};
   buttonInfo.cbSize = sizeof(buttonInfo);
   buttonInfo.dwMask = TBIF_BYINDEX | TBIF_COMMAND;

   const BOOL getInfoResult = toolbarCtrl.GetButtonInfo(itemIndex,
         &buttonInfo);
   if (FALSE == getInfoResult) {
      throw Error("Failed to get item command id\n");
   }

   return buttonInfo.idCommand;
}


void ToolbarWindow::setItemCommand(const size_t itemIndex, const int commandId) {
   CToolBarCtrl& toolbarCtrl = GetToolBarCtrl();
   
   TBBUTTONINFO buttonInfo = {0};
   buttonInfo.cbSize = sizeof(buttonInfo);
   buttonInfo.dwMask = TBIF_BYINDEX | TBIF_COMMAND;
   buttonInfo.idCommand = commandId;

   const BOOL setInfoResult = toolbarCtrl.SetButtonInfo(itemIndex,
         &buttonInfo);
   if (FALSE == setInfoResult) {
      throw Error("Failed to set item command id\n");
   }
}


int ToolbarWindow::getItemImage(const size_t itemIndex) const {
   CToolBarCtrl& toolbarCtrl = GetToolBarCtrl();

   TBBUTTONINFO buttonInfo = {0};
   buttonInfo.cbSize = sizeof(buttonInfo);
   buttonInfo.dwMask = TBIF_BYINDEX | TBIF_IMAGE;

   toolbarCtrl.GetButtonInfo(itemIndex, &buttonInfo);

   return buttonInfo.iImage;
}


void ToolbarWindow::setItemImage(const size_t itemIndex, const int imageId) {
   CToolBarCtrl& toolbarCtrl = GetToolBarCtrl();

   TBBUTTONINFO buttonInfo = {0};
   buttonInfo.cbSize = sizeof(buttonInfo);
   buttonInfo.dwMask = TBIF_BYINDEX | TBIF_IMAGE;
   buttonInfo.iImage = imageId;

   const BOOL setInfoResult = toolbarCtrl.SetButtonInfo(itemIndex,
         &buttonInfo);
   if (FALSE == setInfoResult) {
      throw Error("Failed to set item image\n");
   }
}


void ToolbarWindow::setItemImageToNone(const size_t itemIndex) {
   setItemImage(itemIndex, I_IMAGENONE);

   refreshLayout();
}


BYTE ToolbarWindow::getItemState(const size_t itemIndex) const {
   CToolBarCtrl& toolbarCtrl = GetToolBarCtrl();

   TBBUTTONINFO buttonInfo = {0};
   buttonInfo.cbSize = sizeof(buttonInfo);
   buttonInfo.dwMask = TBIF_BYINDEX | TBIF_STATE;

   toolbarCtrl.GetButtonInfo(itemIndex, &buttonInfo);

   return buttonInfo.fsState;
}


void ToolbarWindow::setItemState(const size_t itemIndex, const BYTE state) {
   CToolBarCtrl& toolbarCtrl = GetToolBarCtrl();
   
   TBBUTTONINFO buttonInfo = {0};
   buttonInfo.cbSize = sizeof(buttonInfo);
   buttonInfo.dwMask = TBIF_BYINDEX | TBIF_STATE;
   buttonInfo.fsState = state;
   
   const BOOL setInfoResult = toolbarCtrl.SetButtonInfo(itemIndex,
         &buttonInfo);
   if (FALSE == setInfoResult) {
      throw Error("Failed to set item state\n");
   }

   refreshLayout();
}


BYTE ToolbarWindow::getItemStyle(const size_t itemIndex) const {
   CToolBarCtrl& toolbarCtrl = GetToolBarCtrl();
   
   TBBUTTONINFO buttonInfo = {0};
   buttonInfo.cbSize = sizeof(buttonInfo);
   buttonInfo.dwMask = TBIF_BYINDEX | TBIF_STYLE;

   const BOOL getInfoResult = toolbarCtrl.GetButtonInfo(itemIndex,
      &buttonInfo);
   if (FALSE == getInfoResult) {
      throw Error("Failed to get item style\n");
   }

   return buttonInfo.fsStyle;
}


void ToolbarWindow::setItemStyle(const size_t itemIndex, const BYTE style) {
   CToolBarCtrl& toolbarCtrl = GetToolBarCtrl();
   
   TBBUTTONINFO buttonInfo = {0};
   buttonInfo.cbSize = sizeof(buttonInfo);
   buttonInfo.dwMask = TBIF_BYINDEX | TBIF_STYLE;
   buttonInfo.fsStyle = style;
   
   const BOOL setInfoResult = toolbarCtrl.SetButtonInfo(itemIndex,
         &buttonInfo);
   if (FALSE == setInfoResult) {
      throw Error("Failed to set item style\n");
   }

   refreshLayout();
}


bool ToolbarWindow::isItemHidden(const size_t itemIndex) const {
   const BYTE itemState = getItemState(itemIndex);
   
   return (itemState & TBSTATE_HIDDEN) == 0;
}


void ToolbarWindow::showItem(const size_t itemIndex) {
   const BYTE itemState = getItemState(itemIndex);
   
   if (TBSTATE_HIDDEN & itemState) {
      setItemState(itemIndex, itemState & ~TBSTATE_HIDDEN);
   }
}


void ToolbarWindow::hideItem(const size_t itemIndex) {
   const BYTE itemState = getItemState(itemIndex);
   
   if (!(TBSTATE_HIDDEN & itemState)) {
      setItemState(itemIndex, itemState | TBSTATE_HIDDEN);
   }
}


void ToolbarWindow::setItemText(const size_t itemIndex,
              const String& itemText) {
   const BOOL setTextResult = SetButtonText(itemIndex, itemText.c_str());
   if (FALSE == setTextResult) {
      throw Error("Failed to set item text\n");
   }

   refreshLayout();
}


ImageListPtr ToolbarWindow::getImageList() const {
   return buttonsImageList_;
}


void ToolbarWindow::setImageList(const ImageListPtr imageList) {
   buttonsImageList_ = imageList;

   GetToolBarCtrl().SetImageList(buttonsImageList_.get());
}


ImageListPtr ToolbarWindow::getHotImageList() const {
   return hotButtonsImageList_;
}


void ToolbarWindow::setHotImageList(const ImageListPtr imageList) {
   hotButtonsImageList_ = imageList;

   GetToolBarCtrl().SetHotImageList(hotButtonsImageList_.get());
}

void ToolbarWindow::updateItem(CMenu *menu, int item) {
  int resourceIndex = menu->GetMenuItemID(item);
  if (resourceIndex <= 0) {
    return;
  }
  String message = loadString(resourceIndex);
  if (!message.empty()) {
    message = ResourceMessages::getMessage(message);
    menu->ModifyMenu(item, MF_BYPOSITION | MF_STRING, 
      menu->GetMenuItemID(item), message.c_str());
  }
}
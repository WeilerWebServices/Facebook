/**
* Facebook Internet Explorer Toolbar Software License 
* Copyright (c) 2009 Facebook, Inc. 
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (which, together with any graphical images included with such
* software, are collectively referred to below as the "Software") to (a) use,
* reproduce, display, distribute, execute, and transmit the Software, (b)
* prepare derivative works of the Software (excluding any graphical images
* included with the Software, which may not be modified or altered), and (c)
* permit third-parties to whom the Software is furnished to do so, all
* subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.  
*
* Facebook, Inc. retains ownership of the Software and all associated
* intellectual property rights.  All rights not expressly granted in this
* license are reserved by Facebook, Inc.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/ 

#include "StdAfx.h"
#include "ClientServiceConnection.h"

#include <afxmt.h>

#include <boost/bind.hpp>

#include "../../FBClientService/FBClientService_i.c"

namespace facebook{

// ---------------------------------------------------------------------
// class ClientServiceConnection
// ---------------------------------------------------------------------

ClientServiceConnection::ClientServiceConnection():
  connectionItems_(),
  criticalSection_() {
}

ClientServiceConnection::~ClientServiceConnection() {
  std::for_each(connectionItems_.begin(), connectionItems_.end(),
      boost::bind(&ClientServiceConnection::releaseSink, this, _1));
}
   
ClientServicePtr ClientServiceConnection::getClientService(
    const DWORD threadId) {
  return getService(obtainConnection(threadId));
}
   
void ClientServiceConnection::subscribeServiceObserver(
    ClientServiceObserver* observer) {
  const ThreadId threadId = ::GetCurrentThreadId();
  ConnectionItem connection = obtainConnection(threadId);

  ClientServiceEventsSinkPtr eventsSink = getEventsSink(connection);

  if (!hasObservers(eventsSink)) {
    advise(getService(connection), eventsSink);
  }

  eventsSink->subscribe(observer);
}

void ClientServiceConnection::unsubscribeServiceObserver(
    ClientServiceObserver* observer) {
  const ThreadId threadId = ::GetCurrentThreadId();
  ConnectionItem connection = obtainConnection(threadId);

  ClientServiceEventsSinkPtr eventsSink = getEventsSink(connection);

  if (!hasObservers(eventsSink)) {
    return;
  }

  eventsSink->unsubscribe(observer);

  if (!hasObservers(eventsSink)) {
    unadvise(getService(connection), eventsSink);
  }
}


ClientServiceEventsSinkPtr ClientServiceConnection::getEventsSink() {
  const ThreadId threadId = ::GetCurrentThreadId();
  return getEventsSink(obtainConnection(threadId));
}


ClientServicePtr ClientServiceConnection::createClientService() {
  ClientServicePtr service;
  const HRESULT createResult = service.CoCreateInstance(CLSID_FBClientService);
  UNREFERENCED_PARAMETER(createResult);
  return service;
}


ClientServiceEventsSinkPtr ClientServiceConnection::createEventsSink() {
  ClientServiceEventsSinkPtr sink;
  const HRESULT createResult =
       ClientServiceEventsSinkObject::CreateInstance(&sink);
  if (FAILED(createResult)) {
    _com_raise_error(createResult);
  }

  sink->AddRef();

  return sink;
}


ClientServiceConnection::ConnectionItem ClientServiceConnection::
createConnection() {
  ClientServicePtr service = createClientService();
  ClientServiceEventsSinkPtr eventsSink = createEventsSink();
  return std::make_pair(service, eventsSink);
}


ClientServicePtr& ClientServiceConnection::getService(ConnectionItem& item) {
  return item.first;
}

const ClientServicePtr& ClientServiceConnection::getService(
    const ConnectionItem& item) {
  return item.first;
}

ClientServiceEventsSinkPtr& ClientServiceConnection::getEventsSink(
    ConnectionItem& item) {
  return item.second;
}


const ClientServiceEventsSinkPtr& ClientServiceConnection::getEventsSink(
    const ConnectionItem& item) {
  return item.second;
}


bool ClientServiceConnection::hasObservers(
    const ClientServiceEventsSinkPtr& sink) const {
  return sink->getObserversCount() > 0;
}


bool ClientServiceConnection::hasConnection(const DWORD connectionId) const {
  return connectionItems_.find(connectionId) != connectionItems_.end();
}


ClientServiceConnection::ConnectionItem ClientServiceConnection::
obtainConnection(const DWORD connectionId) {
  using namespace boost;

  ScopeGuard critSectGuard(bind(&CCriticalSection::Lock, ref(criticalSection_)),
      bind(&CCriticalSection::Unlock, ref(criticalSection_)));

  const ConnectionItemsMap::iterator itemsIter =
      connectionItems_.find(connectionId);

  if (itemsIter != connectionItems_.end()) {
    return itemsIter->second;
  }

  ConnectionItem newConnection = createConnection();

  connectionItems_.insert(std::make_pair(connectionId, newConnection));

  return newConnection;
}


void ClientServiceConnection::removeClientService(const DWORD threadId) {
  const ConnectionItemsMap::iterator itemsIter =
       connectionItems_.find(threadId);
  if (itemsIter != connectionItems_.end()) {
    releaseSink(*itemsIter);
    connectionItems_.erase(itemsIter);
  }
}


void ClientServiceConnection::advise(ClientServicePtr& service,
    ClientServiceEventsSinkPtr& eventsSink) {
  if (!service || !eventsSink) {
    return;
  }
      
  const HRESULT adviseResult = eventsSink->DispEventAdvise(service);
  if (FAILED(adviseResult)) {
    _com_raise_error(adviseResult);
  }
}


void ClientServiceConnection::unadvise(ClientServicePtr& service,
      ClientServiceEventsSinkPtr& eventsSink) {

  if (!service || !eventsSink) {
    return;
  }
  const HRESULT unadviseResult = eventsSink->DispEventUnadvise(service);
  if (FAILED(unadviseResult)) {
    _com_raise_error(unadviseResult);
  }
}


void ClientServiceConnection::releaseSink(ConnectionEntry& connectionEntry) {
   ConnectionItem& connection = connectionEntry.second;
   getEventsSink(connection)->Release();
}

} //!namespace facebook

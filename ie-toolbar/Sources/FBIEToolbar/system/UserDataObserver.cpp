/**
* Facebook Internet Explorer Toolbar Software License 
* Copyright (c) 2009 Facebook, Inc. 
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (which, together with any graphical images included with such
* software, are collectively referred to below as the "Software") to (a) use,
* reproduce, display, distribute, execute, and transmit the Software, (b)
* prepare derivative works of the Software (excluding any graphical images
* included with the Software, which may not be modified or altered), and (c)
* permit third-parties to whom the Software is furnished to do so, all
* subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.  
*
* Facebook, Inc. retains ownership of the Software and all associated
* intellectual property rights.  All rights not expressly granted in this
* license are reserved by Facebook, Inc.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/ 

#include "StdAfx.h"

#include "UserDataObserver.h"

#include "Wininet.h"
#include <boost/algorithm/string.hpp>
#include <boost/bind.hpp>

#include "RuntimeContext.h"

#include "../XslLangCache.h"
#include "../../common/CommonConstants.h"
#include "../../common/ToolbarMessages.h"
#include "../../common/ResourceMessages.h"
#include "../../common/URLUtils.h"

#include "../../util/HttpUtils.h"

#include "../../util/LogUtils.h"
#include "../../util/ScopeGuard.h"
#include "../../util/SessionUtils.h"


namespace facebook {

/**
 *  Helper method initialize instance of UserData
 *  base on FBUserData
 */
void cleanupFBUserData(FBUserData& userData) {
   SysFreeString(userData.id);
   SysFreeString(userData.name);
   SysFreeString(userData.pic);
   SysFreeString(userData.pic_sq);
   SysFreeString(userData.status);
   SysFreeString(userData.cookies);
}

/**
 *  Helper method initialize instance of UserData
 *  base on FBUserData
 */
UserData buildFacebookUserData(const FBUserData& userData) {
   const UserData::Status status(toString(userData.status), 
      userData.stime, _T(""));

   UserData frnd(toString(userData.id), toString(userData.name), status,
      toString(userData.pic), toString(userData.pic_sq), userData.ptime,
      userData.notes, userData.wall);
   frnd.setLoginCookies(userData.cookies);

   return frnd; 
}

// ---------------------------------------------------------------------
// class UserDataObserver
// ---------------------------------------------------------------------

UserDataObserver::UserDataObserver(const DWORD&  threadId) {
   const HRESULT initRes = customRequestsCriticalSection.Init();
   if (FAILED(initRes)) {
      _com_raise_error(initRes);
   }
   thread_  = ::CreateThread(0, 0, threadHandlingProc, this, 0, &processingThreadId_);  

   threadId_ = threadId;
   // data
   isLoggedIn_ = false;
   canChangeStatus_ = false;
   pokesCount_ = 0;
   messagesCount_ = 0;
   requestsCount_ = 0;
   eventsCount_ = 0;
   groupsInvsCount_ = 0;
   isInitialUpdate_ = true;
   getUserRequestsCount_ = 0;
}

UserDataObserver::~UserDataObserver(void) {
  ::CloseHandle(thread_);
  serviceConnection.removeClientService(threadId_);
}

void UserDataObserver::releaseInstance() {

  const DWORD threadId = ::GetCurrentThreadId();

  const ConnectionFasadeItemsMap::iterator itemsIter =
       connectionFasades_.find(threadId);

  if (itemsIter != connectionFasades_.end()) {
    UserDataObserver * currentInstance = itemsIter->second;
    PostThreadMessage(currentInstance->processingThreadId_, WM_QUIT, 0, 0);
  }
}

void UserDataObserver::postCustomRequest(const ClientServiceMessage& requestData) {
  using namespace boost;
   //ScopeGuard fbCritSectGuard(
   //   bind(&CComCriticalSection::Lock, ref(customRequestsCriticalSection)),
   //   bind(&CComCriticalSection::Unlock, ref(customRequestsCriticalSection)));

  requestsQueue_.push(requestData);
  PostThreadMessage(processingThreadId_, TBM_CUSTOM_REQUEST, 0, 0);
}

void UserDataObserver::processCustomRequests() {
  using namespace boost;
   //ScopeGuard fbCritSectGuard(
   //bind(&CComCriticalSection::Lock, ref(customRequestsCriticalSection)),
   //bind(&CComCriticalSection::Unlock, ref(customRequestsCriticalSection)));

  while(!requestsQueue_.empty()) {
    ClientServiceMessage req = requestsQueue_.front();
    processCustomRequest(req);
    requestsQueue_.pop();
  }
}

void UserDataObserver::dataUpdated(unsigned long dataId) {
   // read the new data and update the status:
   switch (dataId) {
      case FBM_MY_STATUS_UPDATED:
         postCustomRequest(ClientServiceMessage(EVENT_GET_LOGGED_IN_USER, threadId_));
         break;
      case FBM_POKES_COUNT_UPDATED:
         postCustomRequest(ClientServiceMessage(EVENT_GET_POKES_COUNT, threadId_));
         break;
      case FBM_REQUESTS_COUNT_PDATED:
         postCustomRequest(ClientServiceMessage(EVENT_GET_REQUESTS_COUNT, threadId_));
         break;
      case FBM_GROUPS_INVINTAIONS_COUNT_UPDATED:
         postCustomRequest(ClientServiceMessage(EVENT_GET_GROUPS_INVS_COUNT, threadId_));
         break;
      case FBM_EVENTS_INVINTAIONS_COUNT_UPDATED:
        postCustomRequest(ClientServiceMessage(EVENT_GET_EVENTS_COUNT, threadId_));
         break;
      case FBM_MY_FRIENDS_LIST_UPDATED:
         postCustomRequest(ClientServiceMessage(EVENT_GET_FRIENDS, threadId_));
         break;
      case FBM_MESSAGES_CONT_UPDATED:
         postCustomRequest(ClientServiceMessage(EVENT_GET_MESSAGES_COUNT, threadId_));
         break;
      default:
         postCustomRequest(ClientServiceMessage(EVENT_DATA_UPDATE, (DataChangeEvents)dataId, threadId_));
         break;
   }
   
}

void UserDataObserver::processCustomRequest(ClientServiceMessage requestData) {
  long dataId = -1;
  switch (requestData.getEvent()) {
    case EVENT_IS_LOGGED_IN: {
      // check if user logged in state changed
      if(handleIsLoggedIn()) {
        isInitialUpdate_ = false;
         //if looged in get data from server
         if (isLoggedIn_) {
           handleGetLoggedInUser();
           handleGetFriends();
           handleCanChangeStatus();
           dataId = FBM_JUST_LOGGED_IN;
         } else { // notify about log out otherwise
           dataId = FBM_LOGOUT_INITIATED;
         }
      }
      break;
    }
    case EVENT_LOG_IN: {
       handleLogin();
       handleIsLoggedIn();
       if (isLoggedIn_) {
          handleGetLoggedInUser();
          handleGetFriends();
          handleCanChangeStatus();
          dataId = FBM_JUST_LOGGED_IN;
       }
       break;
    }
    case EVENT_LOG_OUT: {
       handleLogout();
       handleIsLoggedIn();
       dataId = FBM_LOGOUT_INITIATED;
       break;
    }
    case EVENT_CAN_CHANGE_STATUS: {
       handleCanChangeStatus();
       break;
    }
    case EVENT_GET_POKES_COUNT: {
       handleGetPokesCount();
       dataId = FBM_POKES_COUNT_UPDATED;
       break;
    }
    case EVENT_GET_MESSAGES_COUNT: {
       handleGetMessagesCount();
       dataId = FBM_MESSAGES_CONT_UPDATED;
       break;
    }
    case EVENT_GET_REQUESTS_COUNT: {
       handleGetRequestsCount();
       dataId = FBM_REQUESTS_COUNT_PDATED;
       break;
    }
    case EVENT_GET_EVENTS_COUNT: {
       handleGetEventsCount();
       dataId = FBM_EVENTS_INVINTAIONS_COUNT_UPDATED;
       break;
    }
    case EVENT_GET_GROUPS_INVS_COUNT: {
       handleGetGroupsInvsCount();
       dataId = FBM_GROUPS_INVINTAIONS_COUNT_UPDATED;
       break;
    }
    case EVENT_GET_FRIENDS: {
       handleGetFriends();
       dataId = FBM_MY_FRIENDS_LIST_UPDATED;
       break;
    }
    case EVENT_GET_LOGGED_IN_USER: {
       handleGetLoggedInUser();
       dataId = FBM_MY_STATUS_UPDATED;
       break;
    }
    case EVENT_SET_STATUS: {
       handleSetStatus(requestData.getStatusMessage());
       break;
    }
    case EVENT_SET_SESSION: {
       handleSetSession(requestData.getStatusMessage());
       break;
    }
    case EVENT_DATA_UPDATE: {
       dataId = requestData.getDataEvent();
       handleDataUpdate(dataId);
       break;
    }
    case EVENT_LANGUAGE_UPDATE: {
      handleLanguageUpdate();
      break;
    }
    default:
       return;
  }
  if (dataId >= 0) {
   //LOG4CPLUS_DEBUG(LogUtils::getLogger(), "UserDataObserver::processCustomRequest update views dataId = " << dataId);
   if (RuntimeContext::getToolbar(threadId_)) {
     //LOG4CPLUS_DEBUG(LogUtils::getLogger(), "UserDataObserver::processCustomRequest update toolbar dataId = " << dataId);
     RuntimeContext::getToolbar(threadId_)->postMessage(TBM_DATA_CHANGED, dataId, 0);
   } 
   if (RuntimeContext::getSidebar(threadId_)) {
     //LOG4CPLUS_DEBUG(LogUtils::getLogger(), "UserDataObserver::processCustomRequest update sidebar dataId = " << dataId );
     RuntimeContext::getSidebar(threadId_)->postMessage(TBM_DATA_CHANGED, dataId, 0);
   }
  }
}

DWORD UserDataObserver::threadHandlingProc(LPVOID lpParameter) {

  UserDataObserver* thisHandle =
       reinterpret_cast<UserDataObserver*>(lpParameter);

  CoInitialize(0);
  thisHandle->subscribeServiceObserver(thisHandle);
  thisHandle->postCustomRequest(ClientServiceMessage(EVENT_IS_LOGGED_IN));

  MSG msg;
  while(GetMessage(&msg, 0, 0, 0) > 0) {
    if (msg.message  == TBM_CUSTOM_REQUEST) {
      try {
        thisHandle->processCustomRequests();
        continue;
      }
      catch (...) {}
    }
    TranslateMessage(&msg);
    DispatchMessage(&msg);
  }
  try { 
    thisHandle->unsubscribeServiceObserver(thisHandle);
  }
  catch(_com_error e) {
    (e.Description());
  }

  ScopeGuard coUninitializeGuard(
    boost::bind(CoUninitializeWrapper()));   
  return 0;
}

UserDataObserver::ConnectionFasadeItemsMap UserDataObserver::connectionFasades_;

UserDataObserver& UserDataObserver::getInstance() {
  const DWORD threadId = ::GetCurrentThreadId();

  const ConnectionFasadeItemsMap::iterator itemsIter =
       connectionFasades_.find(threadId);

  if (itemsIter != connectionFasades_.end()) {
   return *(itemsIter->second);
  }

  UserDataObserver * newFasade = new UserDataObserver(threadId);
  connectionFasades_.insert(std::make_pair(threadId, newFasade));

  return (*newFasade);
}

void UserDataObserver::clearInstances() {
   ConnectionFasadeItemsMap::iterator clearIterator = connectionFasades_.begin();
   while (clearIterator != connectionFasades_.end()) {
      delete clearIterator->second;
      clearIterator++;
   }
   connectionFasades_.clear();
}


bool UserDataObserver::handleIsLoggedIn() {
   bool prevLoggedState =  isLoggedIn_;
   ClientServicePtr clientService = serviceConnection.getClientService(threadId_);
   if (clientService == NULL) {
      isLoggedIn_ = false;
   } else {
      USHORT isLogedIn = 0;
      const HRESULT getIsLoggedInRes = clientService->isLoggedIn(&isLogedIn);
      handleError(getIsLoggedInRes);
      isLoggedIn_ = isLogedIn > 0;
   }
   return (prevLoggedState != isLoggedIn_ || isInitialUpdate_);
}

void UserDataObserver::handleLogin() {
  ClientServicePtr clientService = serviceConnection.getClientService(threadId_);
  if (clientService == NULL) {
    return;
  }
  HWND parentHwnd;
  // get the current IE window to show modal login dialog
  RuntimeContext::getBrowser(threadId_)->get_HWND((SHANDLE_PTR*)&parentHwnd);
  const HRESULT loginRes = clientService->login((ULONG)parentHwnd);
  handleError(loginRes);
}

void UserDataObserver::handleLogout() {
   ClientServicePtr clientService = serviceConnection.getClientService(threadId_);
   if (clientService == NULL)
      return;

   const HRESULT logoutRes = clientService->logout();
   handleError(logoutRes);
}

void UserDataObserver::handleCanChangeStatus() {
   ClientServicePtr clientService = serviceConnection.getClientService(threadId_);
   if (clientService == NULL) {
      canChangeStatus_ = false;
      return;
   }
   USHORT allowed = 0;
   const HRESULT canShangeStatusRes = 
      clientService->canChangeStatus(&allowed);

   handleError(canShangeStatusRes);
   canChangeStatus_ = allowed > 0;
}

void UserDataObserver::handleGetPokesCount() {
   ClientServicePtr clientService = serviceConnection.getClientService(threadId_);
   if (clientService == NULL) {
      pokesCount_ = 0;
      return;
   }
  ULONG pokesCount = 0;
  const HRESULT getPokesCountRes = clientService->getPokesCount(&pokesCount);
  handleError(getPokesCountRes);
  pokesCount_ = pokesCount;

}

void UserDataObserver::handleGetMessagesCount() {
   ClientServicePtr clientService = serviceConnection.getClientService(threadId_);
   if (clientService == NULL) {
      messagesCount_ = 0;
      return;
   } 
   ULONG messagesCount = 0;
   const HRESULT getMessagesCountRes = clientService->getMessagesCount(&messagesCount);
   handleError(getMessagesCountRes);
   messagesCount_ = messagesCount;
}

void UserDataObserver::handleGetRequestsCount() {
   ClientServicePtr clientService = serviceConnection.getClientService(threadId_);
   if (clientService == NULL) {
      requestsCount_ = 0;
      return;
   } 

   ULONG requestsCount = 0;
   const HRESULT getRequestsCountRes = clientService->getRequestsCount(&requestsCount);
   handleError(getRequestsCountRes);
   requestsCount_ = requestsCount;
}

void UserDataObserver::handleGetEventsCount() {
   ClientServicePtr clientService = serviceConnection.getClientService(threadId_);
   if (clientService == NULL) {
      eventsCount_ = 0;
      return;
   } 

   ULONG eventsCount = 0;
   const HRESULT getEventsCountRes = clientService->getEventsCount(&eventsCount);
   handleError(getEventsCountRes);
   eventsCount_ = eventsCount;
}

void UserDataObserver::handleGetGroupsInvsCount() {
   ClientServicePtr clientService = serviceConnection.getClientService(threadId_);
   if (clientService == NULL) {
      groupsInvsCount_ = 0;
      return;
   } 

   ULONG groupsInvCount = 0;
   const HRESULT getGrupsInvsCountRes = clientService->getGroupsInvsCount(&groupsInvCount);
   handleError(getGrupsInvsCountRes);
   groupsInvsCount_ = groupsInvCount;
}

void UserDataObserver::handleGetFriends() {
   FriendsList friendsList;
   ClientServicePtr clientService = serviceConnection.getClientService(threadId_);
   if (clientService == NULL) {
      return;
   }

   SAFEARRAY* friendsData = 0;
   const HRESULT getFriendsArrayRes = clientService->getFriends(&friendsData);
   if (FAILED(getFriendsArrayRes)) {
      serviceConnection.removeClientService(threadId_);
      return;
   }

   ScopeGuard saGuard(boost::bind(SafeArrayDestroyWrapper(), friendsData));

   LONG lowerBound = 0;
   const HRESULT getArrayLowerBoundRes = SafeArrayGetLBound(friendsData, 1, &lowerBound);
   if (FAILED(getArrayLowerBoundRes)) {
      return;
   }

   LONG upperBound = 0;
   const HRESULT getArrayUpperBoundRes = SafeArrayGetUBound(friendsData, 1, &upperBound);
   if (FAILED(getArrayUpperBoundRes)) {
      return;
   }

  for (LONG i = lowerBound; i <= upperBound; ++i) {
    FBUserData userData = {0};
    const HRESULT getElementRes = SafeArrayGetElement(friendsData, &i, &userData);
    if (FAILED(getElementRes)) {
      return;
    }

    ScopeGuard userDataGuard(boost::bind(cleanupFBUserData, 
      boost::ref(userData)));

    const UserData frnd = buildFacebookUserData(userData);

    friendsList.push_back(frnd);
  }

  friendList_ = friendsList;
}

void UserDataObserver::setCookies(String cookies) {
  applySession(cookies);
}
void UserDataObserver::handleGetLoggedInUser() {
  FBUserData data;
  ClientServicePtr clientService = serviceConnection.getClientService(threadId_);
  if (clientService == NULL) {
    loggedInUser_ = buildFacebookUserData(data);
    return;
  }

  const HRESULT getLoggedInUserRes = clientService->getUser(&data);

  if (FAILED(getLoggedInUserRes)) {
    serviceConnection.removeClientService(threadId_);
  } else {
    ScopeGuard userDataGuard(boost::bind(cleanupFBUserData, 
      boost::ref(data)));
    loggedInUser_ = buildFacebookUserData(data);
    //get the cookies from currently logged in user
     setCookies(loggedInUser_.getLoginCookies());
  }
  // if we don't get the user correctly - try to reget
  if (loggedInUser_.getName().empty()) {
    if (getUserRequestsCount_ == 0) {
       getUserRequestsCount_++;
       getLoggedInUser();
    }
  } else {
    getUserRequestsCount_ = 0;
  }
}

void UserDataObserver::handleSetStatus(const facebook::String& statusMessage) {
   ClientServicePtr clientService = serviceConnection.getClientService(threadId_);
   if (clientService == NULL) {
      return;
   }

   const HRESULT setStatusRes = 
      clientService->setStatus(SysAllocString( toBSTR(statusMessage)));

  handleError(setStatusRes);
}

void UserDataObserver::handleSetSession(const facebook::String& session) {
   ClientServicePtr clientService = serviceConnection.getClientService(threadId_);
   if (clientService == NULL) {
      return;
   }

   const HRESULT setStatusRes = 
      clientService->setSession(SysAllocString( toBSTR(session)));

  handleError(setStatusRes);
}

void UserDataObserver::handleLanguageUpdate() {
  ClientServicePtr clientService = serviceConnection.getClientService(threadId_);
  if (clientService == NULL) {
    return;
  }

  const HRESULT setStatusRes = clientService->updateView(0);

  handleError(setStatusRes);
}

void UserDataObserver::handleDataUpdate(int dataId) {
  // handle the language changes
  if (dataId == FBM_UPDATE_VIEW) {
    XslLangCache::Instance()->update();
    ResourceMessages::getInstance().loadCurrentCulture();
    ResourceMessages::getInstance().notifyObservers();
  }
  // handle the logout notification from the service
  if (dataId == FBM_LOGOUT_INITIATED) {
    String paramsString = _T("confirm=1");
    String response;
    HttpUtils::doPostRequest(kLogoutPageUrl, paramsString, response);
  }
}

void UserDataObserver::handleError(HRESULT result) {
  if (FAILED(result)) {
    serviceConnection.removeClientService(threadId_);
  }
}

bool UserDataObserver::isLoggedIn(bool needUpdate) {
   if (needUpdate) {
      postCustomRequest(ClientServiceMessage(EVENT_IS_LOGGED_IN));
   }
   return isLoggedIn_;
}

void UserDataObserver::login(bool needUpdate) {
  if (needUpdate) {
    postCustomRequest(ClientServiceMessage(EVENT_LOG_IN));
  }
}

void UserDataObserver::logout(bool needUpdate) {
  if (needUpdate) {
    postCustomRequest(ClientServiceMessage(EVENT_LOG_OUT));
    isLoggedIn_ = false;
  }
}

bool UserDataObserver::canChangeStatus(bool needUpdate) {
  if(needUpdate) {
    postCustomRequest(ClientServiceMessage(EVENT_CAN_CHANGE_STATUS));
  }
  return canChangeStatus_;
}

size_t UserDataObserver::getPokesCount(bool needUpdate) {
  if(needUpdate) {
    postCustomRequest(ClientServiceMessage(EVENT_GET_POKES_COUNT));
  }
  return pokesCount_;   
}

size_t UserDataObserver::getMessagesCount(bool needUpdate) {
  if (needUpdate) {
    postCustomRequest(ClientServiceMessage(EVENT_GET_MESSAGES_COUNT));
  }
  return messagesCount_;   
}

size_t UserDataObserver::getRequestsCount(bool needUpdate) {
  if(needUpdate) {
    postCustomRequest(ClientServiceMessage(EVENT_GET_REQUESTS_COUNT));
  }
  return requestsCount_;   
}

size_t UserDataObserver::getEventsCount(bool needUpdate) {
  if(needUpdate) {
    postCustomRequest(ClientServiceMessage(EVENT_GET_EVENTS_COUNT));
  }
  return eventsCount_;   
}

size_t UserDataObserver::getGroupsInvsCount(bool needUpdate) {
  if(needUpdate) {
    postCustomRequest(ClientServiceMessage(EVENT_GET_GROUPS_INVS_COUNT));
  }
  return groupsInvsCount_;   
}

FriendsList UserDataObserver::getFriends(bool needUpdate) {  
  if (needUpdate) {
    postCustomRequest(ClientServiceMessage(EVENT_GET_FRIENDS));
  }
  return friendList_;   
}

UserData UserDataObserver::getLoggedInUser(bool needUpdate) {
  if(needUpdate) {
    postCustomRequest(ClientServiceMessage(EVENT_GET_LOGGED_IN_USER));
  }
  return loggedInUser_;   
}

void UserDataObserver::subscribeServiceObserver(ClientServiceObserver* observer) {
  serviceConnection.subscribeServiceObserver(observer);
}

void UserDataObserver::unsubscribeServiceObserver(ClientServiceObserver* observer) {
  serviceConnection.unsubscribeServiceObserver(observer);
}

void UserDataObserver::setStatus(const facebook::String& statusMessage) {
  postCustomRequest(ClientServiceMessage(EVENT_SET_STATUS, statusMessage));
}

void UserDataObserver::setSession(const facebook::String& session) {
  postCustomRequest(ClientServiceMessage(EVENT_SET_SESSION, session));
}

void UserDataObserver::updateView(int changeId) {
  UNREFERENCED_PARAMETER(changeId);
  postCustomRequest(ClientServiceMessage(EVENT_LANGUAGE_UPDATE));
}

} // !namespace facebook

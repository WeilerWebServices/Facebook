/**
* Facebook Internet Explorer Toolbar Software License 
* Copyright (c) 2009 Facebook, Inc. 
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (which, together with any graphical images included with such
* software, are collectively referred to below as the "Software") to (a) use,
* reproduce, display, distribute, execute, and transmit the Software, (b)
* prepare derivative works of the Software (excluding any graphical images
* included with the Software, which may not be modified or altered), and (c)
* permit third-parties to whom the Software is furnished to do so, all
* subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.  
*
* Facebook, Inc. retains ownership of the Software and all associated
* intellectual property rights.  All rights not expressly granted in this
* license are reserved by Facebook, Inc.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/ 

#include "StdAfx.h"
#include "IEToolbar.h"

#include <limits>
#include <map>
#include <boost/lexical_cast.hpp>

#include "ToolbarSettingsDlg.h"

#include "../system/ClassIds.h"
#include "../system/ObjectsServer.h"
#include "../system/UserDataObserver.h"
#include "../system/RuntimeContext.h"

#include "../../common/DataChangeEvents.h"
#include "../../common/ToolbarMessages.h"
#include "../../common/UrlUtils.h"

#include "../../util/Error.h"
#include "../../util/BrowserUtils.h"
#include "../../util/GdiUtils.h"
#include "../../util/HtmlUtils.h"
#include "../../common/ResourceMessages.h"
#include "../../util/LogUtils.h"
#include "../../util/PtrUtils.h"
#include "../../util/ShellUtils.h"
#include "../../util/WndUtils.h"

#include "../../system/ProtocolFactory.h"

#include "../resource.h"


#undef min
#undef max


namespace facebook {

const CSize IEToolbar::minSize_(300, 26);
const CSize IEToolbar::maxSize_(-1, 26);

const size_t IEToolbar::invalidItemIndex_ =
    std::numeric_limits<size_t>::max();

std::map<int, String> toolbarCommandActions;

void initToolbarCommandActions() {
  if (!toolbarCommandActions.empty()) {
    return;
  }

  toolbarCommandActions[IDC_TBI_HOME] = kHomePageUrl;
  toolbarCommandActions[IDC_TBI_POKES] = kPokesUrl;
  toolbarCommandActions[IDC_TBI_REQUESTS] = kFriendsRequestsUrl;
  toolbarCommandActions[IDC_TBI_MESSAGES] = kMessagesUrl;
  toolbarCommandActions[IDC_TBI_EVENTINVS] = kEventsInvitationsUrl;
  toolbarCommandActions[IDC_TBI_GROUPINVS] = kGroupsInvitationsUrl;
  toolbarCommandActions[IDC_TBI_PROFILE] = kProfileUrl;
  toolbarCommandActions[ID_QL_PROFILE] = kProfileUrl;
  toolbarCommandActions[ID_QL_FRIENDS] = kFriendsUrl;
  toolbarCommandActions[ID_QL_NETWORKS] = kNetworksUrl;
  toolbarCommandActions[ID_QL_INBOX] = kInboxUrl;
  toolbarCommandActions[ID_QL_PHOTOS] = kPhotosUrl;
  toolbarCommandActions[ID_QL_NOTES] = kNotesUrl;
  toolbarCommandActions[ID_QL_GROUPS] = kGroupsUrl;
  toolbarCommandActions[ID_QL_EVENTS] = kEventsUrl;
  toolbarCommandActions[ID_QL_POSTEDITEMS] = kPostedItemsUrl;
  toolbarCommandActions[ID_QL_ACCOUNT] = kAccountUrl;
  toolbarCommandActions[ID_QL_PRIVACY] = kPrivacyUrl;

} // namespace facebook


// ---------------------------------------------------------------------
// class IEToolbar
// ---------------------------------------------------------------------


IEToolbar::IEToolbar():
  searchEditWidth_(170),
  statusEditWidth_(170),
  cueBannerColor_(RGB(128, 128, 128)),
  objRefsCount_(0),
  site_(0),
  siteWindow_(),
  bandId_(0),
  viewMode_(0),
  toolbarWindow_(),
  searchEdit_(),
  statusEdit_(),
  sidebarButtonIndex_(invalidItemIndex_),
  searchEditIndex_(invalidItemIndex_),
  quickLinksButtonIndex_(invalidItemIndex_),
  homeButtonIndex_(invalidItemIndex_),
  pokesButtonIndex_(invalidItemIndex_),
  requestsButtonIndex_(invalidItemIndex_),
  messagesButtonIndex_(invalidItemIndex_),
  eventInvsButtonIndex_(invalidItemIndex_),
  groupInvsButtonIndex_(invalidItemIndex_),
  shareButtonIndex_(invalidItemIndex_),
  profileButtonIndex_(invalidItemIndex_),
  statusEditIndex_(invalidItemIndex_),
  loginButtonIndex_(invalidItemIndex_),
  loginSpacerIndex_(invalidItemIndex_),
  toolbarState_(TS_USER_LOGGED_OUT) {
  LOG4CPLUS_DEBUG(LogUtils::getLogger(), _T("IEToolbar::IEToolbar"));
  ObjectsServer::lock();
  initToolbarCommandActions(); 
  ResourceMessages::subscribeObserver(this);
  InitializeCriticalSection(&critialSection_);
}


IEToolbar::~IEToolbar() {
  LOG4CPLUS_DEBUG(LogUtils::getLogger(), _T("IEToolbar::~IEToolbar"));

  CComPtr<IInternetSession> session;
  CoInternetGetSession(0, &session, 0);
  session->UnregisterNameSpace(httpsFactory_, L"https");
  httpsFactory_.Release();

  // unsubscribe from http responce trakings
  session->UnregisterNameSpace(httpsFactory_, L"http");
  httpFactory_.Release();

  undockFromSite();
  UserDataObserver::releaseInstance();
  ResourceMessages::unsubscribeObserver(this);
  ObjectsServer::unlock();
}


LRESULT CALLBACK IEToolbar::subclassProcThunk(HWND window, UINT message,
                                              WPARAM wParam, LPARAM lParam,
                                              UINT_PTR subclassId,
                                              DWORD_PTR refData) {
  UNREFERENCED_PARAMETER(subclassId);

  // Retrieve object which subclass the window.
  ClassType* theObject = reinterpret_cast<ClassType*>(refData);

  // Translate message to object which subclass the window.
  // And return if message elaborated.
  LRESULT lResult = 0;
  const bool elaborated = theObject->processSubclassedWindowMessage(
      window, message, wParam, lParam, lResult);
  if (elaborated) {
    return lResult;
  }

  // Call default window procedure of subclassed window.
  return DefSubclassProc(window, message, wParam, lParam);
}


STDMETHODIMP IEToolbar::QueryInterface(REFIID interfaceId,
                                       LPVOID* interfacePointer) {
  *interfacePointer = 0;

  if (IsEqualIID(IID_IUnknown, interfaceId)) {
    *interfacePointer = static_cast<IUnknown*>(
          static_cast<IDeskBand*>(this));
  } else if (IsEqualIID(IID_IOleWindow, interfaceId)) {
    *interfacePointer = static_cast<IOleWindow*>(this);
  } else if (IsEqualIID(IID_IDockingWindow, interfaceId)) {
    *interfacePointer = static_cast<IDockingWindow*>(this);
  } else if (IsEqualIID(IID_IInputObject, interfaceId)) {
    *interfacePointer = static_cast<IInputObject*>(this);
  } else if (IsEqualIID(IID_IObjectWithSite, interfaceId)) {
    *interfacePointer = static_cast<IObjectWithSite*>(this);
  } else if (IsEqualIID(IID_IDeskBand, interfaceId)) {
    *interfacePointer = static_cast<IDeskBand*>(this);
  } else if (IsEqualIID(IID_IPersist, interfaceId)) {
    *interfacePointer = static_cast<IPersist*>(this);
  } else if (IsEqualIID(IID_IPersistStream, interfaceId)) {
    *interfacePointer = static_cast<IPersistStream*>(this);
  } else if (IsEqualIID(IID_IContextMenu, interfaceId)) {
    *interfacePointer = static_cast<IContextMenu*>(this);
  }

  if (*interfacePointer) {
    reinterpret_cast<IUnknown*>(*interfacePointer)->AddRef();
    return S_OK;
  }

  return E_NOINTERFACE;
}


STDMETHODIMP_(DWORD) IEToolbar::AddRef() {
  return ++objRefsCount_;
}


STDMETHODIMP_(DWORD) IEToolbar::Release() {
  if (--objRefsCount_ == 0) {
    delete this;
    return 0;
  }

  return objRefsCount_;
}


STDMETHODIMP IEToolbar::GetWindow(HWND* window) {
  *window = toolbarWindow_.GetSafeHwnd();
  return S_OK;
}


STDMETHODIMP IEToolbar::ContextSensitiveHelp(BOOL) {
  return E_NOTIMPL;
}


STDMETHODIMP IEToolbar::ShowDW(BOOL show) {
   UNREFERENCED_PARAMETER(show);

  return S_OK;
}


STDMETHODIMP IEToolbar::CloseDW(DWORD) {
  return S_OK;
}


STDMETHODIMP IEToolbar::ResizeBorderDW(LPCRECT, IUnknown*, BOOL) {
  return E_NOTIMPL;
}


STDMETHODIMP IEToolbar::GetBandInfo(DWORD bandId, DWORD viewMode,
                                    DESKBANDINFO* bandInfo) {
  if (isNull(bandInfo)) {
  return E_INVALIDARG;
  }

  // Store identifier for the toolbar and its view mode retrieved form IE.
  bandId_ = bandId;
  viewMode_ = viewMode;

  // See what was requested by IE.
  DWORD& infoMask = bandInfo->dwMask;

  // Provide minimal size of toolbar.
  if (infoMask & DBIM_MINSIZE) {
    bandInfo->ptMinSize.x = minSize_.cx;
    bandInfo->ptMinSize.y = minSize_.cy;
  }

  // Provide maximal size of toolbar.
  if (infoMask & DBIM_MAXSIZE) {
    bandInfo->ptMaxSize.x = maxSize_.cx;
    bandInfo->ptMaxSize.y = maxSize_.cy;
  }

  // Provide integral size of toolbar.
  if (infoMask & DBIM_INTEGRAL) {
    bandInfo->ptIntegral.x = minSize_.cx;
    bandInfo->ptIntegral.y = minSize_.cy;
  }

  // Provide actual size of toolbar.
  if (infoMask & DBIM_ACTUAL) {
    bandInfo->ptActual.x = minSize_.cx;
    bandInfo->ptActual.y = minSize_.cy;
  }

  // Setup available modes for toolbar.
  if (infoMask & DBIM_MODEFLAGS) {
    bandInfo->dwModeFlags = DBIMF_NORMAL | DBIMF_VARIABLEHEIGHT;
  }

  // Do not specify custom background for toolbar.
  if (infoMask & DBIM_BKCOLOR) {
    infoMask &= ~DBIM_BKCOLOR;
  }

  return S_OK;
}


STDMETHODIMP IEToolbar::UIActivateIO(BOOL activate, LPMSG message) {
  UNREFERENCED_PARAMETER(message);

  // Set input focus to our MFC-based toolbar window.
  if (TRUE == activate) {
    toolbarWindow_.SetFocus();
  }

  return S_OK;
}


STDMETHODIMP IEToolbar:: HasFocusIO() {
  // Determine if our toolbar window has focus
  const bool toolbarHasFocus = hasFocus(toolbarWindow_);

  return toolbarHasFocus ? S_OK : S_FALSE;
}


STDMETHODIMP IEToolbar::TranslateAcceleratorIO(LPMSG message) {
  // Give a change to process input keyboard message to our toolbar window.
  BOOL messageTranslated = toolbarWindow_.PreTranslateMessage(message);

  // Do default message processing.
  if (FALSE == messageTranslated) {
    messageTranslated = TranslateMessage(message);
    DispatchMessage(message);
  }

  return messageTranslated == TRUE ? S_OK : S_FALSE;
}


STDMETHODIMP IEToolbar::SetSite(IUnknown* sitePtr) {
  if (!isNull(sitePtr)) {
    dockToSite(IUnknownPtr(sitePtr));
  } else {
    undockFromSite();
  }

  return S_OK;
}


STDMETHODIMP IEToolbar::GetSite(REFIID interfaceId, LPVOID* interfacePtr) {
  *interfacePtr = 0;

  // Query requested interface from site on which the toolbar resides.
  if (!isNull(site_)) {
    return site_->QueryInterface(interfaceId, interfacePtr);
  }

  return E_FAIL;
}


STDMETHODIMP IEToolbar::GetClassID(LPCLSID classId) {
  *classId = CLSID_IEToolbar;
  return S_OK;
}

STDMETHODIMP IEToolbar::IsDirty(void) {
  return S_FALSE;
}


STDMETHODIMP IEToolbar::Load(LPSTREAM) {
  return S_OK;
}


STDMETHODIMP IEToolbar::Save(LPSTREAM, BOOL) {
  return S_OK;
}


STDMETHODIMP IEToolbar::GetSizeMax(ULARGE_INTEGER*) {
  return E_NOTIMPL;
}


STDMETHODIMP IEToolbar::QueryContextMenu(HMENU, UINT, UINT, UINT, UINT) {
  return E_NOTIMPL;
}


STDMETHODIMP IEToolbar::InvokeCommand(CMINVOKECOMMANDINFO*) {
  return E_NOTIMPL;
}


STDMETHODIMP IEToolbar::GetCommandString(UINT_PTR, UINT, UINT*, LPSTR, UINT) {
  return E_NOTIMPL;
}


IUnknownPtr IEToolbar::getControlUnknown() {
  // Query IUnknown interface.
  IUnknown* unknown = 0;
  const HRESULT queryResult = QueryInterface(IID_IUnknown,
      reinterpret_cast<void**>(&unknown));
  if (FAILED(queryResult)) {
    _com_raise_error(queryResult);
  }

  return unknown;
}


IServiceProviderPtr IEToolbar::getServiceProvider() const {
  // Query IServiceProvider interface from site on which the toolbar resides.
  IServiceProvider* serviceProviderPtr = 0;
  const HRESULT getProviderResult = site_->QueryInterface(
      IID_IServiceProvider, reinterpret_cast<void**>(&serviceProviderPtr));
  if (FAILED(getProviderResult)) {
    throw(_com_error(getProviderResult));
  }

  return IServiceProviderPtr(serviceProviderPtr);
}


IWebBrowser2Ptr IEToolbar::getWebBrowser() const {
  // Retrieve service provider to query service from.
  IServiceProviderPtr serviceProvider = getServiceProvider();

  // Query web browser interface.
  IWebBrowser2Ptr webBrowser;
  const HRESULT getBrowserResult = serviceProvider->QueryService(
      SID_SWebBrowserApp, &webBrowser);
  if (FAILED(getBrowserResult)) {
    throw(_com_error(getBrowserResult));
  }

  return webBrowser;
}

HWND IEToolbar::getToolbarWindow() const {
  return toolbarWindow_.GetSafeHwnd();
}

void IEToolbar::dockToSite(IUnknownPtr site) {
  //LOG4CPLUS_DEBUG(LogUtils::getLogger(), "IEToolbar::dockToSite start...");
  acquireSite(site);
  acquireSiteWindow(site);
  //LOG4CPLUS_DEBUG(LogUtils::getLogger(), "IEToolbar::dockToSite createToolbarWindow...");
  createToolbarWindow();
  //LOG4CPLUS_DEBUG(LogUtils::getLogger(), "IEToolbar::dockToSite updateView...");
  updateView();
  //LOG4CPLUS_DEBUG(LogUtils::getLogger(), "IEToolbar::dockToSite end");
}

void IEToolbar::undockFromSite() {
   releaseSiteWindow();
   releaseSite();
   destroyToolbarWindow();
}

void IEToolbar::acquireSite(IUnknownPtr site) {
  // Query IInputObjectSite from specified site.
  IInputObjectSite* sitePtr = 0;
  const HRESULT getSiteResult = site->QueryInterface(IID_IInputObjectSite,
      reinterpret_cast<void**>(&sitePtr));
  if (FAILED(getSiteResult)) {
    throw _com_error(getSiteResult);
  }

  // Set up new site for toolbar.
  releaseSite();
  site_ = sitePtr;
}


void IEToolbar::releaseSite() {
  if (!isNull(site_)) {
    site_->Release();
    site_ = 0;
  }
}


void IEToolbar::acquireSiteWindow(IUnknownPtr site) {
  // Query IOleWindow interface from specified site.
  IOleWindowPtr siteOLEWindow;
  const HRESULT getOleWindowResult =
      site.QueryInterface(IID_IOleWindow, &siteOLEWindow);
  if (FAILED(getOleWindowResult)) {
    throw _com_error(getOleWindowResult);
  }

  // Retrieve handle of site window.
  HWND siteWindowHandle = 0;
  const HRESULT getWindowResult = siteOLEWindow->GetWindow(&siteWindowHandle);
  if (FAILED(getWindowResult)) {
    throw _com_error(getWindowResult);
  }

  // Attach MFC-wrapper to site window.
  const BOOL attachResult = siteWindow_.Attach(siteWindowHandle);
  if (FALSE == attachResult) {
    throw Error("Failed to attach to site window handle\n");
  }

  // Subclass site window to retrieve its messages.
  subclassWindow(siteWindow_.GetSafeHwnd());
}


void IEToolbar::postMessage(DWORD code, WPARAM wParam, LPARAM lParam) {
  // Redirect posted message to MFC-based toolbar window.
  siteWindow_.PostMessage(code, wParam, lParam);
}


void IEToolbar::releaseSiteWindow() {
  // Un-subclass site window.
  unsubclassWindow(siteWindow_.GetSafeHwnd());

  // Detach MFC-wrapper from site window to do not destroy it.
  siteWindow_.Detach();
}


void IEToolbar::subclassWindow(const HWND window) {
  const UINT_PTR subclassId = UINT_PTR(this);
  const DWORD refData = DWORD(this);
  const BOOL subclassingResult = SetWindowSubclass(window,
      subclassProcThunk, subclassId, refData);
  if (FALSE == subclassingResult) {
    throw Error("Failed to subclass site window\n");
  }
}


void IEToolbar::unsubclassWindow(const HWND window) {
  const UINT_PTR subclassId = UINT_PTR(this);
  RemoveWindowSubclass(window, subclassProcThunk, subclassId);
}


bool IEToolbar::processSubclassedWindowMessage(const HWND subclassedWindow,
                                               const UINT message,
                                               const WPARAM wParam,
                                               const LPARAM lParam,
                                               LRESULT& lResult) {
  if (subclassedWindow == siteWindow_.m_hWnd) {
    return processSiteWindowMessage(message, wParam, lParam, lResult);
  }

  return false;
}


bool IEToolbar::processSiteWindowMessage(const UINT message,
                                         const WPARAM wParam,
                                         const LPARAM lParam,
                                         LRESULT& lResult) {
  switch (message) {
  case WM_COMMAND:
    return onCommand(wParam);
  case WM_NOTIFY:
    return onNotify(wParam, *(LPNMHDR)lParam, lResult);
  case TBM_DATA_CHANGED:
    dataUpdated(wParam);
    return true;
  case TBM_COOKIES: {
    UNREFERENCED_PARAMETER(lParam);
    String cookie = String((Char*)wParam);
    UserDataObserver::getInstance().setSession(cookie);
    return true;
  }
  default:
    return false;
  }
}

void IEToolbar::createToolbarWindow() {
  toolbarWindow_.create(siteWindow_);

  // Load and assign images for toolbar's buttons.
  setupToolbarImages();
  setupToolbarHotImages();

  // Create all toolbar elements.
  createToolbarItems();

  // Store toolbar reference for 
  RuntimeContext::storeToolbar(*this);

  // subscribe for https responces tracking
  CComPtr<IInternetSession> session;
  CoInternetGetSession(0, &session, 0);
  SessionMetaFactory::CreateInstance(CLSID_HttpSProtocol, 
    &httpsFactory_, siteWindow_.m_hWnd);
  session->RegisterNameSpace(httpsFactory_, CLSID_NULL, L"https", 0, 0, 0);

  // subscribe for http responces tracking
  SessionMetaFactory::CreateInstance(CLSID_HttpProtocol, 
    &httpFactory_, siteWindow_.m_hWnd);
  session->RegisterNameSpace(httpFactory_, CLSID_NULL, L"http", 0, 0, 0);

  // Switch toolbar to appropriate state.
  if (UserDataObserver::getInstance().isLoggedIn()) {
    loggedIn();
  } else {
    loggedOut();
  }
}



void IEToolbar::setupToolbarImages() {
  // Determine if MS Windows is right aligned and load toolbar icons
  // depending on it
  int resId = isBiDi(LOCALE_SYSTEM_DEFAULT) ? 
    IDB_IETOOLBAR_BUTTONS_RTL : IDB_IETOOLBAR_BUTTONS;
  const BitmapPtr buttonsBitmap = loadBitmap(resId);
  const ImageListPtr buttonsImageList = createButtonsImageList(*buttonsBitmap);
  toolbarWindow_.setImageList(buttonsImageList);

  shareButtonBitmap_ = generateShareBitmap(false);
}


void IEToolbar::setupToolbarHotImages() {
  // Determine if MS Windows is right aligned and load toolbar hot icons
  // depending on it
  int resId = isBiDi(LOCALE_SYSTEM_DEFAULT) ? 
    IDB_IETOOLBAR_HOT_BUTTONS_RTL : IDB_IETOOLBAR_HOT_BUTTONS;
  const BitmapPtr hotButtonsBitmap = loadBitmap(resId);
  const ImageListPtr hotButtonsImageList =
      createButtonsImageList(*hotButtonsBitmap);
  toolbarWindow_.setHotImageList(hotButtonsImageList);

  shareHotButtonBitmap_ = generateShareBitmap(true);
}


void IEToolbar::loadQuickLinksMenu(CMenu& menu) {
  HWND focusedWindow = GetFocus();
  if (focusedWindow && GetParent(focusedWindow) == toolbarWindow_.GetSafeHwnd()) {
    toolbarWindow_.SetFocus();
  }
  
  const BOOL loadResult = menu.LoadMenu(IDR_MENU_POPUP);
  if (FALSE == loadResult) {
    throw Error("Failed to load quicklinks menu\n");
  }
}


ImageListPtr IEToolbar::createButtonsImageList(CBitmap& bitmap) const {
  BITMAP bitmapData = {0};
  bitmap.GetBitmap(&bitmapData);

  ImageListPtr imageList(new CImageList());

  const BOOL createResult = imageList->Create(bitmapData.bmHeight,
      bitmapData.bmHeight, bitmapData.bmBitsPixel | ILC_MASK,
      bitmapData.bmWidth / bitmapData.bmHeight, 0);
  if (FALSE == createResult) {
    throw Error("Failed to create buttons image list\n");
  }

  const int addResult = imageList->Add(&bitmap, RGB(255, 0, 255));
  if (addResult < 0) {
    throw Error("Failed to add bitmap to buttons image list\n");
  }

  imageList->SetBkColor(CLR_NONE);

  return imageList;
}


void IEToolbar::createToolbarItems() {
  sidebarButtonIndex_ = appendSidebarButton();

  toolbarWindow_.appendSeparator();

  searchEditIndex_ = appendSearchEdit();
  quickLinksButtonIndex_ = appendQuickLinksButton();

  toolbarWindow_.appendSeparator();

  homeButtonIndex_ = appendHomeButton();

  toolbarWindow_.appendSeparator();

  pokesButtonIndex_ = appendPokesButton();
  requestsButtonIndex_ = appendRequestsButton();
  messagesButtonIndex_ = appendMesssagesButton();
  eventInvsButtonIndex_ = appendEventInvsButton();
  groupInvsButtonIndex_ = appendGroupInvsButton();

  toolbarWindow_.appendSeparator();

  shareButtonIndex_ = appendShareButton();
  resizeShareButton();
  
  toolbarWindow_.appendDynamicSpacer();

  profileButtonIndex_ = appendProfileButton();
  statusEditIndex_ = appendStatusEdit();

  loginSpacerIndex_ = toolbarWindow_.appendSeparator();

  loginButtonIndex_ = appendLoginButton();
}


size_t IEToolbar::appendSidebarButton() {
  TBBUTTON buttonDefn = {0};
  buttonDefn.fsStyle = BTNS_CHECK;
  buttonDefn.fsState = TBSTATE_ENABLED;
  buttonDefn.idCommand = IDC_TBI_SIDEBAR;
  buttonDefn.iBitmap = 0;

  const size_t buttonIndex = toolbarWindow_.appendButton(buttonDefn);

  return buttonIndex;
}


size_t IEToolbar::appendSearchEdit() {
  const size_t spacerIndex = toolbarWindow_.appendFixedSpacer(searchEditWidth_);

  toolbarWindow_.setItemCommand(spacerIndex, IDC_TBI_SEARCH);

  const DWORD editStyles = WS_CHILD | WS_VISIBLE | WS_TABSTOP;
  const BOOL createResult = searchEdit_.Create(editStyles, CRect(),
      &toolbarWindow_, IDC_TBI_SEARCH);
  if (FALSE == createResult) {
    throw Error("Failed to append search edit\n");
  }

  searchEdit_.SetFont(toolbarWindow_.GetFont());
  searchEdit_.setPromptText(ResourceMessages::getMessage(kToolbarSearchFacebook));
  searchEdit_.setPromptColor(cueBannerColor_);
  searchEdit_.setText(_T(""));

  return spacerIndex;
}


size_t IEToolbar::appendQuickLinksButton() {
  TBBUTTON buttonDefn = {0};
  buttonDefn.fsStyle = BTNS_WHOLEDROPDOWN | BTNS_AUTOSIZE | BTNS_SHOWTEXT;
  buttonDefn.fsState = TBSTATE_ENABLED;
  buttonDefn.idCommand = IDC_TBI_QUICKLINKS;
  const size_t buttonIndex = toolbarWindow_.appendButton(buttonDefn);
  toolbarWindow_.setItemImageToNone(buttonIndex);
  return buttonIndex;
}


size_t IEToolbar::appendHomeButton() {
  TBBUTTON buttonDefn = {0};
  buttonDefn.fsStyle = BTNS_BUTTON;
  buttonDefn.fsState = TBSTATE_ENABLED;
  buttonDefn.idCommand = IDC_TBI_HOME;
  buttonDefn.iBitmap = 1;
  
  const size_t buttonIndex = toolbarWindow_.appendButton(buttonDefn);

  return buttonIndex;
}


size_t IEToolbar::appendPokesButton() {
  TBBUTTON buttonDefn = {0};
  buttonDefn.fsStyle = BTNS_BUTTON | BTNS_SHOWTEXT | BTNS_AUTOSIZE;
  buttonDefn.fsState = TBSTATE_ENABLED;
  buttonDefn.idCommand = IDC_TBI_POKES;
  buttonDefn.iBitmap = 2;

  const size_t buttonIndex = toolbarWindow_.appendButton(buttonDefn);

  invalidateCountItem(buttonIndex);

  return buttonIndex;
}


size_t IEToolbar::appendRequestsButton() {
  TBBUTTON buttonDefn = {0};
  buttonDefn.fsStyle = BTNS_BUTTON | BTNS_SHOWTEXT | BTNS_AUTOSIZE;
  buttonDefn.fsState = TBSTATE_ENABLED;
  buttonDefn.idCommand = IDC_TBI_REQUESTS;
  buttonDefn.iBitmap = 3;

  const size_t buttonIndex = toolbarWindow_.appendButton(buttonDefn);

  invalidateCountItem(buttonIndex);

  return buttonIndex;
}


size_t IEToolbar::appendMesssagesButton() {
  TBBUTTON buttonDefn = {0};
  buttonDefn.fsStyle = BTNS_BUTTON | BTNS_SHOWTEXT | BTNS_AUTOSIZE;
  buttonDefn.fsState = TBSTATE_ENABLED;
  buttonDefn.idCommand = IDC_TBI_MESSAGES;
  buttonDefn.iBitmap = 4;

  const size_t buttonIndex = toolbarWindow_.appendButton(buttonDefn);

  invalidateCountItem(buttonIndex);

  return buttonIndex;
}


size_t IEToolbar::appendEventInvsButton() {
  TBBUTTON buttonDefn = {0};
  buttonDefn.fsStyle = BTNS_BUTTON | BTNS_SHOWTEXT | BTNS_AUTOSIZE;
  buttonDefn.fsState = TBSTATE_ENABLED;
  buttonDefn.idCommand = IDC_TBI_EVENTINVS;
  buttonDefn.iBitmap = 5;

  const size_t buttonIndex = toolbarWindow_.appendButton(buttonDefn);

  invalidateCountItem(buttonIndex);

  return buttonIndex;
}


size_t IEToolbar::appendGroupInvsButton() {
  TBBUTTON buttonDefn = {0};
  buttonDefn.fsStyle = BTNS_BUTTON | BTNS_SHOWTEXT | BTNS_AUTOSIZE;
  buttonDefn.fsState = TBSTATE_ENABLED;
  buttonDefn.idCommand = IDC_TBI_GROUPINVS;
  buttonDefn.iBitmap = 6;

  const size_t buttonIndex = toolbarWindow_.appendButton(buttonDefn);

  invalidateCountItem(buttonIndex);

  return buttonIndex;
}


size_t IEToolbar::appendShareButton() {
  TBBUTTON buttonDefn = {0};
  buttonDefn.fsStyle = BTNS_BUTTON | BTNS_SHOWTEXT;
  buttonDefn.fsState = TBSTATE_ENABLED;
  buttonDefn.idCommand = IDC_TBI_SHARE;
  buttonDefn.iString = -1;
  buttonDefn.iBitmap = -1;

  const size_t buttonIndex = toolbarWindow_.appendButton(buttonDefn);

  toolbarWindow_.setItemImageToNone(buttonIndex);

  return buttonIndex;
}


size_t IEToolbar::appendProfileButton() {
  TBBUTTON buttonDefn = {0};
  buttonDefn.fsStyle = BTNS_BUTTON | BTNS_SHOWTEXT | BTNS_AUTOSIZE;
  buttonDefn.fsState = TBSTATE_ENABLED;
  buttonDefn.idCommand = IDC_TBI_PROFILE;

  const size_t buttonIndex = toolbarWindow_.appendButton(buttonDefn);

  toolbarWindow_.setItemImageToNone(buttonIndex);

  return buttonIndex;
}


size_t IEToolbar::appendStatusEdit() {
  const size_t spacerIndex = toolbarWindow_.appendFixedSpacer(statusEditWidth_);

  toolbarWindow_.setItemCommand(spacerIndex, IDC_TBI_STATUS);

  const DWORD editStyles = WS_CHILD | WS_VISIBLE | WS_TABSTOP;
  const BOOL createResult = statusEdit_.Create(editStyles, CRect(),
      &toolbarWindow_, IDC_TBI_STATUS);

  if (FALSE == createResult) {
    throw Error("Failed to append status edit\n");
  }

  statusEdit_.SetFont(toolbarWindow_.GetFont());
  statusEdit_.setPromptText(ResourceMessages::getMessage(kToolbarSetYourStatus));
  statusEdit_.setPromptColor(cueBannerColor_);
  statusEdit_.setDefaultText(ResourceMessages::getMessage(kToolbarStatusPrefix));
  statusEdit_.setText(statusEdit_.getPromptText());

  return spacerIndex;
}


size_t IEToolbar::appendLoginButton() {
  TBBUTTON buttonDefn = {0};
  buttonDefn.fsStyle = BTNS_BUTTON | BTNS_SHOWTEXT | BTNS_AUTOSIZE;
  buttonDefn.fsState = TBSTATE_ENABLED;
  buttonDefn.idCommand = IDC_TBI_LOGIN;

  const size_t buttonIndex = toolbarWindow_.appendButton(buttonDefn);
  toolbarWindow_.setItemImageToNone(buttonIndex);

  return buttonIndex;
}


void IEToolbar::destroyToolbarWindow() {
  toolbarWindow_.DestroyWindow();
}


void IEToolbar::setCountItemValue(const size_t itemIndex, 
                                  const size_t value) {
  const String valueText = boost::lexical_cast<String>(value);

  toolbarWindow_.setItemText(itemIndex, valueText);

  if (value) {
    toolbarWindow_.showItem(itemIndex);
  } else {
    toolbarWindow_.hideItem(itemIndex);
  }
}


void IEToolbar::invalidateCountItem(const size_t itemIndex) {
  toolbarWindow_.setItemText(itemIndex, loadString(IDS_COUNTITEM_INVALIDTEXT));

  toolbarWindow_.showItem(itemIndex);
}


void IEToolbar::setPokesCount(const size_t pokesCount) {
   setCountItemValue(pokesButtonIndex_, pokesCount);
}


void IEToolbar::setRequestsCount(const size_t requestsCount) {
   setCountItemValue(requestsButtonIndex_, requestsCount);
}


void IEToolbar::setMessagesCount(const size_t messagesCount) {
   setCountItemValue(messagesButtonIndex_, messagesCount);
}


void IEToolbar::setEventInvsCount(const size_t eventInvsCount) {
   setCountItemValue(eventInvsButtonIndex_, eventInvsCount);
}


void IEToolbar::setGroupInvsCount(const size_t groupInvsCount) {
   setCountItemValue(groupInvsButtonIndex_, groupInvsCount);
}


void IEToolbar::setProfileName(const String& profileName) {
  const String profileButtonText = String(_T("  ")) + profileName;

  toolbarWindow_.setItemText(profileButtonIndex_, profileButtonText);
}


void IEToolbar::setStatusText(const String& statusText) {
  // do not set status if the status window is active, 

  if (GetActiveWindow() == statusEdit_.GetSafeHwnd() ||
    GetFocus() == statusEdit_.GetSafeHwnd()) {
    return;
  }
  // also if current text is the same as statusText
  if (statusText != statusEdit_.getEnteredText()) {
    statusEdit_.setText(decodeCharsHtmlCode(statusText));
  }
}


void IEToolbar::loggedIn() {
  // If we have already read data for 
  // logged in user then do nothing
  if (toolbarState_ == TS_USER_LOGGED_IN) {
    return;
  }

  toolbarState_ = TS_USER_LOGGED_IN;

  retrieveInitialData();

  toolbarWindow_.showItem(profileButtonIndex_);
  toolbarWindow_.showItem(statusEditIndex_);
  //toolbarWindow_.showItem(loginSpacerIndex_);

  toolbarWindow_.setItemText(loginButtonIndex_, 
    _T("  ") + ResourceMessages::getMessage(kToolbarButtonLogout));

  toolbarWindow_.setItemCommand(loginButtonIndex_, IDC_TBI_LOGOUT);
}


void IEToolbar::loggedOut() {
  toolbarState_ = TS_USER_LOGGED_OUT;

  invalidateData();

  toolbarWindow_.hideItem(profileButtonIndex_);
  toolbarWindow_.hideItem(statusEditIndex_);
  //toolbarWindow_.hideItem(loginSpacerIndex_);

  toolbarWindow_.setItemText(loginButtonIndex_, 
      _T("  ") + ResourceMessages::getMessage(kToolbarButtonLoginToFacebook));

  toolbarWindow_.setItemCommand(loginButtonIndex_, IDC_TBI_LOGIN);
}


void IEToolbar::retrieveInitialData() {
  const UserData loggedInUser =
      UserDataObserver::getInstance().getLoggedInUser();
  setProfileName(loggedInUser.getName());
  setStatusText(loggedInUser.getStatusMessage());
  setPokesCount(UserDataObserver::getInstance().getPokesCount());
  setRequestsCount(UserDataObserver::getInstance().getRequestsCount());
  setMessagesCount(UserDataObserver::getInstance().getMessagesCount());
  setEventInvsCount(UserDataObserver::getInstance().getEventsCount());
  setGroupInvsCount(UserDataObserver::getInstance().getGroupsInvsCount());
}


void IEToolbar::invalidateData() {
  invalidateCountItem(pokesButtonIndex_);
  invalidateCountItem(requestsButtonIndex_);
  invalidateCountItem(messagesButtonIndex_);
  invalidateCountItem(eventInvsButtonIndex_);
  invalidateCountItem(groupInvsButtonIndex_);
}


void IEToolbar::doNavigate(const String& targetUrl) const {
  IWebBrowser2Ptr browser = getWebBrowser();
  BrowserUtils::navigate(browser, targetUrl);
}


bool IEToolbar::onCommand(const size_t command) {
  if (toolbarCommandActions.find(command) != toolbarCommandActions.end()) {
    // if not logged on then dont allow to do the action
    // for some actions - still allow
    if (UserDataObserver::getInstance().isLoggedIn(false) ||
        command == IDC_TBI_HOME) {
      doNavigate(toolbarCommandActions[command]);
    } else {
      UserDataObserver::getInstance().login();
    }
    return true;
  }

  switch (command) {
  case IDC_TBI_SIDEBAR:
    return onSidebarCmd();
  case IDC_TBI_SHARE:
    return onShareCmd();
  case IDC_TBI_LOGIN:
    return onLoginCmd();
  case IDC_TBI_LOGOUT:
    return onLogoutCmd();
  case ID_QL_TOOLBARSETTINGS:
    return onQuickLinksToolbarSettingsCmd();
  default:
    return onLanguageChanged(command);
  }
}


bool IEToolbar::onNotify(const size_t controlId, const NMHDR& messageInfo,
                         LRESULT& lResult) {
  UNREFERENCED_PARAMETER(controlId);

  if (controlId == AFX_IDW_TOOLBAR) {
    return onToolbarNotify((NMTOOLBAR&)messageInfo, lResult);
  }

  if (messageInfo.code == TTN_NEEDTEXTW) {
    return onNeedToolTipText((NMTTDISPINFOW&)messageInfo, lResult);
  }

  return false;
}


bool IEToolbar::onNeedToolTipText(NMTTDISPINFOW& messageInfo,
                                  LRESULT& lResult) {
  // Load string from resources accordingly to control(command) identifier.
  String toolTipText = loadString(messageInfo.hdr.idFrom);

  toolTipText = ResourceMessages::getMessage(toolTipText);

  // Copy loaded string into message's data structure.
  messageInfo.lpszText = SysAllocStringLen(toWiden(toolTipText).c_str(),
      toolTipText.size());

  lResult = TRUE;

  return true;
}


bool IEToolbar::onToolbarNotify(const NMTOOLBAR& messageInfo,
                                LRESULT& lResult) {
  switch (messageInfo.hdr.code) {
  case TBN_DROPDOWN:
    return onToolbarDropdown(messageInfo, lResult);
  case NM_SETFOCUS:
    return onToolbarSetFocus(messageInfo, lResult);
  case NM_KILLFOCUS:
    return onToolbarKillFocus(messageInfo, lResult);
  case NM_CUSTOMDRAW:
    return onToolbarCustomDraw((NMTBCUSTOMDRAW&)messageInfo, lResult);
  default:
    return false;
  }
}


bool IEToolbar::onToolbarSetFocus(const NMTOOLBAR& messageInfo,
                                  LRESULT& lResult) {
  UNREFERENCED_PARAMETER(messageInfo);
  UNREFERENCED_PARAMETER(lResult);

  const IUnknownPtr control = getControlUnknown();

  const HRESULT chageFocusResult = site_->OnFocusChangeIS(control, TRUE);

  if (FAILED(chageFocusResult)) {
    _com_raise_error(chageFocusResult);
  }

  return true;
}


bool IEToolbar::onToolbarKillFocus(const NMTOOLBAR& messageInfo,
                                   LRESULT& lResult) {
  UNREFERENCED_PARAMETER(messageInfo);
  UNREFERENCED_PARAMETER(lResult);

  const IUnknownPtr control = getControlUnknown();
  const HRESULT chageFocusResult = site_->OnFocusChangeIS(control, FALSE);
  if (FAILED(chageFocusResult)) {
    _com_raise_error(chageFocusResult);
  }

  return true;
}


bool IEToolbar::onToolbarDropdown(const NMTOOLBAR& messageInfo,
                                  LRESULT& lResult) {
  if (messageInfo.iItem == IDC_TBI_QUICKLINKS) {
    return onQuickLinksDropdown(messageInfo, lResult);
  }

  return false;
}


bool IEToolbar::onToolbarCustomDraw(const NMTBCUSTOMDRAW& messageInfo,
                                    LRESULT& lResult) {
  if (messageInfo.nmcd.dwDrawStage == CDDS_PREPAINT) {
    lResult = CDRF_NOTIFYITEMDRAW;
    return true;
  }

  if (messageInfo.nmcd.dwDrawStage == CDDS_POSTPAINT) {
    lResult = CDRF_DODEFAULT;
    return true;
  }

  if (messageInfo.nmcd.dwDrawStage == CDDS_ITEMPREPAINT) {
    lResult = CDRF_NOTIFYPOSTPAINT;
    return true;
  }

  if (messageInfo.nmcd.dwDrawStage == CDDS_ITEMPOSTPAINT) {
    if (messageInfo.nmcd.dwItemSpec == IDC_TBI_SHARE) {
      return onShareButtonDraw(messageInfo, lResult);
    }
    // refresh layout on dynamic separator redraw - it may drop our resize
    if (messageInfo.nmcd.dwItemSpec == IDC_TBI_SEPARATOR) {
      toolbarWindow_.refreshLayout();
    }
  }

  return false;
}


bool IEToolbar::onShareButtonDraw(const NMTBCUSTOMDRAW& messageInfo, 
                                  LRESULT& lResult) {
  const HDC& deviceCntxHadle = messageInfo.nmcd.hdc;
  const UINT itemState = messageInfo.nmcd.uItemState;

  CDC* deviceCntx = CDC::FromHandle(deviceCntxHadle);

  // Prepare device context to load image into.
  CDC memDC;
  memDC.CreateCompatibleDC(deviceCntx);
  memDC.SetMapMode(deviceCntx->GetMapMode());

  // Determine which image load into memory device context and load it.
  const bool isHot = (itemState == CDIS_HOT);
  CBitmap* oldBmp = memDC.SelectObject(isHot ?
      getPtr(shareHotButtonBitmap_) : getPtr(shareButtonBitmap_));

  // Calculate position to draw the image.
  const CRect itemRect = toolbarWindow_.getItemRect(shareButtonIndex_);
  const CSize bitmapSize = getBitmapSize(shareButtonBitmap_);
  const int xOffset = (itemRect.Width() - bitmapSize.cx) / 2;
  const int yOffset = (itemRect.Height() - bitmapSize.cy) / 2;

  // Draw the image.
  const BOOL bitBltResult = deviceCntx->BitBlt(itemRect.left, itemRect.top,
      itemRect.Width(), itemRect.Height(), &memDC, -xOffset, -yOffset, SRCCOPY);
  if (FALSE == bitBltResult) {
    throw Error("Failed to draw share button image/n");
  }

  memDC.SelectObject(oldBmp);

  lResult = CDRF_SKIPDEFAULT;

  return true;
}

BitmapPtr IEToolbar::generateShareBitmap(bool isHot) {
  const int textMargin = 3;
  const int bitmapHeight = 16;
  const int bitmapMargin = 2;

  const COLORREF grey = RGB(227, 232, 240);
  const COLORREF blue = RGB(57, 86, 149);

  // Set colors and plus bitmap
  UINT plusIconId = (isHot) ? IDB_SHARE_PLUS : IDB_SHARE_HOT_PLUS;
  COLORREF bkColor = (isHot) ? blue : grey;
  COLORREF bkFrameColor = (isHot) ? grey : blue;
  COLORREF txtColor = (isHot) ? grey : blue;

  // Load Plus bitmap and get its properties
  BITMAP bm;
  BitmapPtr plusIcon = loadBitmap(plusIconId);
	plusIcon->GetBitmap(&bm);
	int plusIconWidth = bm.bmWidth;
  int plusIconHeight = bm.bmHeight;

  // Create destination context
  CDC memDC;
  CFont font;
  CDC* deviceContext = CDC::FromHandle(::GetDC(0));
  memDC.CreateCompatibleDC(deviceContext);
  setFont(&memDC, 14, _T("Sans Serif"), font);

  // Get message length in pixels
  String message = ResourceMessages::getMessage(kToolbarButtonShare);
  SIZE textSize = getMessageLength(message, font);

  // Create destination bitmap
  BitmapPtr bitmap(new CBitmap());
  int bitmapWidth = 2 * textMargin + textSize.cx + 2 * bitmapMargin + plusIconWidth;
  bitmap->CreateCompatibleBitmap(deviceContext, bitmapWidth, bitmapHeight);
  memDC.SelectObject(getPtr(bitmap));

  // Draw background with frame
  CRect frame(0, 0, bitmapWidth, bitmapHeight) ; 
  memDC.FillSolidRect(&frame , bkFrameColor);
  CRect rectangle(1, 1, bitmapWidth - 1, bitmapHeight - 1) ; 
  memDC.FillSolidRect(&rectangle , bkColor);
 
  // Draw message
  memDC.SetTextColor(txtColor);
  CRect textRect(1 + textMargin, 1, bitmapWidth - 1, bitmapHeight - 1) ; 
  memDC.DrawText(message.c_str(), message.length(), textRect, DT_SINGLELINE | DT_VCENTER);

  // Draw plus bitmap
  CDC srcDC;
  srcDC.CreateCompatibleDC(NULL);
  srcDC.SelectObject(getPtr(plusIcon));
  const BOOL bitBltResult = memDC.BitBlt(bitmapWidth - bitmapMargin - plusIconWidth, bitmapMargin,
      plusIconWidth, plusIconHeight, &srcDC, 0, 0, SRCCOPY);
  if (FALSE == bitBltResult) {
    throw Error("Failed to draw share button image/n");
  }

  // Delete resources
  font.DeleteObject();
  DeleteDC(srcDC);
  DeleteDC(memDC);

  return bitmap;
}

void IEToolbar::buildLanguagesSubMenu(CMenu& menu) {

  CMenu* languagesMenu = menu.GetSubMenu(14);
  languagesMenu->RemoveMenu(0, MF_BYPOSITION);
  // get the current submenu list
  std::map<String, String> languages = ResourceMessages::getCulturesList();
  std::map<String, String>::iterator languageIterator;
  // fill all the available languages
  int languageIndex = ID_LANGUAGE;
  for (languageIterator = languages.begin(); languageIterator != languages.end();
    ++languageIterator) {
      UINT nFlags = MF_STRING;
      if ((*languageIterator).first == ResourceMessages::getInstance().getCurrentCulture()) {
        nFlags |= MF_CHECKED;
      }
      languagesMenu->AppendMenu(nFlags, languageIndex, (*languageIterator).second.c_str());
    ++languageIndex;
  }
}


bool IEToolbar::onQuickLinksDropdown(const NMTOOLBAR& messageInfo, 
                                     LRESULT& lResult) {
  UNREFERENCED_PARAMETER(messageInfo);
  lResult = TBDDRET_DEFAULT;
  // if not logged on then dont allow to see menu
  if (!UserDataObserver::getInstance().isLoggedIn(false)) {
    UserDataObserver::getInstance().login();
  } else {
    // Prepare menu.
    CMenu menu;
    loadQuickLinksMenu(menu);
    CMenu* settingsSubMenu = menu.GetSubMenu(0);
    if (!settingsSubMenu) {
      throw Error("Failed to get quick links sub-menu\n");
    }

    //get all the menu items messages
    for (unsigned int index = 0; index < settingsSubMenu->GetMenuItemCount(); ++index) {
      ToolbarWindow::updateItem(settingsSubMenu, index);
    }
    // get the language popup submenu caption
    String message = ResourceMessages::getMessage(kToolbarMenuLanguage);
    settingsSubMenu->ModifyMenu(14, MF_BYPOSITION | MF_STRING, 0, message.c_str());

    // Set pop-up menu flags.
    const UINT trackFlags = TPM_LEFTALIGN | TPM_RIGHTBUTTON;

    // Calculate quick links button rect to show menu in appropriate position.
    CRect quickLinksButtonRect = toolbarWindow_.getItemRect(
        quickLinksButtonIndex_);
    toolbarWindow_.MapWindowPoints(0, quickLinksButtonRect);

   
    // get the language submenu
    buildLanguagesSubMenu(*settingsSubMenu);
    
    // Track pop-up menu.
    // Determine if MS Windows is right aligned and set x position
    // of the menu
    int x = isBiDi(LOCALE_SYSTEM_DEFAULT) ? quickLinksButtonRect.right :
      quickLinksButtonRect.left;
    const BOOL trackResult = settingsSubMenu->TrackPopupMenu(trackFlags,
      x, quickLinksButtonRect.bottom, &siteWindow_);
    if (FALSE == trackResult) {
      throw Error("Failed to track quick links menu\n");
    }

  }
  return true;
}


bool IEToolbar::onSidebarCmd() {
  const String friendsSidebarClassID = toString(CLSID_IESidebar);

  variant_t friendsSideBarGuid = toBSTR(friendsSidebarClassID);

  const BOOL sideBarIsOpen = RuntimeContext::isSidebarOpened();

  variant_t showFlag(sideBarIsOpen ? VARIANT_FALSE : VARIANT_TRUE, VT_BOOL);

  IWebBrowser2Ptr browser = getWebBrowser();

  const HRESULT showSidebarReas = browser->ShowBrowserBar(&friendsSideBarGuid,
      &showFlag, 0);
  if (FAILED(showSidebarReas)) {
    _com_raise_error(showSidebarReas);
  }

  // Update the filter on sidebar if we are opening the sidebar,
  // if it was opened and we are closing it - no
  if (!sideBarIsOpen) {
    String filterText = searchEdit_.getEnteredText();
    if (filterText == searchEdit_.getPromptText()) {
      filterText = _T("");
    }
    HWND sideBarHwnd = RuntimeContext::getSidebarHwnd();
    if (sideBarHwnd) {
      String* filterMessageParam = new String(filterText);
      ::PostMessage(sideBarHwnd, TBM_FILTER_CHANGED, 0,
          (LPARAM)filterMessageParam);
    }
  }

  return true;
}


bool IEToolbar::onShareCmd() {

   // if not logged on then dont allow to do the action
  if (!UserDataObserver::getInstance().isLoggedIn(false)) {
    UserDataObserver::getInstance().login();
  } else {
    const unsigned int shareWindowWidth = 626;
    const unsigned int shareWindowHeight = 436;

    const IWebBrowser2Ptr browser = getWebBrowser();

    BSTR locationAsBSTR;
    const HRESULT getLocationUrl = browser->get_LocationURL(&locationAsBSTR);
    if (SUCCEEDED(getLocationUrl)) {
      _bstr_t bstrLocationHolder(locationAsBSTR);
      SysFreeString(locationAsBSTR);
      String locationUrl = bstrLocationHolder;

      BSTR nameAsBSTR;
      //get the title if possible
      String locationName;
      const HRESULT getLocationName = browser->get_LocationName(&nameAsBSTR);
      if (SUCCEEDED(getLocationName)) {
        _bstr_t bstrNameHolder(nameAsBSTR);
         SysFreeString(nameAsBSTR);
         locationName = bstrNameHolder;
      }
      locationUrl = buildShareContentURL(locationUrl, locationName);
      BrowserUtils::IEPopup(locationUrl, shareWindowWidth, shareWindowHeight);
    }
  }

  return true;
}


bool IEToolbar::onLoginCmd() {
  UserDataObserver::getInstance().login();
  return true;
}


bool IEToolbar::onLogoutCmd() {
  UserDataObserver::getInstance().logout();
  return true;
}


bool IEToolbar::onQuickLinksToolbarSettingsCmd() {
  ToolbarSettingsDlg settingsDialog;
  settingsDialog.DoModal();

  return true;
}

bool IEToolbar::onLanguageChanged(size_t command) {
  // handle only kMaxCultures possible languages
  if (command < ID_LANGUAGE || command > ID_LANGUAGE + kMaxCultures) {
    return false;
  }
  size_t languageIndex = command - ID_LANGUAGE;
  ResourceMessages::setCurrentCulture(languageIndex);
  UserDataObserver::getInstance().updateView(0);
  return true;
}


void IEToolbar::dataUpdated(unsigned long dataId) {
  UserDataObserver& dataObserver = UserDataObserver::getInstance();

  //LOG4CPLUS_DEBUG(LogUtils::getLogger(), "IEToolbar::dataUpdated dataId = " << dataId);
  switch (dataId) {
  case FBM_POKES_COUNT_UPDATED:
    return setPokesCount(dataObserver.getPokesCount(false));
  case FBM_MESSAGES_CONT_UPDATED:
    return setMessagesCount(dataObserver.getMessagesCount(false));
  case FBM_REQUESTS_COUNT_PDATED:
    return setRequestsCount(dataObserver.getRequestsCount(false));
  case FBM_EVENTS_INVINTAIONS_COUNT_UPDATED:
    return setEventInvsCount(dataObserver.getEventsCount(false));
  case FBM_GROUPS_INVINTAIONS_COUNT_UPDATED:
    return setGroupInvsCount(dataObserver.getGroupsInvsCount(false));
  case FBM_MY_STATUS_UPDATED:
    setProfileName(dataObserver.getLoggedInUser(false).getName());
    setStatusText(dataObserver.getLoggedInUser(false).getStatusMessage());
    return;
  case FBM_JUST_LOGGED_IN:
    return loggedIn();
  case FBM_LOGOUT_INITIATED:
    return loggedOut();
  case FBM_UPDATE_VIEW:
    //updateView();
    break;
  }
}
void IEToolbar::sidebarIsOpen() {
  const BYTE sidebarButtonState = toolbarWindow_.getItemState(
      sidebarButtonIndex_);

  toolbarWindow_.setItemState(sidebarButtonIndex_,
      sidebarButtonState | TBSTATE_CHECKED);
}


void IEToolbar::sidebarIsClosed() {
  const BYTE sidebarButtonState = toolbarWindow_.getItemState(
      sidebarButtonIndex_);

  toolbarWindow_.setItemState(sidebarButtonIndex_,
       sidebarButtonState & ~TBSTATE_CHECKED);

  // If we close the sidebar then remove the focus from the search edit.
  searchEdit_.KillFocus();
}

void IEToolbar::updateView(int changeId) {
  EnterCriticalSection(&critialSection_);

  UNREFERENCED_PARAMETER(changeId);
  if (!toolbarWindow_.GetSafeHwnd()) {
    LeaveCriticalSection(&critialSection_);
    // do not update if we are empty
    return;
  }
  try {

    toolbarWindow_.setItemText(quickLinksButtonIndex_, 
      _T("  ") + ResourceMessages::getMessage(kToolbarButtonQuickLinks));

    if (toolbarWindow_.getItemCommand(loginButtonIndex_) == IDC_TBI_LOGIN) {
      toolbarWindow_.setItemText(loginButtonIndex_, 
        _T("  ") + ResourceMessages::getMessage(kToolbarButtonLoginToFacebook));
    } else {
      toolbarWindow_.setItemText(loginButtonIndex_, 
        _T("  ") + ResourceMessages::getMessage(kToolbarButtonLogout));
    }

    // Update Share button
    resizeShareButton();
    shareButtonBitmap_ = generateShareBitmap(false);
    shareHotButtonBitmap_ = generateShareBitmap(true);

  } catch (...) {
    // dont crash if we can't find button, 
    // better do nothing -> there would be another tries
  }

  

  LeaveCriticalSection(&critialSection_);
}

void IEToolbar::resizeShareButton() {
  SIZE textSize, spaceSize;
  HFONT windowFont = (HFONT)::SendMessage(toolbarWindow_.GetSafeHwnd(), WM_GETFONT, 0, 0);
  HDC context = ::GetDC(toolbarWindow_.GetSafeHwnd());
  SelectObject(context, windowFont);

  String message = ResourceMessages::getMessage(kToolbarButtonShare);
  GetTextExtentPoint32(context, message.c_str(), message.length(), &textSize);
  GetTextExtentPoint32(context, _T(" "), 1, &spaceSize);

  const size_t buttonTextWidth = textSize.cx / spaceSize.cx + 6;
  const String text(buttonTextWidth, _T(' '));
  toolbarWindow_.setItemText(shareButtonIndex_, text.c_str());

  ReleaseDC(toolbarWindow_.GetSafeHwnd(), context);
}

} // namespace facebook

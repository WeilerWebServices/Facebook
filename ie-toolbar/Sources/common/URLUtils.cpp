/**
* Facebook Internet Explorer Toolbar Software License 
* Copyright (c) 2009 Facebook, Inc. 
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (which, together with any graphical images included with such
* software, are collectively referred to below as the "Software") to (a) use,
* reproduce, display, distribute, execute, and transmit the Software, (b)
* prepare derivative works of the Software (excluding any graphical images
* included with the Software, which may not be modified or altered), and (c)
* permit third-parties to whom the Software is furnished to do so, all
* subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.  
*
* Facebook, Inc. retains ownership of the Software and all associated
* intellectual property rights.  All rights not expressly granted in this
* license are reserved by Facebook, Inc.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/ 

#include "StdAfx.h"
#include "UrlUtils.h"

#pragma warning(disable : 4180)
#pragma warning(disable : 4244)

#include <boost/format.hpp>
#include <boost/regex.hpp>
#include <boost/algorithm/string/case_conv.hpp>
#include <boost/algorithm/string/replace.hpp>
#include <boost/algorithm/string/trim.hpp>
#include <boost/algorithm/string/regex.hpp>


#ifdef _UNICODE
  typedef boost::wregex Regex;
#else
  typedef boost::regex Regex;
#endif

namespace facebook{

String buildShareContentURL(const String& contentUrl, const String& title) {
  StringStream ss;
  ss << kFacebookRoot 
    << kSharePage 
    <<  _T("?src=tb&v=4&u=") 
    << encodeUrl(contentUrl)
    <<  _T("&t=") 
    <<  encodeUrl(title);
  return ss.str(); 
}

String buildActionURL(const String& actionPage, 
                      const String& userID,
                      const bool needEncode) {
  StringStream ss;
  ss << kFacebookRoot << actionPage;

  String targetPageInUpperCase = boost::to_upper_copy(actionPage);
  boost::trim(targetPageInUpperCase);
  if (targetPageInUpperCase ==   boost::to_upper_copy(kSearchPage)) {
    ss << _T("?q=");
  } else {
    ss << _T("?id=");
  }

  if (needEncode) {
    ss  << encodeUrl(userID); 
  } else {
    ss  << userID;
  }

  return ss.str(); 
}

String buildSearchURL(const String& searchQuery) {
  StringStream ss;
  ss << kFacebookRoot 
     << kSearchPage 
     << _T("?q=") 
     << encodeUrl(searchQuery);
  return ss.str(); 

}

String buildUserProfileUrl(const String& userID) {
  StringStream ss;
  ss << kFacebookRoot 
    << kProfilePage 
    << _T("?id=")  
    << userID; 

  return ss.str(); 
}

String buildHtmlResourceUrl(const String& moduleName, const UINT resID) {
  // RT_HTML is a number but in LPSTR type, 
  // we need to use WORD value to build URL
  return buildResourceUrl(moduleName, (WORD) RT_HTML, resID);
}

String buildResourceUrl(const String& moduleName, const UINT resType, const UINT resID) {
  StringStream ss;
  String newPath = boost::replace_all_copy(moduleName, _T("\\"), _T("\\\\"));
  ss << _T("res://") 
    <<  newPath  
    << "/" 
    << resType 
    << "/" 
    << resID;
  return ss.str(); 
}

String buildUserStatusUrl(const String& userID) {
  StringStream ss;
  ss << kFacebookRoot 
    << kProfilePage 
    << _T("?id=")  
    << userID
    << _T("#status\n");

  return ss.str(); 
}

String buildUserInboxUrl() {
  StringStream ss;

  ss << kFacebookRoot 
    << kMessagesPage
    << "\n";

  return ss.str(); 
}

String buildPokeFriendUrl() {
  StringStream ss;

  ss << kFacebookRoot 
    << kHomePage
    << "\n";

  return ss.str(); 
}

String buildFriendsRequestUrl() {
  StringStream ss;

  ss << kFacebookRoot 
    << kRequestsPage
    << "\n";

  return ss.str(); 
}

String buildUserWallUrl(const String& userID) {
  StringStream ss;
  ss << kFacebookRoot 
    << kProfilePage 
    << _T("?id=")  
    << userID
    << _T("#wall\n");

  return ss.str(); 
}

String buildUserNotesUrl(const String& userID) {
  StringStream ss;
  ss << kFacebookRoot 
    << kNotesPage 
    << _T("?id=")  
    << userID;

  return ss.str(); 
}

String buildUpdateProfileUrl(const String& userID) {
  StringStream ss;
  ss << kFacebookRoot 
    << kProfilePage 
    << _T("?id=")  
    << userID
    << _T("&highlight");

  return ss.str(); 
}

bool isCustomAction(const String& url) {
  return (url.find(kCustomActionPrefix) == 0);
}

bool isOrdinaryChar(TCHAR c) {
  TCHAR ch = towlower(c);
  if ((ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9')) {
      return true;
  }
  return false;
}

NarrowString encodeUtf8(const String originalString) {
  NarrowString result;
  WORD byteSymbol;
  size_t length = originalString.size();
  for (size_t i = 0; i < length; ++i) {
    byteSymbol = (WORD)originalString.at(i);
    if (byteSymbol < 128) {
      result += (char)(byteSymbol);
    } else if (byteSymbol < 2048) {
      result += (char)((byteSymbol >> 6) | 192);
      result += (char)((byteSymbol & 63) | 128);
    } else {
      result += (char)((byteSymbol >> 12) | 224);
			result += (char)(((byteSymbol >> 6) & 63) | 128);
		  result += (char)((byteSymbol & 63) | 128);
    }
  }
  return result;
}


String encodeUrl(const String& url) {
  String result;
  NarrowString simpleString = encodeUtf8(url);
  int length = simpleString.size();
  boost::wformat format(_T("%%%x"));
  for (int i = 0; i < length; ++i) {
    if (isOrdinaryChar(simpleString.at(i))) {
      result += simpleString.at(i);
    } else if (simpleString.at(i) == _T(' ')) {
      result += _T("+");
    } else {
      result += (format % (BYTE)simpleString.at(i)).str();
    }
  }
  return result;
}

bool isCorrectUrl(String url) {
  bool result = false;
  String regexString = String(_T("^(https?://)"))
  + String(_T("?(([0-9a-z_!~*'().&=+$%-]+: )?[0-9a-z_!~*'().&=+$%-]+@)?")) //user@
  + String(_T("(([0-9]{1,3}\\.){3}[0-9]{1,3}")) // IP- 199.194.52.184
  + String(_T("|")) // allows either IP or domain
  + String(_T("([0-9a-z_!~*'()-]+\\.)*")) // tertiary domain(s)- www.
  + String(_T("([0-9a-z][0-9a-z-]{0,61})?[0-9a-z]\\.")) // second level domain
  + String(_T("[a-z]{2,6})")) // first level domain- .com or .museum
  + String(_T("(:[0-9]{1,4})?")) // port number- :80
  + String(_T("((/?)|")) // a slash isn't required if there is no file name
  + String(_T("(//?[0-9a-z_!~*'().;?:@&=+$,%#-]+)+/?)$")); 
  Regex urlRegex(regexString);
  if (regex_match(url, urlRegex)) {
    result = true;
  }
  return result;
}

std::vector<String> splitUrl(String url) {
  std::vector<String> result;
  using namespace boost;
  using namespace boost::algorithm;
  split_regex(result, url, regex("/"));
  return result;
}

} // !namespace facebook
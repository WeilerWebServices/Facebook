/**
* Facebook Internet Explorer Toolbar Software License 
* Copyright (c) 2009 Facebook, Inc. 
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (which, together with any graphical images included with such
* software, are collectively referred to below as the "Software") to (a) use,
* reproduce, display, distribute, execute, and transmit the Software, (b)
* prepare derivative works of the Software (excluding any graphical images
* included with the Software, which may not be modified or altered), and (c)
* permit third-parties to whom the Software is furnished to do so, all
* subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.  
*
* Facebook, Inc. retains ownership of the Software and all associated
* intellectual property rights.  All rights not expressly granted in this
* license are reserved by Facebook, Inc.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/ 

#include "StdAfx.h"
#include "ResourceMessages.h"

#include "CommonConstants.h"
#include <mshtml.h>
#include <string>

#include <boost/bind.hpp>

#include "../data/ToolbarSettings.h"
#include "../util/COMWrappers.h"
#include "../util/RegistryUtils.h"
#include "../util/ResourceUtils.h"
#include "../util/ShellUtils.h"
#include "../util/ScopeGuard.h"
#include "../util/XMLUtils.h"


namespace facebook{

const String kDefaultCultureId = _T("default");
const String kDefaultCultureOriginalId = _T("en-us");

/**
 * class CultureInfo
 *
 * Main class for handling one Culture.
 */
class CultureInfo {

public:

  typedef std::map<String, String> Dictionary;

public:

  CultureInfo():id_(kDefaultCultureId), isRightAligned_(false) {}

  CultureInfo(const String id):id_(id), isRightAligned_(false) {}

  ~CultureInfo() {};

  String getId() const { return id_; }
  void setId(const String id) { id_ = id; }

  /**
   * Gets the messge to the key in this culture
   *
   * @param key - message to get.
   * @param message - resulting message, or key if no such message
   * @return true if the message was found and false other wise
   */
  bool getMessage(const String& key, String& message) const {
    bool result = false;
    message = _T("");
    Dictionary::const_iterator index = messages_.find(key);
    if (index != messages_.end()) {
      message = (*index).second;
      result = true;
    }
    return result;
  }

  /**
   * Gets text alignment of the culture 
   * @return true - if text is right alignment, false - otherwise
   */
  bool getAlignment() {
    return isRightAligned_;
  }

  /**
   * Set text alignment of the culture
   * @param isRightAligned true - if text is right alignment, false - otherwise
   */
  void setAlignment(bool isRightAligned) {
    isRightAligned_ = isRightAligned;
  }

  /**
   * Add new message to this culture
   *
   * @param key - message key to get from culture
   * @param message - entire message
   */
  void addMessage(const String key, const String message) {
    messages_.insert(make_pair(key, message));
  }

private:

  String id_;
  Dictionary messages_;
  bool isRightAligned_;
};



// ---------------------------------------------------------------------
// class ResourceMessages
// ---------------------------------------------------------------------

ResourceMessages messages;

ResourceMessages::ResourceMessages():
  currentCulture_(NULL),
  currentCultureId_(kDefaultCultureId),
  isAutoCultureId_(true),
  defaultCultureNeeded_(true) {
  loadCurrentCulture();
}

ResourceMessages::~ResourceMessages() {
  clear();
  // clear all the cultures
  std::for_each(cultures_.begin(), cultures_.end(),
    boost::bind(&ResourceMessages::clearCulture, this,  _1));
  observers_.clear();
}

void ResourceMessages::clearCulture(CultureInfoEntry& cultureEntry) {
  delete cultureEntry.second;
}

void ResourceMessages::clear() {
  defaultCulture_.reset();
}

String ResourceMessages::getCulture(int index) {
  String result;
  CultureInfoMap::iterator cultureIndex;
  for (cultureIndex = messages.cultures_.begin(); 
       cultureIndex != messages.cultures_.end();
        ++cultureIndex) {
    // skip if empty culture
    if (!(*cultureIndex).second) {
      continue;
    }
    // if we have needed culture index then break
    if (index-- == 0) {
        result = ((*cultureIndex).first);
        break;
      }
  }
  return result;
  
}

void ResourceMessages::setCurrentCulture(int index) {
  String cultureId = messages.getCulture(index);
  if (!cultureId.empty()) {
     messages.setCurrentCulture(cultureId);
  }
}

String ResourceMessages::getMessage(const String key, bool reload) {
  if (reload) {
    messages.loadCurrentCulture();
  }
  String result;
  if (messages.currentCulture_ &&
    messages.currentCulture_->getMessage(key, result)) {
  // try to get from current culture
  } else if (!isNull(messages.defaultCulture_) &&
    messages.defaultCulture_->getMessage(key, result)) {
  // try to get from default culture
  } else {
  // return the key
    result = key;
  }
  return result;
}

bool ResourceMessages::isTextRightAligned() {
  bool result = false;
  if (messages.currentCulture_) {
    result = messages.currentCulture_->getAlignment();
  }

  return result;
}

String ResourceMessages::getCultureName(const String& fileName) {
  String result;
  unsigned int firstPosition = fileName.find('.');
  unsigned int lastPosition = fileName.rfind('.');
  if (firstPosition != String::npos &&
      lastPosition != String::npos &&
      firstPosition != lastPosition) {
    //get the culture id
    result = fileName.substr(firstPosition + 1, 
      lastPosition - firstPosition - 1);
  }
  return result;
}

void ResourceMessages::load() {
  // load the default culture
  defaultCulture_.reset(new CultureInfo(kDefaultCultureId));
  if (!readDefaultCulture(*defaultCulture_)) {
    clear();
  }
  String searchFolder = getApplicationDataDir() + _T("lang\\");
  if (searchFolder.empty()) {
    // no culture files
    return;
  }
  // get the culture files
  std::vector<String> cultureFiles = getFileList(searchFolder, 
    searchFolder + _T("*.xml"));
  std::for_each(cultureFiles.begin(), cultureFiles.end(), 
    boost::bind(&ResourceMessages::loadCulture, this, searchFolder, _1));

  currentCulture_ = cultures_[currentCultureId_];
}

void ResourceMessages::loadCulture(const String& searchFolder, const String& fileName) {
  String id = getCultureName(fileName);
  if (!id.empty()) {
    String fileFullPath = searchFolder + fileName;
    CultureInfo *data = new CultureInfo(id);
    // if the culture file is correct then add new culture, else skip data
    if (readCulture(*data, fileFullPath)) {
      cultures_[id] = data;
      // if this is en-us then we don't need default
      if (id == kDefaultCultureOriginalId) {
        defaultCultureNeeded_ = false;
      }
    } else {
      delete data;
    }
  }
}

void readCultureFromXml(CultureInfo& data, 
                        MSXML2::IXMLDOMDocumentPtr xmlDoc) {
  const String kIsRightAligned = _T("isRightAligned");

  // load the root node
  MSXML2::IXMLDOMNodePtr rootNode = xmlDoc->selectSingleNode(_T("root"));
  if (rootNode == NULL) {
    throw std::exception("failed to load xml");
  }
  // load the data nodes
  MSXML2::IXMLDOMNodeListPtr children;
  const HRESULT getChildNodesRes = rootNode->get_childNodes(&children);
  if (FAILED(getChildNodesRes)) {
    throw std::exception("failed to load data nodes");
  }

  MSXML2::IXMLDOMNodePtr dataNode = NULL;
  MSXML2::IXMLDOMNodePtr attributeNode = NULL;
  for(long index = 0;  index < children->Getlength(); ++index) {
    dataNode = children->Getitem(index);
    MSXML2::IXMLDOMNamedNodeMapPtr attributes = dataNode->Getattributes();
    if (attributes == NULL) {
      // no attributes
      continue;
    }
    // get the name attribute
    attributeNode = attributes->getNamedItem(_T("name"));
    if (attributeNode == NULL) {
      // no needed attribute
      continue;
    }

    if (XMLUtils::getNodeText(attributeNode).compare(kIsRightAligned)) {
      data.addMessage(XMLUtils::getNodeText(attributeNode), 
        XMLUtils::getNodeText(dataNode));
    } else {
      bool alignment = XMLUtils::getNodeText(dataNode).compare(_T("0")) ? true : false;
      data.setAlignment(alignment);
    }
  }
}

bool ResourceMessages::readDefaultCulture(CultureInfo& data) {
  try {
    CoInitialize(0);
    String cultureData = loadStringFromResources(kDefaultCultureResource, 
      RT_HTML);
    // load the file
    MSXML2::IXMLDOMDocumentPtr xmlDoc(MSXML2::CLSID_DOMDocument);
    const variant_t xmlLoadRes = xmlDoc->loadXML(toBSTR(cultureData));
    if (xmlLoadRes.boolVal == VARIANT_FALSE) {
      throw std::exception("failed to load xml");
    }
    readCultureFromXml(data, xmlDoc);
  }
  catch(...) {
    CoUninitialize();
    return false;
  }
  ScopeGuard coUninitializeGuard(
    boost::bind(CoUninitializeWrapper()));
  return true;
}

bool ResourceMessages::readCulture(CultureInfo& data, const String &file) {
  try {
    CoInitialize(0);
    // load the file
    MSXML2::IXMLDOMDocumentPtr xmlDoc(MSXML2::CLSID_DOMDocument);
    variant_t fileName;
    fileName = toBSTR(file);
    const variant_t xmlLoadRes = xmlDoc->load(fileName);
    if (xmlLoadRes.boolVal == VARIANT_FALSE) {
      throw std::exception("failed to load xml");
    }
    readCultureFromXml(data, xmlDoc);
  }
  catch(...) {
    CoUninitialize();
    return false;
  }

  ScopeGuard coUninitializeGuard(
    boost::bind(CoUninitializeWrapper()));
  return true;
}

void ResourceMessages::setCurrentCulture(const String id) {
  currentCultureId_ = id;
  isAutoCultureId_ = false;
  saveCurrentCulture();
  // if we set the default culture thern load it
  if (id == kDefaultCultureOriginalId && defaultCultureNeeded_) {
    currentCulture_ = NULL;
  } else {
    currentCulture_ = cultures_[id];
  }
  notifyObservers();
}

String ResourceMessages::getCurrentCulture() const {
  if (currentCultureId_.empty()) {
    return kDefaultCultureOriginalId;
  } else {
    return currentCultureId_;
  }
}

void ResourceMessages::loadCurrentCulture() {
  currentCultureId_ = ToolbarSettings::getInstance().readStringValue(TO_CURRENTCULTURE);
  currentCulture_ = cultures_[currentCultureId_];
  //notifyObservers();
}

void ResourceMessages::saveCurrentCulture() {
  ToolbarSettings::getInstance().writeValue(TO_CURRENTCULTURE, currentCultureId_);
}

ResourceMessages& ResourceMessages::getInstance() {
  return messages;
}

void ResourceMessages::subscribeObserver(ViewObserver *observer) {
  messages.observers_.push_back(observer);
}

void ResourceMessages::unsubscribeObserver(ViewObserver *observer) {
  messages.observers_.remove(observer);
}

void ResourceMessages::notifyObservers(int changeId) {
  std::for_each(observers_.begin(), observers_.end(),
    boost::bind(&ViewObserver::updateView, _1, changeId));
}

std::map<String, String> ResourceMessages::getCulturesList() {
  std::map<String, String> cultures;
  CultureInfoMap::iterator cultureIndex;
  String name;
  if (messages.defaultCultureNeeded_ && messages.defaultCulture_) {
    String defaultName;
    messages.defaultCulture_->getMessage(kCultureName, defaultName);
    cultures[kDefaultCultureOriginalId] = defaultName;
  }

  for (cultureIndex = messages.cultures_.begin(); 
       cultureIndex != messages.cultures_.end();
       ++cultureIndex) {

    CultureInfo *data = (*cultureIndex).second;
    if (!data) {
      continue;
    }
    if (data->getMessage(kCultureName, name)) {
      // If MS Windows is right alignment, replace
      // braces to the proper one for right alignment language
      if (isBiDi(LOCALE_SYSTEM_DEFAULT) && name.find(_T("(")) != String::npos) {
        name.erase(name.end() - 1, name.end());
        name =  _T("(") + name;
      }
      cultures[data->getId()] = name;
    }
  }
  return cultures;
}


} // !namespace facebook
/**
* Facebook Internet Explorer Toolbar Software License 
* Copyright (c) 2009 Facebook, Inc. 
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (which, together with any graphical images included with such
* software, are collectively referred to below as the "Software") to (a) use,
* reproduce, display, distribute, execute, and transmit the Software, (b)
* prepare derivative works of the Software (excluding any graphical images
* included with the Software, which may not be modified or altered), and (c)
* permit third-parties to whom the Software is furnished to do so, all
* subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.  
*
* Facebook, Inc. retains ownership of the Software and all associated
* intellectual property rights.  All rights not expressly granted in this
* license are reserved by Facebook, Inc.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/ 

#include "StdAfx.h"
#include "UserData.h"
#include <functional>

#pragma warning(disable : 4180)
#pragma warning(disable : 4244)
#include <boost/bind.hpp>
#include <boost/regex.hpp>
#include <boost/algorithm/string/regex.hpp>

#include "../util/HtmlUtils.h"

#ifdef _UNICODE
  typedef boost::wregex Regex;
#else
  typedef boost::regex Regex;
#endif


namespace facebook{

using namespace std;

// ---------------------------------------------------------------------
// class UserData
// ---------------------------------------------------------------------


UserData::UserData()  : 
   id_(), 
   name_(), 
   status_(_T(""), 0, _T("")) ,
   smallPicUrl_(_T("")), 
   squarePicUrl_(_T("")), 
   profileUdatedTime_(0),
   notesCount_(0), 
   wallPostsCount_(0),
   loginCookies_(_T("")) {

}

UserData::UserData(
      const String& id, 
      const String& name, 
      const Status& status,
      const String& smallPicUrl, 
      const String& squarePicUrl, 
      const unsigned int profileUdatedTime,
      const unsigned int notesCount, 
      const unsigned int wallPostsCount) :
   id_(id),
   name_(name),
   status_(status),
   smallPicUrl_(smallPicUrl) , 
   squarePicUrl_(squarePicUrl), 
   profileUdatedTime_(profileUdatedTime),
   notesCount_(notesCount), 
   wallPostsCount_(wallPostsCount),
   loginCookies_(_T("")) {
  status_.message_= encodeCharsHtmlCode(status_.message_);
}


const bool UserData::operator == (const UserData& other) const{
  return (id_ == other.id_ &&  
    name_ == other.name_ && 
    status_ == other.status_ &&
    smallPicUrl_ == other.smallPicUrl_ && 
    squarePicUrl_ == other.squarePicUrl_ && 
    notesCount_ == other.notesCount_ &&
    wallPostsCount_ == other.wallPostsCount_ &&
    loginCookies_ == other.loginCookies_);
}


// utilities


size_t facebook::getLastUpdateTime(const UserData& userData) {
  return max(userData.getStatusUpdateTime(), 
    userData.getProfileUdatedTime());
}

size_t facebook::getStatusUpdateTime(const UserData& userData) {
  const String statusMessage = userData.getStatusMessage();
  return statusMessage.empty() ? 0  : userData.getStatusUpdateTime();
}


void facebook::applyFilter(FriendsList& friends, const String& filter) {
  if (filter.empty()) {
    return; 
  }
  using namespace boost;
  using namespace boost::algorithm;

  // split the filter to search words
  StringsVector searchWords;
  searchWords = split_regex( searchWords, filter, regex("\\s+"));

  // list of the symbols that aren\t supported by regex
  // includes { } " ' * \ ( ) [ ] ? | +
  // if we find such symbol in the word dont create seach patterns after it
  StringsVector regexExceptions;
  regexExceptions.push_back(_T("{"));
  regexExceptions.push_back(_T("}"));
  regexExceptions.push_back(_T("\""));
  regexExceptions.push_back(_T("'"));
  regexExceptions.push_back(_T("*"));
  regexExceptions.push_back(_T("\\"));
  regexExceptions.push_back(_T("("));
  regexExceptions.push_back(_T(")"));
  regexExceptions.push_back(_T("["));
  regexExceptions.push_back(_T("]"));
  regexExceptions.push_back(_T("?"));
  regexExceptions.push_back(_T("|"));
  regexExceptions.push_back(_T("+"));

  // create search templates from search words
  vector< Regex > searchExpressions;
  bool stopSearching = false;

  for (unsigned int searchWordsIndex = 0; 
    searchWordsIndex < searchWords.size(); ++searchWordsIndex) {

    for (unsigned int regexExceptionsIndex = 0; 
      regexExceptionsIndex < regexExceptions.size(); ++regexExceptionsIndex) {
        if (searchWords[searchWordsIndex].find(regexExceptions[regexExceptionsIndex]) != String::npos) {
          stopSearching = true;
          break;
        }
    }
    if (stopSearching) {
      break;
    }
    String regularExpression = _T("\\b") + searchWords[searchWordsIndex];
    if (!searchWords[searchWordsIndex].empty()) {
      searchExpressions.push_back(Regex(regularExpression, 
        regex_constants::icase | regex_constants::normal));
    }
  }
  FriendsList friendsResult;
  //apply search templates to eeach friend name in list
  // if all templates match then add to result list
  for (unsigned int j = 0; j < friends.size(); ++j) {
    bool found = true;
    for(unsigned int k = 0; k < searchExpressions.size(); k++) {
      if (!regex_search (friends[j].getName(),  
          searchExpressions[k], regex_constants::match_default)) {
        found = false;
      }
    }
    if (found) {
      friendsResult.push_back(friends[j]);
    }
  }
  friends.swap(friendsResult);
}

void facebook::applySort(FriendsList& friends, SortMode& sortMode) {
  if (sortMode == NO_SORT) {
    return;
  }

  if  (sortMode == SORT_BY_PROFILE_UPDATE_TIME) {
    sort(friends.begin(), friends.end(),
       bind(greater<size_t>(), 
       bind(&UserData::getProfileUdatedTime, _1), 
       bind(&UserData::getProfileUdatedTime, _2)));
  }

  if  (sortMode == SORT_BY_NAME) {
    sort(friends.begin(), friends.end(),
       bind(StringCILess(), 
       bind(&UserData::getName , _1), 
       bind(&UserData::getName, _2)));
  }

  if  (sortMode == SORT_BY_STATUS_UPDATE_TIME) {
    sort(friends.begin(), friends.end(),
       bind(greater<size_t>(), 
       bind(getStatusUpdateTime , _1), 
       bind(getStatusUpdateTime, _2)));
  }

  if  (sortMode == SORT_BY_LAST_UPDATE_TIME) {
    sort(friends.begin(), friends.end(),
       bind(greater<size_t>(), 
       bind(getLastUpdateTime ,_1), 
       bind(getLastUpdateTime, _2)));
  }
}

} // !namespace facebook

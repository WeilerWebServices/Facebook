/**
* Facebook Internet Explorer Toolbar Software License 
* Copyright (c) 2009 Facebook, Inc. 
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (which, together with any graphical images included with such
* software, are collectively referred to below as the "Software") to (a) use,
* reproduce, display, distribute, execute, and transmit the Software, (b)
* prepare derivative works of the Software (excluding any graphical images
* included with the Software, which may not be modified or altered), and (c)
* permit third-parties to whom the Software is furnished to do so, all
* subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.  
*
* Facebook, Inc. retains ownership of the Software and all associated
* intellectual property rights.  All rights not expressly granted in this
* license are reserved by Facebook, Inc.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/ 

#include "StdAfx.h"
#include "md5.h"

/**
 * Auxiliary md5 structures and constants 
 * placed in anonymous namespace
 * below
 */

namespace facebook{

static BYTE PADDING[64] = {
  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

const UINT S11 = 7;
const UINT S12 = 12;
const UINT S13 = 17;
const UINT S14 = 22;
const UINT S21 = 5;
const UINT S22 = 9;
const UINT S23 = 14;
const UINT S24 = 20;
const UINT S31 = 4;
const UINT S32 = 11;
const UINT S33 = 16;
const UINT S34 = 23;
const UINT S41 = 6;
const UINT S42 = 10;
const UINT S43 = 15;
const UINT S44 = 21;

/**
* Converts a completed md5 digest into a TCHAR* string.
*/
TCHAR* Printmd5(BYTE md5digest[16]) {
   TCHAR chBuffer[256];
   TCHAR chEach[10];
   int nCount;

   memset(chBuffer, 0, 256);
   memset(chEach, 0, 10);

   for (nCount = 0; nCount < 16; nCount++) {
#if (_MSC_VER >= 1400)
      _stprintf_s(chEach, 10, _T("%02x"), md5digest[nCount]);
      _tcsncat_s(chBuffer, 256, chEach, sizeof(chEach));
#else
      _stprintf(chEach, _T("%02x"), md5digest[nCount]);
      _tcsncat(chBuffer, chEach, sizeof(chEach));
#endif
   }

   return _tcsdup(chBuffer);
}

NarrowString md5::encodeUtf8(const TCHAR* originalString) {
  NarrowString result;
  WORD byteSymbol;
  size_t length = _tcslen(originalString);
  for (size_t i = 0; i < length; ++i) {
    byteSymbol = (WORD)originalString[i];
    if (byteSymbol < 128) {
      result += (char)(byteSymbol);
    } else if (byteSymbol < 2048) {
      result += (char)((byteSymbol >> 6) | 192);
      result += (char)((byteSymbol & 63) | 128);
    } else {
      result += (char)((byteSymbol >> 12) | 224);
			result += (char)(((byteSymbol >> 6) & 63) | 128);
		  result += (char)((byteSymbol & 63) | 128);
    }
  }
  return result;
}

TCHAR* facebook::md5String(String szString) {
  md5 alg;
  NarrowString narrow = alg.encodeUtf8(szString.c_str());
  size_t nLen = narrow.size();
  alg.update((BYTE*)narrow.c_str(), (UINT)nLen);
  alg.finalize();

  return Printmd5(alg.digest());
}


// <-- md5 class implementation -->


void md5::init() {
  memset(count_, 0, 2 * sizeof(UINT));

  state_[0] = 0x67452301;
  state_[1] = 0xefcdab89;
  state_[2] = 0x98badcfe;
  state_[3] = 0x10325476;
}


void md5::update(BYTE* chInput, UINT nInputLen) {
  UINT i, index, partLen;

  // Compute number of bytes mod 64
  index = (unsigned int)((count_[0] >> 3) & 0x3F);

  // update number of bits
  if ((count_[0] += (nInputLen << 3)) < (nInputLen << 3)) {
    count_[1]++;                              
  }

  count_[1] += (nInputLen >> 29);

  partLen = 64 - index;

  // transform as many times as possible.
  if (nInputLen >= partLen) {
    memcpy( &buffer_[index], chInput, partLen );
    transform(buffer_);

    for (i = partLen; i + 63 < nInputLen; i += 64) {
      transform(&chInput[i]);  
    }

    index = 0;
  } else {
    i = 0;
  }

  // Buffer remaining input
  memcpy( &buffer_[index], &chInput[i], nInputLen-i );
}


void md5::finalize() {
  BYTE bits[8];
  UINT index, padLen;

  // Save number of bits
  encode (bits, count_, 8);

  // Pad out to 56 mod 64
  index = (unsigned int)((count_[0] >> 3) & 0x3f);
  padLen = (index < 56) ? (56 - index) : (120 - index);
  update(PADDING, padLen);

  // Append length (before padding)
  update (bits, 8);

  // Store state in digest
  encode (digest_, state_, 16);

  memset(count_, 0, 2 * sizeof(UINT));
  memset(state_, 0, 4 * sizeof(UINT));
  memset(buffer_,0, 64 * sizeof(BYTE));
} 

 
// md5 basic transformation. transforms state based on block.


void md5::transform (BYTE* block) {
  UINT a = state_[0];
  UINT b = state_[1];
  UINT c = state_[2];
  UINT d = state_[3];
  UINT x[16];

  decode(x, block, 64);

  // Round 1
  FF(a, b, c, d, x[ 0], S11, 0xd76aa478);
  FF(d, a, b, c, x[ 1], S12, 0xe8c7b756);
  FF(c, d, a, b, x[ 2], S13, 0x242070db);
  FF(b, c, d, a, x[ 3], S14, 0xc1bdceee);
  FF(a, b, c, d, x[ 4], S11, 0xf57c0faf);
  FF(d, a, b, c, x[ 5], S12, 0x4787c62a);
  FF(c, d, a, b, x[ 6], S13, 0xa8304613);
  FF(b, c, d, a, x[ 7], S14, 0xfd469501);
  FF(a, b, c, d, x[ 8], S11, 0x698098d8);
  FF(d, a, b, c, x[ 9], S12, 0x8b44f7af);
  FF(c, d, a, b, x[10], S13, 0xffff5bb1);
  FF(b, c, d, a, x[11], S14, 0x895cd7be);
  FF(a, b, c, d, x[12], S11, 0x6b901122);
  FF(d, a, b, c, x[13], S12, 0xfd987193);
  FF(c, d, a, b, x[14], S13, 0xa679438e);
  FF(b, c, d, a, x[15], S14, 0x49b40821);

  // Round 2
  GG(a, b, c, d, x[ 1], S21, 0xf61e2562);
  GG(d, a, b, c, x[ 6], S22, 0xc040b340);
  GG(c, d, a, b, x[11], S23, 0x265e5a51);
  GG(b, c, d, a, x[ 0], S24, 0xe9b6c7aa);
  GG(a, b, c, d, x[ 5], S21, 0xd62f105d);
  GG(d, a, b, c, x[10], S22,  0x2441453);
  GG(c, d, a, b, x[15], S23, 0xd8a1e681);
  GG(b, c, d, a, x[ 4], S24, 0xe7d3fbc8);
  GG(a, b, c, d, x[ 9], S21, 0x21e1cde6);
  GG(d, a, b, c, x[14], S22, 0xc33707d6);
  GG(c, d, a, b, x[ 3], S23, 0xf4d50d87);
  GG(b, c, d, a, x[ 8], S24, 0x455a14ed);
  GG(a, b, c, d, x[13], S21, 0xa9e3e905);
  GG(d, a, b, c, x[ 2], S22, 0xfcefa3f8);
  GG(c, d, a, b, x[ 7], S23, 0x676f02d9);
  GG(b, c, d, a, x[12], S24, 0x8d2a4c8a);

  // Round 3
  HH(a, b, c, d, x[ 5], S31, 0xfffa3942);
  HH(d, a, b, c, x[ 8], S32, 0x8771f681);
  HH(c, d, a, b, x[11], S33, 0x6d9d6122);
  HH(b, c, d, a, x[14], S34, 0xfde5380c);
  HH(a, b, c, d, x[ 1], S31, 0xa4beea44);
  HH(d, a, b, c, x[ 4], S32, 0x4bdecfa9);
  HH(c, d, a, b, x[ 7], S33, 0xf6bb4b60);
  HH(b, c, d, a, x[10], S34, 0xbebfbc70);
  HH(a, b, c, d, x[13], S31, 0x289b7ec6);
  HH(d, a, b, c, x[ 0], S32, 0xeaa127fa);
  HH(c, d, a, b, x[ 3], S33, 0xd4ef3085);
  HH(b, c, d, a, x[ 6], S34,  0x4881d05);
  HH(a, b, c, d, x[ 9], S31, 0xd9d4d039);
  HH(d, a, b, c, x[12], S32, 0xe6db99e5);
  HH(c, d, a, b, x[15], S33, 0x1fa27cf8);
  HH(b, c, d, a, x[ 2], S34, 0xc4ac5665);

  // Round 4
  II(a, b, c, d, x[ 0], S41, 0xf4292244);
  II(d, a, b, c, x[ 7], S42, 0x432aff97);
  II(c, d, a, b, x[14], S43, 0xab9423a7);
  II(b, c, d, a, x[ 5], S44, 0xfc93a039);
  II(a, b, c, d, x[12], S41, 0x655b59c3);
  II(d, a, b, c, x[ 3], S42, 0x8f0ccc92);
  II(c, d, a, b, x[10], S43, 0xffeff47d);
  II(b, c, d, a, x[ 1], S44, 0x85845dd1);
  II(a, b, c, d, x[ 8], S41, 0x6fa87e4f);
  II(d, a, b, c, x[15], S42, 0xfe2ce6e0);
  II(c, d, a, b, x[ 6], S43, 0xa3014314);
  II(b, c, d, a, x[13], S44, 0x4e0811a1);
  II(a, b, c, d, x[ 4], S41, 0xf7537e82);
  II(d, a, b, c, x[11], S42, 0xbd3af235);
  II(c, d, a, b, x[ 2], S43, 0x2ad7d2bb);
  II(b, c, d, a, x[ 9], S44, 0xeb86d391);

  state_[0] += a;
  state_[1] += b;
  state_[2] += c;
  state_[3] += d;

  memset(x, 0, sizeof(x));
}


void md5::encode(BYTE* dest, UINT* src, UINT nLength) {
  UINT i, j;

  for (i = 0, j = 0; j < nLength; i++, j += 4) {
    dest[j] = (BYTE)(src[i] & 0xff);
    dest[j+1] = (BYTE)((src[i] >> 8) & 0xff);
    dest[j+2] = (BYTE)((src[i] >> 16) & 0xff);
    dest[j+3] = (BYTE)((src[i] >> 24) & 0xff);
  }
}


void md5::decode(UINT* dest, BYTE* src, UINT nLength) {
  UINT i, j;                                   
  for (i = 0, j = 0; j < nLength; i++, j += 4) {
    dest[i] = ((UINT)src[j]) | (((UINT)src[j+1])<<8) |
            (((UINT)src[j+2])<<16) | (((UINT)src[j+3])<<24);
  }
}

} //!namespace facebook

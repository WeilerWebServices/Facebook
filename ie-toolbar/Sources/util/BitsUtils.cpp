/**
* Facebook Internet Explorer Toolbar Software License 
* Copyright (c) 2009 Facebook, Inc. 
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (which, together with any graphical images included with such
* software, are collectively referred to below as the "Software") to (a) use,
* reproduce, display, distribute, execute, and transmit the Software, (b)
* prepare derivative works of the Software (excluding any graphical images
* included with the Software, which may not be modified or altered), and (c)
* permit third-parties to whom the Software is furnished to do so, all
* subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.  
*
* Facebook, Inc. retains ownership of the Software and all associated
* intellectual property rights.  All rights not expressly granted in this
* license are reserved by Facebook, Inc.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/ 

#include "StdAfx.h"
#include "BitsUtils.h"

#include <time.h>

namespace facebook{

BitsUtils::BitsUtils() {
  initiazeBits();
}

BitsUtils::~BitsUtils() {
  releaseBits();
}

bool BitsUtils::initiazeBits() {
  HRESULT hr = S_FALSE;
  try {
    hr = CoCreateInstance(__uuidof(BackgroundCopyManager), NULL,
                        CLSCTX_LOCAL_SERVER,
                        __uuidof(IBackgroundCopyManager),
                        (void**) &bitsManager_);
  } catch (...) {
  }
 return SUCCEEDED(hr);
}

void BitsUtils::releaseBits() {
  if (bitsManager_) {
    bitsManager_->Release();
    bitsManager_ = NULL;
  }
}

bool BitsUtils::createDownload(const String& name, 
                               const String& url, 
                               const String& downloadFile) {
  bool result = false;
  if (!bitsManager_) {
    return result;
  }
  GUID jobId;
  IBackgroundCopyJob* job = NULL;
  HRESULT hr = bitsManager_->CreateJob(name.c_str(), BG_JOB_TYPE_DOWNLOAD, &jobId, &job);
  if (SUCCEEDED(hr))
  {
    hr = job->AddFile(url.c_str(), downloadFile.c_str());
    if (SUCCEEDED(hr)) {
      job->Resume();
      result = true;
    }
  }
  return result;

}

IBackgroundCopyJob* BitsUtils::getDownload(const String& name) {
  HRESULT hr = 0;
  IEnumBackgroundCopyJobs* jobs = NULL;
  IBackgroundCopyJob* job = NULL;
  ULONG jobCount = 0;
  ULONG index = 0;

  if (!bitsManager_) {
    return job;
  }
  // try to get for all users first, if not - get for current
  hr = bitsManager_->EnumJobs(BG_JOB_ENUM_ALL_USERS, &jobs);
  if (FAILED(hr)) {
    hr = bitsManager_->EnumJobs(0, &jobs);
  }
  if (SUCCEEDED(hr)) {
    //Get the count of jobs in the queue. 
    jobs->GetCount(&jobCount);
    WCHAR* jobName = NULL;
    //Enumerate the jobs in the queue.
    for (index  = 0; index < jobCount; ++index) {
      hr = jobs->Next(1, &job, NULL);
      if (SUCCEEDED(hr)) {
        if (SUCCEEDED(job->GetDisplayName(&jobName))) {
          String jobNameConverted = String(jobName);
          CoTaskMemFree(jobName);
          if (name == jobNameConverted) {
            // Vista issue - check for suspended state
            BG_JOB_STATE state;
            job->GetState(&state);
            if (state != BG_JOB_STATE_SUSPENDED) {
              break;
            }
          }
        }
        job->Release();
        job = NULL;
      } else {
        break;
      }
    }
    jobs->Release();
    jobs = NULL;
  }
  return job;
}

void BitsUtils::cancelDownload(const String& name) {
  IBackgroundCopyJob* job = getDownload(name);
  while (job) {
    job->Cancel();
    job->Release();
    job = getDownload(name);
  }
}

bool BitsUtils::completeDownload(const String& name) {
  HRESULT hr = S_FALSE;
  IBackgroundCopyJob* job = getDownload(name);
  if (job) {
   hr = job->Complete();
   job->Release();
   job = NULL;
  }
  return (SUCCEEDED(hr));
}

bool BitsUtils::isDownloadExpired(const String& name, 
                                  const int expirationHours) {

  IBackgroundCopyJob* job = getDownload(name);
  if (!job) {
    return false;
  }
  bool result = false;
  BG_JOB_TIMES times;
  HRESULT hr = job->GetTimes(&times);
  if (SUCCEEDED(hr)) {

    // 116444736000000000 nsecs
    const __int64 kEpochDiff = 0x019DB1DED53E8000LL; 
    // 100 nsecs
    const __int64 kRateDiff = 10000000;             

    //convert from filetime to time_t
    __int64 fileTime = ((__int64)times.CreationTime.dwHighDateTime << 32) 
      + times.CreationTime.dwLowDateTime;

    time_t jobTime = (time_t)(fileTime - kEpochDiff) / kRateDiff;
    // difference in secconds
    double timeDifference = difftime(time(NULL), jobTime);
    if (timeDifference > expirationHours * 3600) {
      result = true;
    }
  }
  return result;
}

BitsUtils::BitsDownloadStatus BitsUtils::checkDownloadStatus(const String& name) {
  BitsUtils::BitsDownloadStatus status = NO_DOWNLOAD;
  IBackgroundCopyJob* job = getDownload(name);
  if (!job) {
    status = NO_DOWNLOAD;
  } else {
    BG_JOB_STATE state;
    job->GetState(&state);
    switch (state) {
      case BG_JOB_STATE_ERROR:
        status = DOWNLOAD_FAILED;
        break;
      case BG_JOB_STATE_TRANSFERRED:
        status = DOWNLOAD_COMPLETED;
        break;
      case BG_JOB_STATE_SUSPENDED:
      default:
        status = DOWNLOAD_IN_PROGRESS;
    }
    job->Release();
  }
  return status;
}


}// !namespace facebook
